# App-Level Tool Configuration

> Layer: `services`, `routes_app`, `auth_middleware` crates | Status: âœ… Complete (Partially superseded by Phase 7.6)

> **Note**: The Keycloak integration described in this spec was **incorrect** and has been removed in Phase 7.6. See [05.6-external-app-tool-access.md](./05.6-external-app-tool-access.md) for the corrected approach. The app-level enable/disable now only updates the local database, with no Keycloak sync.

## Overview

Adds admin-controlled app-level tool enablement that gates user-level configuration. Creates a two-tier authorization model for session/first-party auth where tools must be enabled at both app-level (by admin) and user-level (by individual user) before use.

## Two-Tier Authorization Model (Session/First-Party)

```
Tool Usable = (app_enabled=true) AND (user_enabled=true) AND (user_api_key present)
```

- **App-Level** (admin): Stored in `app_tool_configs`, ~~synced with Keycloak client scopes~~ (local DB only)
- **User-Level** (existing): Stored in `user_tool_configs`, per-user API keys

**For OAuth/External Apps**: See [05.6-external-app-tool-access.md](./05.6-external-app-tool-access.md) for four-tier authorization.

## Database Schema

Add to existing migration `0007_tools_config.up.sql`:

```sql
CREATE TABLE IF NOT EXISTS app_tool_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tool_id TEXT NOT NULL UNIQUE,
    enabled INTEGER NOT NULL DEFAULT 0,
    updated_by TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_app_tool_configs_tool_id ON app_tool_configs(tool_id);
```

### Initial State

Fresh installations have no rows in `app_tool_configs`. Absence of row = `enabled=false`. Admin must explicitly enable each tool.

### Row Structure

```rust
pub struct AppToolConfigRow {
    pub id: i64,
    pub tool_id: String,
    pub enabled: bool,
    pub updated_by: String,      // user_id of admin who last updated
    pub created_at: i64,         // Unix timestamp
    pub updated_at: i64,
}
```

## ~~Keycloak Integration~~ (REMOVED in Phase 7.6)

> **This section is obsolete.** The Keycloak integration described here was based on incorrect understanding. App-level tool enable/disable now only updates the local database. See [05.6-external-app-tool-access.md](./05.6-external-app-tool-access.md) for the correct approach to external app authorization.

~~Follows existing pattern from `assign_user_role` - passthrough of admin's access token.~~

### ~~Enable Tool Scope~~

```
REMOVED - These endpoints do not exist on Keycloak
```

### ~~Disable Tool Scope~~

```
REMOVED - These endpoints do not exist on Keycloak
```

## ~~AuthService Additions~~ (REMOVED in Phase 7.6)

> **These methods have been removed** from the AuthService trait and implementation.

```rust
// REMOVED from AuthService trait
// async fn enable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()>;
// async fn disable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()>;
```

## ToolService Additions

### New Methods

```rust
// Add to ToolService trait
async fn get_app_tool_config(&self, tool_id: &str) -> Result<Option<AppToolConfig>, ToolError>;
async fn set_app_tool_enabled(
    &self,
    admin_token: &str,
    tool_id: &str,
    enabled: bool,
    updated_by: &str,
) -> Result<AppToolConfig, ToolError>;
async fn is_tool_enabled_for_app(&self, tool_id: &str) -> Result<bool, ToolError>;
```

### Modified Method

```rust
// Modify existing is_tool_available_for_user
async fn is_tool_available_for_user(&self, user_id: &str, tool_id: &str) -> Result<bool, ToolError> {
    // Check app-level first
    if !self.is_tool_enabled_for_app(tool_id).await? {
        return Ok(false);
    }
    // Then check user-level (existing logic)
    let config = self.db_service.get_user_tool_config(user_id, tool_id).await?;
    Ok(match config {
        Some(c) => c.enabled && c.encrypted_api_key.is_some(),
        None => false,
    })
}
```

### ~~Sync Strategy~~ (REMOVED in Phase 7.6)

> **This sync strategy is obsolete.** App-level enable/disable now only updates local DB.

When admin toggles app-level enable:

1. ~~Call Keycloak API first (enable or disable)~~
2. ~~On Keycloak success, update local DB~~
3. ~~If DB write fails after Keycloak success: Log error, return success (Keycloak is source of truth)~~
4. ~~If Keycloak fails: Return error, do not update DB~~

**New behavior (Phase 7.6)**: Simply update `app_tool_configs` table in local DB. No Keycloak interaction.

## Domain Objects

Add to `crates/objs/src/tools.rs`:

```rust
/// App-level tool configuration (public API model)
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppToolConfig {
    pub tool_id: String,
    pub enabled: bool,
    pub updated_by: String,
    #[schema(value_type = String, format = "date-time")]
    pub created_at: DateTime<Utc>,
    #[schema(value_type = String, format = "date-time")]
    pub updated_at: DateTime<Utc>,
}
```

## API Routes

### New Admin Routes

```rust
// PUT /tools/:tool_id/app-config - Enable tool for app
// Requires ResourceRole::Admin
pub async fn enable_app_tool(
    State(state): State<Arc<dyn RouterState>>,
    Path(tool_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolConfigResponse>, ApiError>

// DELETE /tools/:tool_id/app-config - Disable tool for app
// Requires ResourceRole::Admin
pub async fn disable_app_tool(
    State(state): State<Arc<dyn RouterState>>,
    Path(tool_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolConfigResponse>, ApiError>
```

### Response Enrichment

Modify existing endpoints to include `app_enabled`:

```rust
// GET /tools response
pub struct ToolListItem {
    pub definition: ToolDefinition,
    pub app_enabled: bool,
    pub user_config: Option<UserToolConfigSummary>,
}

// GET /tools/:tool_id/config response
pub struct GetToolConfigResponse {
    pub tool_id: String,
    pub app_enabled: bool,
    pub enabled: bool,
    pub has_api_key: bool,
}
```

### Route Registration

```rust
// Admin-only routes for app-level config
let tool_admin_apis = Router::new()
    .route("/bodhi/v1/tools/:tool_id/app-config", put(enable_app_tool))
    .route("/bodhi/v1/tools/:tool_id/app-config", delete(disable_app_tool))
    .route_layer(from_fn_with_state(state.clone(), move |s, r, n| {
        api_auth_middleware(ResourceRole::Admin, None, None, s, r, n)  // Admin + session only
    }));
```

## Middleware Updates

Update `tool_auth_middleware` to check app-level status:

```rust
// Add app-level check before user-level check
// is_tool_available_for_user now internally checks app-level first
let is_available = state
    .app_service()
    .tool_service()
    .is_tool_available_for_user(user_id, &tool_id)
    .await?;
```

Since `is_tool_available_for_user` is modified to check app-level first, the middleware code itself doesn't need changes - just the ToolService method it calls.

## UI Behavior

### Admin View (`/ui/tools`)

| Column | Description |
|--------|-------------|
| Tool Name | Tool identifier and description |
| App Enabled | Toggle with edit icon (admin-only column) |
| My Config | Personal enabled + API key status |

Admin sees two separate concerns:
1. **App Enabled**: Controls whether tool is available to all users
2. **My Config**: Admin's own personal tool configuration

### Regular User View (`/ui/tools`)

| Column | Description |
|--------|-------------|
| Tool Name | Tool identifier and description |
| Status | Shows "Disabled by Admin" if app_enabled=false |
| My Config | Personal config (greyed out if app disabled) |

When `app_enabled=false`:
- Tool is visible but marked as disabled
- User cannot edit their personal config
- User's preserved config state remains in DB

## Error Handling

| Scenario | Behavior |
|----------|----------|
| ~~Keycloak call fails~~ | ~~Return error to admin, do not update DB~~ (REMOVED) |
| ~~DB write fails after Keycloak success~~ | ~~Log error, return success~~ (REMOVED) |
| DB write fails | Return error to admin |
| Non-admin attempts app-config change | 403 Forbidden |
| Tool not found | 404 Not Found |

## Test Cases

1. **DB Layer**
   - CRUD for app_tool_configs
   - Default disabled state (no row = disabled)
   - Upsert behavior

2. **~~AuthService~~** (REMOVED in Phase 7.6)
   - ~~Keycloak enable call (mocked)~~
   - ~~Keycloak disable call (mocked)~~
   - ~~Error handling~~

3. **ToolService**
   - `is_tool_enabled_for_app` returns false when no row
   - `is_tool_enabled_for_app` returns true when enabled
   - `is_tool_available_for_user` checks app-level first
   - `set_app_tool_enabled` ~~calls Keycloak then~~ updates DB

4. **Routes**
   - Admin-only access enforcement
   - Response includes `app_enabled` field
   - PUT enables, DELETE disables

5. **Middleware**
   - Tool execution blocked when app-disabled
   - Tool execution allowed when app-enabled + user-configured

## Related Documents

- [05.6-external-app-tool-access.md](./05.6-external-app-tool-access.md) - Corrected approach for external app authorization (Phase 7.6)

# App-Level Tool Configuration

> Layer: `services`, `routes_app`, `auth_middleware` crates | Status: âœ… Complete

## Overview

Adds admin-controlled app-level tool enablement that gates user-level configuration. Creates a two-tier authorization model where tools must be enabled at both app-level (by admin) and user-level (by individual user) before use.

## Two-Tier Authorization Model

```
Tool Usable = (app_enabled=true) AND (user_enabled=true) AND (user_api_key present)
```

- **App-Level** (admin): Stored in `app_tool_configs`, synced with Keycloak client scopes
- **User-Level** (existing): Stored in `user_tool_configs`, per-user API keys

## Database Schema

Add to existing migration `0007_tools_config.up.sql`:

```sql
CREATE TABLE IF NOT EXISTS app_tool_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tool_id TEXT NOT NULL UNIQUE,
    enabled INTEGER NOT NULL DEFAULT 0,
    updated_by TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_app_tool_configs_tool_id ON app_tool_configs(tool_id);
```

### Initial State

Fresh installations have no rows in `app_tool_configs`. Absence of row = `enabled=false`. Admin must explicitly enable each tool.

### Row Structure

```rust
pub struct AppToolConfigRow {
    pub id: i64,
    pub tool_id: String,
    pub enabled: bool,
    pub updated_by: String,      // user_id of admin who last updated
    pub created_at: i64,         // Unix timestamp
    pub updated_at: i64,
}
```

## Keycloak Integration

Follows existing pattern from `assign_user_role` - passthrough of admin's access token.

### Enable Tool Scope

```
POST /realms/{realm}/bodhi/resources/tools
Authorization: Bearer <admin-access-token>
Content-Type: application/json

{ "tool_scope": "scope_tool-builtin-exa-web-search" }

Response: 200 OK (idempotent - returns 200 even if already enabled)
```

### Disable Tool Scope

```
DELETE /realms/{realm}/bodhi/resources/tools/{urlencoded_tool_scope}
Authorization: Bearer <admin-access-token>

Response: 200 OK (idempotent - returns 200 even if not found)
```

## AuthService Additions

```rust
// Add to AuthService trait
async fn enable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()>;
async fn disable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()>;
```

### Implementation in KeycloakAuthService

```rust
async fn enable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()> {
    let endpoint = format!(
        "{}/realms/{}/bodhi/resources/tools",
        self.auth_url, self.realm
    );

    let response = self
        .client
        .post(&endpoint)
        .bearer_auth(admin_token)
        .json(&serde_json::json!({ "tool_scope": tool_scope }))
        .header(HEADER_BODHI_APP_VERSION, &self.app_version)
        .send()
        .await?;

    if response.status().is_success() {
        Ok(())
    } else {
        let error = response.json::<KeycloakError>().await?;
        Err(error.into())
    }
}

async fn disable_tool_scope(&self, admin_token: &str, tool_scope: &str) -> Result<()> {
    let encoded_scope = urlencoding::encode(tool_scope);
    let endpoint = format!(
        "{}/realms/{}/bodhi/resources/tools/{}",
        self.auth_url, self.realm, encoded_scope
    );

    let response = self
        .client
        .delete(&endpoint)
        .bearer_auth(admin_token)
        .header(HEADER_BODHI_APP_VERSION, &self.app_version)
        .send()
        .await?;

    if response.status().is_success() {
        Ok(())
    } else {
        let error = response.json::<KeycloakError>().await?;
        Err(error.into())
    }
}
```

## ToolService Additions

### New Methods

```rust
// Add to ToolService trait
async fn get_app_tool_config(&self, tool_id: &str) -> Result<Option<AppToolConfig>, ToolError>;
async fn set_app_tool_enabled(
    &self,
    admin_token: &str,
    tool_id: &str,
    enabled: bool,
    updated_by: &str,
) -> Result<AppToolConfig, ToolError>;
async fn is_tool_enabled_for_app(&self, tool_id: &str) -> Result<bool, ToolError>;
```

### Modified Method

```rust
// Modify existing is_tool_available_for_user
async fn is_tool_available_for_user(&self, user_id: &str, tool_id: &str) -> Result<bool, ToolError> {
    // Check app-level first
    if !self.is_tool_enabled_for_app(tool_id).await? {
        return Ok(false);
    }
    // Then check user-level (existing logic)
    let config = self.db_service.get_user_tool_config(user_id, tool_id).await?;
    Ok(match config {
        Some(c) => c.enabled && c.encrypted_api_key.is_some(),
        None => false,
    })
}
```

### Sync Strategy

When admin toggles app-level enable:

1. Call Keycloak API first (enable or disable)
2. On Keycloak success, update local DB
3. If DB write fails after Keycloak success: Log error, return success (Keycloak is source of truth)
4. If Keycloak fails: Return error, do not update DB

## Domain Objects

Add to `crates/objs/src/tools.rs`:

```rust
/// App-level tool configuration (public API model)
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppToolConfig {
    pub tool_id: String,
    pub enabled: bool,
    pub updated_by: String,
    #[schema(value_type = String, format = "date-time")]
    pub created_at: DateTime<Utc>,
    #[schema(value_type = String, format = "date-time")]
    pub updated_at: DateTime<Utc>,
}
```

## API Routes

### New Admin Routes

```rust
// PUT /tools/:tool_id/app-config - Enable tool for app
// Requires ResourceRole::Admin
pub async fn enable_app_tool(
    State(state): State<Arc<dyn RouterState>>,
    Path(tool_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolConfigResponse>, ApiError>

// DELETE /tools/:tool_id/app-config - Disable tool for app
// Requires ResourceRole::Admin
pub async fn disable_app_tool(
    State(state): State<Arc<dyn RouterState>>,
    Path(tool_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolConfigResponse>, ApiError>
```

### Response Enrichment

Modify existing endpoints to include `app_enabled`:

```rust
// GET /tools response
pub struct ToolListItem {
    pub definition: ToolDefinition,
    pub app_enabled: bool,
    pub user_config: Option<UserToolConfigSummary>,
}

// GET /tools/:tool_id/config response
pub struct GetToolConfigResponse {
    pub tool_id: String,
    pub app_enabled: bool,
    pub enabled: bool,
    pub has_api_key: bool,
}
```

### Route Registration

```rust
// Admin-only routes for app-level config
let tool_admin_apis = Router::new()
    .route("/bodhi/v1/tools/:tool_id/app-config", put(enable_app_tool))
    .route("/bodhi/v1/tools/:tool_id/app-config", delete(disable_app_tool))
    .route_layer(from_fn_with_state(state.clone(), move |s, r, n| {
        api_auth_middleware(ResourceRole::Admin, None, None, s, r, n)  // Admin + session only
    }));
```

## Middleware Updates

Update `tool_auth_middleware` to check app-level status:

```rust
// Add app-level check before user-level check
// is_tool_available_for_user now internally checks app-level first
let is_available = state
    .app_service()
    .tool_service()
    .is_tool_available_for_user(user_id, &tool_id)
    .await?;
```

Since `is_tool_available_for_user` is modified to check app-level first, the middleware code itself doesn't need changes - just the ToolService method it calls.

## UI Behavior

### Admin View (`/ui/tools`)

| Column | Description |
|--------|-------------|
| Tool Name | Tool identifier and description |
| App Enabled | Toggle with edit icon (admin-only column) |
| My Config | Personal enabled + API key status |

Admin sees two separate concerns:
1. **App Enabled**: Controls whether tool is available to all users
2. **My Config**: Admin's own personal tool configuration

### Regular User View (`/ui/tools`)

| Column | Description |
|--------|-------------|
| Tool Name | Tool identifier and description |
| Status | Shows "Disabled by Admin" if app_enabled=false |
| My Config | Personal config (greyed out if app disabled) |

When `app_enabled=false`:
- Tool is visible but marked as disabled
- User cannot edit their personal config
- User's preserved config state remains in DB

## Error Handling

| Scenario | Behavior |
|----------|----------|
| Keycloak call fails | Return error to admin, do not update DB |
| DB write fails after Keycloak success | Log error, return success (Keycloak is source of truth) |
| Non-admin attempts app-config change | 403 Forbidden |
| Tool not found | 404 Not Found |

## Test Cases

1. **DB Layer**
   - CRUD for app_tool_configs
   - Default disabled state (no row = disabled)
   - Upsert behavior

2. **AuthService**
   - Keycloak enable call (mocked)
   - Keycloak disable call (mocked)
   - Error handling

3. **ToolService**
   - `is_tool_enabled_for_app` returns false when no row
   - `is_tool_enabled_for_app` returns true when enabled
   - `is_tool_available_for_user` checks app-level first
   - `set_app_tool_enabled` calls Keycloak then updates DB

4. **Routes**
   - Admin-only access enforcement
   - Response includes `app_enabled` field
   - PUT enables, DELETE disables

5. **Middleware**
   - Tool execution blocked when app-disabled
   - Tool execution allowed when app-enabled + user-configured

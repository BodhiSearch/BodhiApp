# App-Level Toolset Configuration

> Layer: `services`, `routes_app`, `auth_middleware` crates | Status: âœ… Complete

## Overview

Admin-controlled app-level toolset enablement that gates user-level configuration. Creates a two-tier authorization model for session/first-party auth where toolsets must be enabled at both app-level (by admin) and user-level (by individual user) before use.

## Two-Tier Authorization Model (Session/First-Party)

```
Toolset Usable = (app_enabled=true) AND (user_enabled=true) AND (user_api_key present)
```

- **App-Level** (admin): Stored in `app_toolset_configs`, local DB only
- **User-Level** (existing): Stored in `user_toolset_configs`, per-user API keys at toolset level

**For OAuth/External Apps**: See [05.6-external-app-toolset-access.md](./05.6-external-app-toolset-access.md) for four-tier authorization.

## Database Schema

```sql
CREATE TABLE IF NOT EXISTS app_toolset_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    toolset_id TEXT NOT NULL UNIQUE,
    enabled INTEGER NOT NULL DEFAULT 0,
    updated_by TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_app_toolset_configs_toolset_id ON app_toolset_configs(toolset_id);
```

### Initial State

Fresh installations seed `builtin-exa-web-search` as enabled. Admin can disable if needed.

### Row Structure

```rust
pub struct AppToolsetConfigRow {
    pub id: i64,
    pub toolset_id: String,
    pub enabled: bool,
    pub updated_by: String,
    pub created_at: i64,
    pub updated_at: i64,
}
```

## ToolsetService Methods

```rust
// Add to ToolsetService trait
async fn get_app_toolset_config(&self, toolset_id: &str) -> Result<Option<AppToolsetConfig>, ToolsetError>;
async fn set_app_toolset_enabled(
    &self,
    admin_token: &str,
    toolset_id: &str,
    enabled: bool,
    updated_by: &str,
) -> Result<AppToolsetConfig, ToolsetError>;
async fn is_toolset_enabled_for_app(&self, toolset_id: &str) -> Result<bool, ToolsetError>;
async fn list_app_toolset_configs(&self) -> Result<Vec<AppToolsetConfig>, ToolsetError>;
```

### Modified Method

```rust
// is_toolset_available_for_user checks app-level first
async fn is_toolset_available_for_user(&self, user_id: &str, toolset_id: &str) -> Result<bool, ToolsetError> {
    // Check app-level first
    if !self.is_toolset_enabled_for_app(toolset_id).await? {
        return Ok(false);
    }
    // Then check user-level
    let config = self.db_service.get_user_toolset_config(user_id, toolset_id).await?;
    Ok(match config {
        Some(c) => c.enabled && c.encrypted_api_key.is_some(),
        None => false,
    })
}
```

## Domain Objects

```rust
// crates/objs/src/toolsets.rs
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppToolsetConfig {
    pub toolset_id: String,
    pub enabled: bool,
    pub updated_by: String,
    #[schema(value_type = String, format = "date-time")]
    pub created_at: DateTime<Utc>,
    #[schema(value_type = String, format = "date-time")]
    pub updated_at: DateTime<Utc>,
}
```

## API Routes

### Admin Routes

```rust
// PUT /toolsets/:toolset_id/app-config - Enable toolset for app
// Requires ResourceRole::Admin
pub async fn enable_app_toolset(
    State(state): State<Arc<dyn RouterState>>,
    Path(toolset_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolsetConfigResponse>, ApiError>

// DELETE /toolsets/:toolset_id/app-config - Disable toolset for app
// Requires ResourceRole::Admin
pub async fn disable_app_toolset(
    State(state): State<Arc<dyn RouterState>>,
    Path(toolset_id): Path<String>,
    headers: HeaderMap,
) -> Result<Json<AppToolsetConfigResponse>, ApiError>
```

### Response Enrichment

All toolset endpoints include `app_enabled` status:

```rust
// GET /toolsets response
pub struct ToolsetListItem {
    pub toolset_id: String,
    pub name: String,
    pub description: String,
    pub app_enabled: bool,
    pub user_config: Option<UserToolsetConfigSummary>,
    pub tools: Vec<ToolDefinition>,
}

// GET /toolsets/:toolset_id/config response
pub struct EnhancedToolsetConfigResponse {
    pub toolset_id: String,
    pub app_enabled: bool,
    pub config: UserToolsetConfig,
}
```

## Middleware Updates

The `toolset_auth_middleware` checks app-level status:

```rust
// App-level check is first check for all auth types
if !toolset_service.is_toolset_enabled_for_app(&toolset_id).await? {
    return Err(ToolsetError::ToolsetAppDisabled.into());
}
```

## UI Behavior

### Admin View (`/ui/toolsets`)

| Column | Description |
|--------|-------------|
| Toolset Name | Toolset identifier and description |
| App Enabled | Toggle (admin-only) |
| My Config | Personal enabled + API key status |

### Regular User View (`/ui/toolsets`)

| Column | Description |
|--------|-------------|
| Toolset Name | Toolset identifier and description |
| Status | Shows "Disabled by Admin" if app_enabled=false |
| My Config | Personal config (greyed out if app disabled) |

When `app_enabled=false`:
- Toolset is visible but marked as disabled
- User cannot edit their personal config
- User's preserved config state remains in DB

## Error Handling

| Scenario | Behavior |
|----------|----------|
| DB write fails | Return error to admin |
| Non-admin attempts app-config change | 403 Forbidden |
| Toolset not found | 404 Not Found |

## Test Cases

1. **DB Layer**
   - CRUD for app_toolset_configs
   - Default state from migration seed
   - Upsert behavior

2. **ToolsetService**
   - `is_toolset_enabled_for_app` returns correct state
   - `is_toolset_available_for_user` checks app-level first
   - `set_app_toolset_enabled` updates DB

3. **Routes**
   - Admin-only access enforcement
   - Response includes `app_enabled` field
   - PUT enables, DELETE disables

4. **Middleware**
   - Toolset execution blocked when app-disabled
   - Toolset execution allowed when app-enabled + user-configured

## Related Documents

- [05.6-external-app-toolset-access.md](./05.6-external-app-toolset-access.md) - External app authorization with four-tier model

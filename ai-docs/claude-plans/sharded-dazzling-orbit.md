# Access Request Implementation Plan: Phases 0-1-2

## Context

The current `/apps/request-access` endpoint implements a server-to-server flow where apps register scopes with Keycloak through BodhiApp proxy. This approach grants apps automatic access to tool categories without explicit user consent for specific tool instances.

**Problem**: Users have no visibility into what tools an app requests access to. Apps get blanket access to toolsets without the ability for users to review, narrow, or deny specific tool access.

**Solution**: Transform into a user-approval flow where:
1. App creates a **draft** access request specifying tool types
2. BodhiApp returns a **review URL** where user can review and approve/deny
3. User explicitly maps tool types to specific tool instances they own
4. On approval, BodhiApp registers consent with Keycloak via custom SPI
5. App launches OAuth flow with dynamic scope `scope_access_request:<uuid>`
6. Tokens include `access_request_id` claim validated by BodhiApp middleware
7. Downstream APIs use `access_request_id` to look up approved tool instances

**Breaking Changes**: This is a clean cutover. The old `app_client_toolset_configs` table and server-to-server flow will be completely removed.

**Phase Scope**: This plan covers Phases 0 (KC verification - skipped), 1 (database & domain), and 2 (service layer). Later phases will handle API endpoints, middleware, frontend, and testing.

## Phase 0: Keycloak SPI Verification (SKIPPED)

**Status**: Assuming KC implementation is complete and deployed. No BodhiApp work needed in this phase.

**KC Contract Summary**:
- **Endpoint**: `POST {auth_url}/realms/{realm}/bodhi/users/request-access`
- **Auth**: Bearer token = user's ACCESS_TOKEN from session (NOT service account)
- **Request**: `{ app_client_id, access_request_id, description }`
- **Response 201**: `{ scope, access_request_id, access_request_scope }`
- **Response 200**: Idempotent retry (same response, treat as success)
- **Response 409**: UUID collision → mark request as failed, app creates new draft

See `/ai-docs/claude-plans/20260210-access-request/phase-0-1-2-ctx.md` for full KC integration details.

## Phase 1: Database Schema & Domain Objects

### 1.1 Migration: Drop Old Table

**Create**: `crates/services/migrations/0010_app_client_toolset_configs_drop.up.sql`

```sql
DROP TABLE IF EXISTS app_client_toolset_configs;
```

**Create**: `crates/services/migrations/0010_app_client_toolset_configs_drop.down.sql`

```sql
-- Recreate table from migration 0008 for rollback
CREATE TABLE IF NOT EXISTS app_client_toolset_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    app_client_id TEXT NOT NULL UNIQUE,
    config_version TEXT,
    toolsets_json TEXT NOT NULL,
    resource_scope TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);
```

### 1.2 Migration: Create New Table

**Create**: `crates/services/migrations/0011_app_access_requests.up.sql`

```sql
CREATE TABLE IF NOT EXISTS app_access_requests (
    id TEXT PRIMARY KEY,                    -- UUID (access_request_id)
    app_client_id TEXT NOT NULL,
    flow_type TEXT NOT NULL,                -- 'redirect' | 'popup'
    redirect_uri TEXT,                      -- Required for redirect flow
    status TEXT NOT NULL DEFAULT 'draft',   -- 'draft' | 'approved' | 'denied' | 'failed'
    tools_requested TEXT NOT NULL,          -- JSON: [{"tool_type": "builtin-exa-search"}]
    tools_approved TEXT,                    -- JSON: ["<toolset-uuid>", ...] (set on approval)
    user_id TEXT,                           -- NULL until user approves/denies
    resource_scope TEXT,                    -- KC-returned "scope_resource-xyz" (set after KC call)
    access_request_scope TEXT,              -- KC-returned "scope_access_request:<uuid>" (set after KC call)
    error_message TEXT,                     -- Error details when status='failed'
    expires_at INTEGER NOT NULL,            -- Unix timestamp, draft TTL = 10 minutes
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

CREATE INDEX idx_app_access_requests_status ON app_access_requests(status);
CREATE INDEX idx_app_access_requests_app_client ON app_access_requests(app_client_id);
```

**Notes**:
- `id` is UUID v4 generated by service layer (not database auto-increment)
- `tools_requested` stores array of objects: `[{"tool_type": "string"}]`
- `tools_approved` stores array of toolset UUIDs: `["uuid1", "uuid2"]`
- `error_message` stores KC error details when status='failed' (409 Conflict, etc.)
- `expires_at` enforces 10-minute TTL for drafts; checked at read time (no cleanup job)

**Create**: `crates/services/migrations/0011_app_access_requests.down.sql`

```sql
DROP TABLE IF EXISTS app_access_requests;
```

### 1.3 Domain Objects

**Create**: `crates/objs/src/access_request.rs`

```rust
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use utoipa::ToSchema;

#[derive(
  Debug,
  Clone,
  Copy,
  PartialEq,
  Eq,
  strum::Display,
  strum::EnumIter,
  strum::EnumString,
  Serialize,
  Deserialize,
  ToSchema,
)]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case")]
pub enum AppAccessRequestStatus {
  Draft,
  Approved,
  Denied,
  Failed,
}

#[derive(
  Debug,
  Clone,
  Copy,
  PartialEq,
  Eq,
  strum::Display,
  strum::EnumString,
  Serialize,
  Deserialize,
  ToSchema,
)]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case")]
pub enum AccessRequestFlowType {
  Redirect,
  Popup,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct ToolTypeRequest {
  pub tool_type: String,  // e.g., "builtin-exa-search"
}
```

**Modify**: `crates/objs/src/lib.rs`

Add re-exports:
```rust
pub use access_request::{
  AccessRequestFlowType,
  AppAccessRequestStatus,
  ToolTypeRequest,
};
```

### 1.4 Database Row Type

**Modify**: `crates/services/src/db/objs.rs`

Add row struct:
```rust
#[derive(Debug, Clone, PartialEq)]
pub struct AppAccessRequestRow {
  pub id: String,              // UUID (access_request_id)
  pub app_client_id: String,
  pub flow_type: String,       // "redirect" | "popup"
  pub redirect_uri: Option<String>,
  pub status: String,          // "draft" | "approved" | "denied" | "failed"
  pub tools_requested: String, // JSON: [{"tool_type":"..."}]
  pub tools_approved: Option<String>, // JSON: ["uuid1", "uuid2"]
  pub user_id: Option<String>,
  pub resource_scope: Option<String>,         // KC-returned scope
  pub access_request_scope: Option<String>,   // KC-returned scope
  pub error_message: Option<String>,          // Error details for 'failed' status
  pub expires_at: i64,         // Unix timestamp
  pub created_at: i64,
  pub updated_at: i64,
}
```

### 1.5 API Request/Response Types

**Modify**: `crates/services/src/lib.rs`

Add request/response structs:
```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppAccessRequest {
  pub app_client_id: String,
  pub flow_type: String,        // "redirect" | "popup"
  #[serde(skip_serializing_if = "Option::is_none")]
  pub redirect_uri: Option<String>,  // Required if flow_type == "redirect"
  pub tools: Vec<objs::ToolTypeRequest>,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppAccessResponse {
  pub access_request_id: String,
  pub review_url: String,
  #[serde(skip_serializing_if = "Vec::is_empty")]
  pub scopes: Vec<String>,     // Empty on draft creation, populated after approval
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema, PartialEq)]
pub struct AppAccessRequestDetail {
  pub id: String,
  pub app_client_id: String,
  pub flow_type: String,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub redirect_uri: Option<String>,
  pub status: String,
  pub tools_requested: Vec<objs::ToolTypeRequest>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub tools_approved: Option<Vec<String>>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub user_id: Option<String>,
  #[serde(skip_serializing_if = "Vec::is_empty")]
  pub scopes: Vec<String>,
  #[serde(skip_serializing_if = "Option::is_none")]
  pub error_message: Option<String>,
  #[schema(value_type = String, format = "date-time")]
  pub expires_at: DateTime<Utc>,
  #[schema(value_type = String, format = "date-time")]
  pub created_at: DateTime<Utc>,
  #[schema(value_type = String, format = "date-time")]
  pub updated_at: DateTime<Utc>,
}
```

**Pattern**: `AppAccessRequestDetail` is the public API representation returned by polling endpoint. Includes `DateTime<Utc>` fields for OpenAPI compliance.

## Phase 2: Service Layer Implementation

### 2.1 Error Types

**Create**: `crates/services/src/access_request_service/error.rs`

```rust
use crate::db::DbError;
use crate::auth_service::AuthServiceError;
use crate::tool_service::ToolsetError;
use objs::{AppError, ErrorType};

#[derive(Debug, thiserror::Error, errmeta_derive::ErrorMeta)]
#[error_meta(trait_to_impl = AppError)]
pub enum AccessRequestError {
  #[error("Access request '{0}' not found.")]
  #[error_meta(error_type = ErrorType::NotFound)]
  NotFound(String),

  #[error("Access request '{0}' has expired.")]
  #[error_meta(error_type = ErrorType::Gone)]
  Expired(String),

  #[error("Access request '{0}' has already been processed.")]
  #[error_meta(error_type = ErrorType::Conflict)]
  AlreadyProcessed(String),

  #[error("Invalid status '{0}' for access request.")]
  #[error_meta(error_type = ErrorType::BadRequest)]
  InvalidStatus(String),

  #[error("Invalid flow type '{0}'. Expected 'redirect' or 'popup'.")]
  #[error_meta(error_type = ErrorType::BadRequest)]
  InvalidFlowType(String),

  #[error("Redirect URI is required for redirect flow.")]
  #[error_meta(error_type = ErrorType::BadRequest)]
  MissingRedirectUri,

  #[error("Keycloak registration returned 409 Conflict (UUID collision). Please retry.")]
  #[error_meta(error_type = ErrorType::Conflict)]
  KcUuidCollision,

  #[error("Keycloak registration failed: {0}.")]
  #[error_meta(error_type = ErrorType::InternalServer)]
  KcRegistrationFailed(String),

  #[error(transparent)]
  DbError(#[from] DbError),

  #[error(transparent)]
  AuthError(#[from] AuthServiceError),

  #[error(transparent)]
  ToolError(#[from] ToolsetError),
}

pub type Result<T> = std::result::Result<T, AccessRequestError>;
```

### 2.2 Access Request Repository

**Create**: `crates/services/src/db/access_request_repository.rs`

```rust
use async_trait::async_trait;
use crate::db::error::DbError;
use crate::db::objs::AppAccessRequestRow;

#[async_trait]
pub trait AccessRequestRepository: Send + Sync {
  async fn create(&self, row: &AppAccessRequestRow) -> Result<AppAccessRequestRow, DbError>;

  async fn get(&self, id: &str) -> Result<Option<AppAccessRequestRow>, DbError>;

  async fn update_approval(
    &self,
    id: &str,
    user_id: &str,
    tools_approved: &str,       // JSON string
    resource_scope: &str,
    access_request_scope: &str,
  ) -> Result<AppAccessRequestRow, DbError>;

  async fn update_denial(
    &self,
    id: &str,
    user_id: &str,
  ) -> Result<AppAccessRequestRow, DbError>;

  async fn update_failure(
    &self,
    id: &str,
    error_message: &str,
  ) -> Result<AppAccessRequestRow, DbError>;
}
```

**Modify**: `crates/services/src/db/service.rs`

1. Import repository trait:
```rust
use crate::db::access_request_repository::AccessRequestRepository;
```

2. Add to `DbService` super-trait (around line 14-41):
```rust
pub trait DbService:
  ModelRepository
  + AccessRepository
  + TokenRepository
  + ToolsetRepository
  + UserAliasRepository
  + AccessRequestRepository  // Add this line
  + DbCore
  + Send
  + Sync
  + std::fmt::Debug
{
}
```

3. Update blanket impl:
```rust
impl<T> DbService for T where
  T: ModelRepository
    + AccessRepository
    + TokenRepository
    + ToolsetRepository
    + UserAliasRepository
    + AccessRequestRepository  // Add this line
    + DbCore
    + Send
    + Sync
    + std::fmt::Debug
{
}
```

4. Implement repository for `SqliteDbService`:
```rust
#[async_trait]
impl AccessRequestRepository for SqliteDbService {
  async fn create(&self, row: &AppAccessRequestRow) -> Result<AppAccessRequestRow, DbError> {
    let result = query_as::<_, (String, String, String, Option<String>, String, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>, i64, i64, i64)>(
      "INSERT INTO app_access_requests
        (id, app_client_id, flow_type, redirect_uri, status, tools_requested,
         tools_approved, user_id, resource_scope, access_request_scope, error_message,
         expires_at, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
       RETURNING id, app_client_id, flow_type, redirect_uri, status, tools_requested,
                 tools_approved, user_id, resource_scope, access_request_scope, error_message,
                 expires_at, created_at, updated_at"
    )
    .bind(&row.id)
    .bind(&row.app_client_id)
    .bind(&row.flow_type)
    .bind(&row.redirect_uri)
    .bind(&row.status)
    .bind(&row.tools_requested)
    .bind(&row.tools_approved)
    .bind(&row.user_id)
    .bind(&row.resource_scope)
    .bind(&row.access_request_scope)
    .bind(&row.error_message)
    .bind(row.expires_at)
    .bind(row.created_at)
    .bind(row.updated_at)
    .fetch_one(&self.pool)
    .await?;

    Ok(AppAccessRequestRow {
      id: result.0,
      app_client_id: result.1,
      flow_type: result.2,
      redirect_uri: result.3,
      status: result.4,
      tools_requested: result.5,
      tools_approved: result.6,
      user_id: result.7,
      resource_scope: result.8,
      access_request_scope: result.9,
      error_message: result.10,
      expires_at: result.11,
      created_at: result.12,
      updated_at: result.13,
    })
  }

  async fn get(&self, id: &str) -> Result<Option<AppAccessRequestRow>, DbError> {
    let result = query_as::<_, (String, String, String, Option<String>, String, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>, i64, i64, i64)>(
      "SELECT id, app_client_id, flow_type, redirect_uri, status, tools_requested,
              tools_approved, user_id, resource_scope, access_request_scope, error_message,
              expires_at, created_at, updated_at
       FROM app_access_requests WHERE id = ?"
    )
    .bind(id)
    .fetch_optional(&self.pool)
    .await?;

    Ok(result.map(|r| AppAccessRequestRow {
      id: r.0,
      app_client_id: r.1,
      flow_type: r.2,
      redirect_uri: r.3,
      status: r.4,
      tools_requested: r.5,
      tools_approved: r.6,
      user_id: r.7,
      resource_scope: r.8,
      access_request_scope: r.9,
      error_message: r.10,
      expires_at: r.11,
      created_at: r.12,
      updated_at: r.13,
    }))
  }

  async fn update_approval(
    &self,
    id: &str,
    user_id: &str,
    tools_approved: &str,
    resource_scope: &str,
    access_request_scope: &str,
  ) -> Result<AppAccessRequestRow, DbError> {
    let now = self.time_service.utc_now().timestamp();
    let result = query_as::<_, (String, String, String, Option<String>, String, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>, i64, i64, i64)>(
      "UPDATE app_access_requests
       SET status = 'approved', user_id = ?, tools_approved = ?,
           resource_scope = ?, access_request_scope = ?, updated_at = ?
       WHERE id = ?
       RETURNING id, app_client_id, flow_type, redirect_uri, status, tools_requested,
                 tools_approved, user_id, resource_scope, access_request_scope, error_message,
                 expires_at, created_at, updated_at"
    )
    .bind(user_id)
    .bind(tools_approved)
    .bind(resource_scope)
    .bind(access_request_scope)
    .bind(now)
    .bind(id)
    .fetch_one(&self.pool)
    .await?;

    Ok(AppAccessRequestRow {
      id: result.0,
      app_client_id: result.1,
      flow_type: result.2,
      redirect_uri: result.3,
      status: result.4,
      tools_requested: result.5,
      tools_approved: result.6,
      user_id: result.7,
      resource_scope: result.8,
      access_request_scope: result.9,
      error_message: result.10,
      expires_at: result.11,
      created_at: result.12,
      updated_at: result.13,
    })
  }

  async fn update_denial(
    &self,
    id: &str,
    user_id: &str,
  ) -> Result<AppAccessRequestRow, DbError> {
    let now = self.time_service.utc_now().timestamp();
    let result = query_as::<_, (String, String, String, Option<String>, String, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>, i64, i64, i64)>(
      "UPDATE app_access_requests
       SET status = 'denied', user_id = ?, updated_at = ?
       WHERE id = ?
       RETURNING id, app_client_id, flow_type, redirect_uri, status, tools_requested,
                 tools_approved, user_id, resource_scope, access_request_scope, error_message,
                 expires_at, created_at, updated_at"
    )
    .bind(user_id)
    .bind(now)
    .bind(id)
    .fetch_one(&self.pool)
    .await?;

    Ok(AppAccessRequestRow {
      id: result.0,
      app_client_id: result.1,
      flow_type: result.2,
      redirect_uri: result.3,
      status: result.4,
      tools_requested: result.5,
      tools_approved: result.6,
      user_id: result.7,
      resource_scope: result.8,
      access_request_scope: result.9,
      error_message: result.10,
      expires_at: result.11,
      created_at: result.12,
      updated_at: result.13,
    })
  }

  async fn update_failure(
    &self,
    id: &str,
    error_message: &str,
  ) -> Result<AppAccessRequestRow, DbError> {
    let now = self.time_service.utc_now().timestamp();
    let result = query_as::<_, (String, String, String, Option<String>, String, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>, i64, i64, i64)>(
      "UPDATE app_access_requests
       SET status = 'failed', error_message = ?, updated_at = ?
       WHERE id = ?
       RETURNING id, app_client_id, flow_type, redirect_uri, status, tools_requested,
                 tools_approved, user_id, resource_scope, access_request_scope, error_message,
                 expires_at, created_at, updated_at"
    )
    .bind(error_message)
    .bind(now)
    .bind(id)
    .fetch_one(&self.pool)
    .await?;

    Ok(AppAccessRequestRow {
      id: result.0,
      app_client_id: result.1,
      flow_type: result.2,
      redirect_uri: result.3,
      status: result.4,
      tools_requested: result.5,
      tools_approved: result.6,
      user_id: result.7,
      resource_scope: result.8,
      access_request_scope: result.9,
      error_message: result.10,
      expires_at: result.11,
      created_at: result.12,
      updated_at: result.13,
    })
  }
}
```

**Modify**: `crates/services/src/db/mod.rs`

Add module:
```rust
pub mod access_request_repository;
```

### 2.3 AuthService KC Registration Method

**Modify**: `crates/services/src/auth_service.rs`

1. Add response struct (after existing structs around line 10):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegisterAccessRequestConsentResponse {
  pub scope: String,
  pub access_request_id: String,
  pub access_request_scope: String,
}
```

2. Add trait method to `AuthService` trait (around line 50):
```rust
#[cfg_attr(any(test, feature = "test-utils"), mockall::automock)]
#[async_trait]
pub trait AuthService: Send + Sync + std::fmt::Debug {
  // ... existing methods ...

  async fn register_access_request_consent(
    &self,
    user_token: &str,
    app_client_id: &str,
    access_request_id: &str,
    description: &str,
  ) -> Result<RegisterAccessRequestConsentResponse>;
}
```

3. Implement in `KeycloakAuthService` (after existing impl methods around line 300):
```rust
#[async_trait]
impl AuthService for KeycloakAuthService {
  // ... existing methods ...

  async fn register_access_request_consent(
    &self,
    user_token: &str,
    app_client_id: &str,
    access_request_id: &str,
    description: &str,
  ) -> Result<RegisterAccessRequestConsentResponse> {
    let endpoint = format!(
      "{}/realms/{}/bodhi/users/request-access",
      self.auth_url, self.realm
    );

    log::log_http_request("POST", &endpoint, "auth_service", None);

    let request_body = serde_json::json!({
      "app_client_id": app_client_id,
      "access_request_id": access_request_id,
      "description": description,
    });

    let response = self
      .client
      .post(&endpoint)
      .json(&request_body)
      .header("Authorization", format!("Bearer {}", user_token))
      .header(HEADER_BODHI_APP_VERSION, &self.app_version)
      .send()
      .await?;

    let status = response.status();

    if status.is_success() {
      // 201 Created or 200 OK (idempotent retry)
      Ok(response.json::<RegisterAccessRequestConsentResponse>().await?)
    } else if status == 409 {
      // UUID collision - different context
      let error_text = response.text().await?;
      log::log_http_error("POST", &endpoint, "auth_service", &error_text);
      Err(AuthServiceError::TokenExchangeError(format!(
        "UUID collision (409): {}",
        error_text
      )))
    } else {
      // 400, 401, or other errors
      let error_text = response.text().await?;
      log::log_http_error("POST", &endpoint, "auth_service", &error_text);
      Err(AuthServiceError::AuthServiceApiError {
        status: status.as_u16(),
        body: error_text,
      })
    }
  }
}
```

### 2.4 AccessRequestService Implementation

**Create**: `crates/services/src/access_request_service/mod.rs`

```rust
pub mod error;
pub mod service;

pub use error::{AccessRequestError, Result};
pub use service::{AccessRequestService, DefaultAccessRequestService};
```

**Create**: `crates/services/src/access_request_service/service.rs`

```rust
use async_trait::async_trait;
use chrono::{Duration, Utc};
use std::sync::Arc;
use uuid::Uuid;

use crate::access_request_service::error::{AccessRequestError, Result};
use crate::auth_service::AuthService;
use crate::db::objs::AppAccessRequestRow;
use crate::db::service::DbService;
use crate::time_service::TimeService;
use crate::tool_service::ToolService;

#[cfg_attr(any(test, feature = "test-utils"), mockall::automock)]
#[async_trait]
pub trait AccessRequestService: Send + Sync + std::fmt::Debug {
  /// Create a draft access request
  async fn create_draft(
    &self,
    app_client_id: String,
    flow_type: String,
    redirect_uri: Option<String>,
    tools_requested: Vec<String>,  // JSON-serialized array
  ) -> Result<AppAccessRequestRow>;

  /// Get access request by ID
  async fn get_request(&self, id: &str) -> Result<Option<AppAccessRequestRow>>;

  /// Approve access request and register with KC
  async fn approve_request(
    &self,
    id: &str,
    user_id: &str,
    user_token: &str,
    tools_approved_uuids: Vec<String>,
  ) -> Result<AppAccessRequestRow>;

  /// Deny access request
  async fn deny_request(&self, id: &str, user_id: &str) -> Result<AppAccessRequestRow>;

  /// Build review URL for a given access request ID
  fn build_review_url(&self, access_request_id: &str) -> String;
}

#[derive(Debug)]
pub struct DefaultAccessRequestService {
  db_service: Arc<dyn DbService>,
  auth_service: Arc<dyn AuthService>,
  tool_service: Arc<dyn ToolService>,
  time_service: Arc<dyn TimeService>,
  frontend_url: String,
}

impl DefaultAccessRequestService {
  pub fn new(
    db_service: Arc<dyn DbService>,
    auth_service: Arc<dyn AuthService>,
    tool_service: Arc<dyn ToolService>,
    time_service: Arc<dyn TimeService>,
    frontend_url: String,
  ) -> Self {
    Self {
      db_service,
      auth_service,
      tool_service,
      time_service,
      frontend_url,
    }
  }

  /// Generate description for KC consent screen from tool UUIDs
  async fn generate_description(&self, tool_uuids: &[String]) -> Result<String> {
    let mut lines = Vec::new();
    for uuid in tool_uuids {
      match self.tool_service.get_toolset_by_id(uuid).await {
        Ok(Some(toolset)) => lines.push(format!("- {}", toolset.name)),
        Ok(None) => lines.push(format!("- Unknown tool ({})", uuid)),
        Err(_) => lines.push(format!("- Unknown tool ({})", uuid)),
      }
    }
    Ok(lines.join("\n"))
  }
}

#[async_trait]
impl AccessRequestService for DefaultAccessRequestService {
  async fn create_draft(
    &self,
    app_client_id: String,
    flow_type: String,
    redirect_uri: Option<String>,
    tools_requested: Vec<String>,
  ) -> Result<AppAccessRequestRow> {
    // Validate flow type
    if flow_type != "redirect" && flow_type != "popup" {
      return Err(AccessRequestError::InvalidFlowType(flow_type));
    }

    // Validate redirect_uri for redirect flow
    if flow_type == "redirect" && redirect_uri.is_none() {
      return Err(AccessRequestError::MissingRedirectUri);
    }

    // Generate UUID
    let access_request_id = Uuid::new_v4().to_string();

    let now = self.time_service.utc_now();
    let expires_at = now + Duration::minutes(10);

    // Serialize tools_requested to JSON
    let tools_requested_json = serde_json::to_string(&tools_requested)
      .map_err(|e| AccessRequestError::InvalidStatus(format!("JSON serialization failed: {}", e)))?;

    let row = AppAccessRequestRow {
      id: access_request_id,
      app_client_id,
      flow_type,
      redirect_uri,
      status: "draft".to_string(),
      tools_requested: tools_requested_json,
      tools_approved: None,
      user_id: None,
      resource_scope: None,
      access_request_scope: None,
      error_message: None,
      expires_at: expires_at.timestamp(),
      created_at: now.timestamp(),
      updated_at: now.timestamp(),
    };

    let created_row = self.db_service.create(&row).await?;
    Ok(created_row)
  }

  async fn get_request(&self, id: &str) -> Result<Option<AppAccessRequestRow>> {
    let row = self.db_service.get(id).await?;

    if let Some(row) = row {
      // Check expiry for draft status
      if row.status == "draft" {
        let now = self.time_service.utc_now().timestamp();
        if row.expires_at < now {
          return Err(AccessRequestError::Expired(id.to_string()));
        }
      }
      Ok(Some(row))
    } else {
      Ok(None)
    }
  }

  async fn approve_request(
    &self,
    id: &str,
    user_id: &str,
    user_token: &str,
    tools_approved_uuids: Vec<String>,
  ) -> Result<AppAccessRequestRow> {
    // Get current request
    let row = self.get_request(id).await?
      .ok_or_else(|| AccessRequestError::NotFound(id.to_string()))?;

    // Check status
    if row.status != "draft" {
      return Err(AccessRequestError::AlreadyProcessed(id.to_string()));
    }

    // Generate consent description from tool UUIDs
    let description = self.generate_description(&tools_approved_uuids).await?;

    // Call KC to register consent
    let kc_response = match self
      .auth_service
      .register_access_request_consent(user_token, &row.app_client_id, id, &description)
      .await
    {
      Ok(resp) => resp,
      Err(e) => {
        // Check if 409 Conflict
        let error_msg = e.to_string();
        if error_msg.contains("409") || error_msg.contains("UUID collision") {
          // Mark as failed, app must create new draft
          let failure_msg = "KC registration failed: UUID collision (409). Please retry with new request.";
          let failed_row = self.db_service.update_failure(id, failure_msg).await?;
          return Ok(failed_row);
        } else {
          // Network error or other failure - keep as draft for retry
          return Err(AccessRequestError::KcRegistrationFailed(error_msg));
        }
      }
    };

    // Serialize tools_approved to JSON
    let tools_approved_json = serde_json::to_string(&tools_approved_uuids)
      .map_err(|e| AccessRequestError::InvalidStatus(format!("JSON serialization failed: {}", e)))?;

    // Update database with approval
    let updated_row = self
      .db_service
      .update_approval(
        id,
        user_id,
        &tools_approved_json,
        &kc_response.scope,
        &kc_response.access_request_scope,
      )
      .await?;

    Ok(updated_row)
  }

  async fn deny_request(&self, id: &str, user_id: &str) -> Result<AppAccessRequestRow> {
    // Get current request
    let row = self.get_request(id).await?
      .ok_or_else(|| AccessRequestError::NotFound(id.to_string()))?;

    // Check status
    if row.status != "draft" {
      return Err(AccessRequestError::AlreadyProcessed(id.to_string()));
    }

    // Update database with denial
    let updated_row = self.db_service.update_denial(id, user_id).await?;
    Ok(updated_row)
  }

  fn build_review_url(&self, access_request_id: &str) -> String {
    format!(
      "{}/ui/apps/request-access/review?id={}",
      self.frontend_url, access_request_id
    )
  }
}
```

**Modify**: `crates/services/src/lib.rs`

Add exports:
```rust
pub mod access_request_service;
pub use access_request_service::{AccessRequestError, AccessRequestService, DefaultAccessRequestService};
```

### 2.5 Register AccessRequestService in AppService

**Modify**: `crates/services/src/app_service.rs`

1. Add getter to trait (around line 15):
```rust
#[cfg_attr(test, mockall::automock)]
pub trait AppService: std::fmt::Debug + Send + Sync {
  // ... existing getters ...
  fn access_request_service(&self) -> Arc<dyn AccessRequestService>;
}
```

2. Add field to `DefaultAppService` (around line 30):
```rust
#[derive(Clone, Debug)]
pub struct DefaultAppService {
  // ... existing fields ...
  access_request_service: Arc<dyn AccessRequestService>,
}
```

3. Update constructor parameter list (around line 45):
```rust
impl DefaultAppService {
  pub fn new(
    // ... existing params ...
    access_request_service: Arc<dyn AccessRequestService>,
  ) -> Self {
    Self {
      // ... existing assignments ...
      access_request_service,
    }
  }
}
```

4. Implement getter (around line 60):
```rust
impl AppService for DefaultAppService {
  // ... existing getters ...
  fn access_request_service(&self) -> Arc<dyn AccessRequestService> {
    Arc::clone(&self.access_request_service)
  }
}
```

### 2.6 Remove Old Code

**Search for usages before deletion**:
```bash
# Grep for old method names
grep -r "request_access" crates/services/src/
grep -r "is_app_client_registered_for_toolset" crates/services/src/
grep -r "get_app_client_toolset_config" crates/services/src/
grep -r "upsert_app_client_toolset_config" crates/services/src/
grep -r "AppClientToolsetConfigRow" crates/

# Check test files explicitly
grep -r "request_access\|is_app_client_registered_for_toolset\|get_app_client_toolset_config\|AppClientToolsetConfigRow" crates/services/src/db/tests/
grep -r "request_access\|is_app_client_registered_for_toolset\|get_app_client_toolset_config\|AppClientToolsetConfigRow" crates/services/tests/
```

**Delete after confirming no usages**:

1. **In `crates/services/src/auth_service.rs`**:
   - Remove `request_access()` method from trait
   - Remove `RequestAccessRequest` struct
   - Remove `RequestAccessResponse` struct
   - Remove implementation in `KeycloakAuthService`

2. **In `crates/services/src/tool_service/service.rs`**:
   - Remove `is_app_client_registered_for_toolset()` method from trait
   - Remove implementation in `DefaultToolService`

3. **In `crates/services/src/db/toolset_repository.rs`**:
   - Remove `get_app_client_toolset_config()` method from trait
   - Remove `upsert_app_client_toolset_config()` method from trait
   - Remove implementations in `SqliteDbService`

4. **In `crates/services/src/db/objs.rs`**:
   - Remove `AppClientToolsetConfigRow` struct

5. **In `crates/services/src/lib.rs`**:
   - Remove exports for deleted types

## Testing Strategy

### Unit Tests: Repository Layer

**Create**: `crates/services/src/db/tests/access_request_tests.rs`

```rust
use rstest::rstest;
use rstest_reuse::*;
use anyhow::Result;
use chrono::Duration;

use crate::db::access_request_repository::AccessRequestRepository;
use crate::db::objs::AppAccessRequestRow;
use crate::tests::fixtures::test_db_service::test_db_service;
use crate::tests::fixtures::TestDbService;

#[rstest]
#[awt]
#[anyhow_trace]
#[tokio::test]
async fn test_create_draft_request(
  #[future]
  #[from(test_db_service)]
  service: TestDbService,
) -> Result<()> {
  let now = service.now();
  let expires_at = now + Duration::minutes(10);

  let row = AppAccessRequestRow {
    id: "550e8400-e29b-41d4-a716-446655440000".to_string(),
    app_client_id: "app-abc123".to_string(),
    flow_type: "redirect".to_string(),
    redirect_uri: Some("https://example.com/callback".to_string()),
    status: "draft".to_string(),
    tools_requested: r#"[{"tool_type":"builtin-exa-search"}]"#.to_string(),
    tools_approved: None,
    user_id: None,
    resource_scope: None,
    access_request_scope: None,
    error_message: None,
    expires_at: expires_at.timestamp(),
    created_at: now.timestamp(),
    updated_at: now.timestamp(),
  };

  let result = service.create(&row).await?;
  assert_eq!(result.id, row.id);
  assert_eq!(result.status, "draft");
  assert_eq!(result.app_client_id, row.app_client_id);
  Ok(())
}

#[rstest]
#[awt]
#[anyhow_trace]
#[tokio::test]
async fn test_update_approval(
  #[future]
  #[from(test_db_service)]
  service: TestDbService,
) -> Result<()> {
  // Create draft
  let now = service.now();
  let expires_at = now + Duration::minutes(10);
  let row = AppAccessRequestRow {
    id: "550e8400-e29b-41d4-a716-446655440000".to_string(),
    app_client_id: "app-abc123".to_string(),
    flow_type: "redirect".to_string(),
    redirect_uri: Some("https://example.com/callback".to_string()),
    status: "draft".to_string(),
    tools_requested: r#"[{"tool_type":"builtin-exa-search"}]"#.to_string(),
    tools_approved: None,
    user_id: None,
    resource_scope: None,
    access_request_scope: None,
    error_message: None,
    expires_at: expires_at.timestamp(),
    created_at: now.timestamp(),
    updated_at: now.timestamp(),
  };
  service.create(&row).await?;

  // Approve
  let tools_approved_json = r#"["uuid1","uuid2"]"#;
  let result = service
    .update_approval(
      &row.id,
      "user-uuid",
      tools_approved_json,
      "scope_resource-xyz",
      "scope_access_request:550e8400-e29b-41d4-a716-446655440000",
    )
    .await?;

  assert_eq!(result.status, "approved");
  assert_eq!(result.user_id, Some("user-uuid".to_string()));
  assert_eq!(result.tools_approved, Some(tools_approved_json.to_string()));
  assert_eq!(result.resource_scope, Some("scope_resource-xyz".to_string()));
  Ok(())
}

// Add more tests for:
// - test_update_denial
// - test_update_failure
// - test_get_request
// - test_get_nonexistent_request
```

### Unit Tests: Service Layer

**Create**: `crates/services/src/tests/access_request_service_tests.rs`

```rust
use rstest::rstest;
use mockall::predicate::*;
use std::sync::Arc;

use crate::access_request_service::{AccessRequestService, DefaultAccessRequestService};
use crate::db::service::MockDbService;
use crate::auth_service::{MockAuthService, RegisterAccessRequestConsentResponse};
use crate::tool_service::MockToolService;
use crate::time_service::FrozenTimeService;

#[rstest]
#[tokio::test]
async fn test_create_draft_generates_uuid() {
  let mut mock_db = MockDbService::new();
  let mock_auth = MockAuthService::new();
  let mock_tool = MockToolService::new();
  let time_service = Arc::new(FrozenTimeService::default());

  mock_db
    .expect_create()
    .returning(|row| Ok(row.clone()));

  let service = DefaultAccessRequestService::new(
    Arc::new(mock_db),
    Arc::new(mock_auth),
    Arc::new(mock_tool),
    time_service,
    "https://example.com".to_string(),
  );

  let result = service
    .create_draft(
      "app-abc123".to_string(),
      "redirect".to_string(),
      Some("https://example.com/callback".to_string()),
      vec![r#"{"tool_type":"builtin-exa-search"}"#.to_string()],
    )
    .await
    .unwrap();

  assert_eq!(result.status, "draft");
  assert!(!result.id.is_empty());
  assert_eq!(result.app_client_id, "app-abc123");
}

#[rstest]
#[tokio::test]
async fn test_approve_request_calls_kc() {
  let mut mock_db = MockDbService::new();
  let mut mock_auth = MockAuthService::new();
  let mut mock_tool = MockToolService::new();
  let time_service = Arc::new(FrozenTimeService::default());

  // Mock get - returns draft
  mock_db
    .expect_get()
    .returning(|_| {
      Ok(Some(AppAccessRequestRow {
        id: "550e8400-e29b-41d4-a716-446655440000".to_string(),
        app_client_id: "app-abc123".to_string(),
        status: "draft".to_string(),
        // ... other fields
      }))
    });

  // Mock toolset lookup for description generation
  mock_tool
    .expect_get_toolset_by_id()
    .returning(|_| Ok(Some(Toolset { name: "Exa Search".to_string(), /* ... */ })));

  // Mock KC call
  mock_auth
    .expect_register_access_request_consent()
    .withf(|token, app_id, req_id, desc| {
      token == "user-token"
        && app_id == "app-abc123"
        && req_id == "550e8400-e29b-41d4-a716-446655440000"
        && desc.contains("Exa Search")
    })
    .returning(|_, _, _, _| {
      Ok(RegisterAccessRequestConsentResponse {
        scope: "scope_resource-xyz".to_string(),
        access_request_id: "550e8400-e29b-41d4-a716-446655440000".to_string(),
        access_request_scope: "scope_access_request:550e8400-e29b-41d4-a716-446655440000".to_string(),
      })
    });

  // Mock update_approval
  mock_db
    .expect_update_approval()
    .returning(|_, _, _, _, _| {
      Ok(AppAccessRequestRow {
        status: "approved".to_string(),
        // ... other fields
      })
    });

  let service = DefaultAccessRequestService::new(
    Arc::new(mock_db),
    Arc::new(mock_auth),
    Arc::new(mock_tool),
    time_service,
    "https://example.com".to_string(),
  );

  let result = service
    .approve_request(
      "550e8400-e29b-41d4-a716-446655440000",
      "user-uuid",
      "user-token",
      vec!["toolset-uuid-1".to_string()],
    )
    .await
    .unwrap();

  assert_eq!(result.status, "approved");
}

// Add more tests for:
// - test_approve_request_handles_409_conflict
// - test_deny_request
// - test_get_expired_request_returns_error
// - test_create_draft_validates_flow_type
// - test_create_draft_validates_redirect_uri
```

## Verification Steps

### Phase 1 Verification

1. **Migration execution**:
```bash
cargo test -p services --test db_tests
```

2. **Compilation check**:
```bash
cargo check -p objs
cargo check -p services
```

3. **Verify migration files created**:
```bash
ls crates/services/migrations/ | grep "0010\|0011"
```

### Phase 2 Verification

1. **Repository tests**:
```bash
cargo test -p services access_request_repository
```

2. **Service tests**:
```bash
cargo test -p services access_request_service
```

3. **Full service crate tests**:
```bash
cargo test -p services
```

4. **Verify old code removed**:
```bash
# Should return no results
grep -r "request_access\|AppClientToolsetConfigRow" crates/services/src/ | grep -v "access_request"
```

### Integration Verification (Manual)

1. Start application with migrations:
```bash
make run.app
```

2. Check logs for successful migration execution

3. Verify database schema:
```bash
sqlite3 data/bodhi.db ".schema app_access_requests"
```

## Critical Files Modified

### Phase 1
- `crates/services/migrations/0010_app_client_toolset_configs_drop.{up,down}.sql`
- `crates/services/migrations/0011_app_access_requests.{up,down}.sql`
- `crates/objs/src/access_request.rs`
- `crates/objs/src/lib.rs`
- `crates/services/src/db/objs.rs`
- `crates/services/src/lib.rs`

### Phase 2
- `crates/services/src/access_request_service/error.rs`
- `crates/services/src/access_request_service/service.rs`
- `crates/services/src/access_request_service/mod.rs`
- `crates/services/src/db/access_request_repository.rs`
- `crates/services/src/db/service.rs`
- `crates/services/src/db/mod.rs`
- `crates/services/src/auth_service.rs`
- `crates/services/src/app_service.rs`
- `crates/services/src/lib.rs`

### Tests
- `crates/services/src/db/tests/access_request_tests.rs`
- `crates/services/src/tests/access_request_service_tests.rs`

## Next Phases Preview

- **Phase 3**: API endpoints (POST /apps/request-access, GET /apps/request-access)
- **Phase 4**: Auth middleware changes (validate access_request_id claim)
- **Phase 5**: Remove old endpoint
- **Phase 6**: Frontend review/approve page
- **Phase 7**: Comprehensive tests
- **Phase 8**: Frontend component tests
- **Phase 9**: E2E tests with real Keycloak

## Notes

- **UUID Generation**: Service layer generates UUIDs on draft creation using `Uuid::new_v4()`
- **Expiry Enforcement**: Check `expires_at` at read time; return 410 Gone if expired
- **Two-Phase Polling**: Draft creation returns empty scopes; app polls after approval for populated scopes
- **Error Handling**: 409 from KC → mark as 'failed'; network errors → keep as 'draft'
- **TimeService Usage**: All timestamp operations use injected `TimeService` for testability
- **Clean Cutover**: No feature flags; old code deleted completely in Phase 2

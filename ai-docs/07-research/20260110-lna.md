# Local Network Access (LNA) - Updated Research Report

**Date:** 2026-01-10
**Version:** 2.0 (Permission-First Approach)
**Sources:** 2025/2026 only
**Status:** Complete

---

## Executive Summary

**Local Network Access (LNA)** is a browser security feature that restricts websites from accessing devices on a user's local network through **user permission prompts**. Launched in Chrome 142 (October 2025), LNA is **purely client-side** enforcement with no server-side control mechanism.

**Critical Understanding:**

> With Chrome 142, local network requests are blocked **before** CORS is evaluated. Server headers cannot bypass LNA restrictions.

**Key Impacts:**
- **Frontend-heavy**: Permission management, iframe delegation, mixed-content handling
- **Backend-minimal**: Standard CORS headers only; no special LNA headers needed
- **No server control**: Cannot override browser permission prompt from backend
- **Affects**: Tauri desktop apps, Docker/self-hosted deployments, development environments

**Deployment Status:**
- Chrome 142+ (Oct 2025): Enforced
- Edge 143+ (Nov 2025): Enforced
- Firefox Nightly 143+: In development
- Safari: No web LNA (OS-level only for native apps)

---

## 1. What is Local Network Access?

### Definition

LNA restricts websites from sending HTTP requests to servers on private networks unless the user explicitly grants permission. This protects against:

1. **CSRF attacks** - Malicious sites attacking routers, IoT devices, NAS systems
2. **Network fingerprinting** - Sites enumerating local devices to track users

### IP Address Space Classification

| Address Space | Description | Examples |
|---------------|-------------|----------|
| **Public** | Globally reachable internet addresses | Most IPs outside reserved ranges |
| **Local** | Private network addresses (RFC 1918, etc.) | 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, fc00::/7, fe80::/10 |
| **Loopback** | Local machine only | 127.0.0.0/8, ::1/128 |

**Rule:** A request is a "local network request" if the target IP is **less public** than the origin:
- Public website → Local IP = blocked
- Public website → Loopback = blocked
- Local site → Loopback = blocked
- Same address space = allowed (no prompt)

### User Experience

When website attempts local network access:

1. **Permission prompt appears**:
   `"[website] wants to look for and connect to any device on your local network"`

2. **User choices**:
   - **Allow**: Permission granted, requests proceed
   - **Block**: Permission denied, requests fail
   - *Close prompt*: Treated as "Block"

3. **Permission persists**: Remembered per-origin until user changes settings

---

## 2. Two Permission Types

The [Local Network Access specification](https://wicg.github.io/local-network-access/) defines **two distinct permissions**:

### `local-network` Permission

**Covers:** Private address ranges
**Examples:**
- 10.0.0.0/8 (RFC 1918 Class A)
- 172.16.0.0/12 (RFC 1918 Class B)
- 192.168.0.0/16 (RFC 1918 Class C)
- fc00::/7 (IPv6 Unique Local)
- fe80::/10 (IPv6 Link-Local)

**Use case:** Accessing local network devices (routers, IoT, NAS)

### `loopback-network` Permission

**Covers:** Loopback addresses
**Examples:**
- 127.0.0.0/8 (IPv4 loopback)
- ::1/128 (IPv6 loopback)

**Use case:** Accessing localhost services (development servers, local APIs)

### Browser Implementation

Currently, Chrome treats these as a **unified permission** under the name `"local-network-access"`. Future browser versions may separate these for finer-grained control.

---

## 3. How LNA Works

### Permission Flow

```
1. Website attempts fetch("http://192.168.1.1/api")
   ↓
2. Browser detects: public → local request
   ↓
3. BEFORE sending request, check permission state
   ↓
4a. Permission GRANTED → proceed to step 5
4b. Permission DENIED → fail immediately (CORS never evaluated)
4c. Permission PROMPT → show user dialog → goto 4a or 4b
   ↓
5. Send request with standard CORS
   ↓
6. Server responds with CORS headers
   ↓
7. Browser evaluates CORS (normal flow)
   ↓
8. Request succeeds or fails based on CORS
```

### Critical Timing

**LNA blocks BEFORE CORS evaluation.**

This means:
- Adding `Access-Control-Allow-Private-Network: true` header **does not help**
- Server cannot bypass permission prompt
- CORS headers only matter **after** permission is granted

### Mixed Content Relaxation

**Normally:** HTTPS page cannot access HTTP endpoints (mixed content blocked)

**With LNA permission granted:** HTTPS page **can** access HTTP local endpoints

Example:
```
https://myapp.com → http://192.168.1.100:8080/api
```

Without LNA permission: Blocked by mixed content
With LNA permission: Allowed (LNA relaxes mixed content rules)

---

## 4. Frontend: Permission Management

Since LNA is client-side only, frontend code must handle permission states.

### Permission API

```javascript
navigator.permissions.query({ name: "local-network-access" })
  .then(result => {
    console.log(result.state); // "granted" | "prompt" | "denied"
  })
  .catch(error => {
    console.error("Permission query failed:", error);
  });
```

### Three Permission States

#### 1. `granted` - Access Allowed

**Meaning:** User previously allowed access, or enterprise policy auto-grants

**Action:** Proceed with requests normally

**Pattern:**
```javascript
if (result.state === "granted") {
  // Safe to call local API
  await fetch("http://localhost:1135/api/models");
}
```

#### 2. `prompt` - Not Yet Decided

**Meaning:** User hasn't been asked yet

**Action:** Inform user what to expect, then make request (triggers prompt)

**Pattern:**
```javascript
if (result.state === "prompt") {
  showNotification("Allow local network access when prompted");
  // Making request will trigger prompt
  await fetch("http://localhost:1135/api/models");
}
```

#### 3. `denied` - Access Blocked

**Meaning:** User blocked access, or browser policy denies

**Action:** Show fallback UI, guide user to settings

**Pattern:**
```javascript
if (result.state === "denied") {
  showError("Local network access denied. Enable in Chrome Settings → Privacy → Site Settings → Local network access");
  // Do NOT attempt request - will fail
}
```

### Conceptual Handler Pattern

```javascript
async function checkAndRequestLocalAccess() {
  try {
    const permission = await navigator.permissions.query({
      name: "local-network-access"
    });

    switch (permission.state) {
      case "granted":
        return true; // Proceed with requests

      case "prompt":
        // Inform user, then request triggers prompt
        showUserGuidance("Please allow local network access");
        return true; // Let request trigger prompt

      case "denied":
        // Show settings guidance
        showSettingsLink();
        return false; // Don't attempt request
    }
  } catch (error) {
    console.warn("Permission API not supported", error);
    // Try request anyway (older browsers)
    return true;
  }
}
```

### Best Practices

**Do:**
- Check permission **before** critical UX flows
- Provide context **before** prompt appears
- Handle `denied` gracefully with settings guidance
- Include `.catch()` for browsers without Permissions API

**Don't:**
- Assume permission is granted
- Retry immediately after denial
- Show technical error messages to users
- Rely on permission API alone (progressive enhancement)

---

## 5. Frontend: iframe Permission Delegation

### The Problem

iframes **inherit restrictions** from their embedder. By default, iframes **cannot** access local networks even if top-level page has permission.

### Solution: `allow` Attribute

Use Permissions Policy to delegate access:

```html
<iframe
  src="https://embedded-app.com"
  allow="local-network-access">
</iframe>
```

### Nested iframes

**Critical:** Every level must delegate permission.

#### Example: 3-Level Hierarchy

```html
<!-- Top-level page: https://myapp.com -->
<iframe
  id="level1"
  src="https://dashboard.com"
  allow="local-network-access">

  <!-- Level 1: https://dashboard.com -->
  <iframe
    id="level2"
    src="https://widget.com"
    allow="local-network-access">

    <!-- Level 2: https://widget.com -->
    <iframe
      id="level3"
      src="https://api-client.com"
      allow="local-network-access">

      <!-- NOW level 3 can access local network -->
      <script>
        fetch("http://localhost:8080/api");
      </script>
    </iframe>
  </iframe>
</iframe>
```

**If ANY level omits `allow="local-network-access"`, the chain breaks.**

### Syntax Variations

**Allow for all origins (permissive):**
```html
<iframe allow="local-network-access">
```

**Allow for specific origin:**
```html
<iframe allow="local-network-access https://trusted.com">
```

**Allow for self + specific origin:**
```html
<iframe allow="local-network-access 'self' https://trusted.com">
```

### Debugging iframe Issues

**Check if iframe has permission:**
```javascript
// Inside iframe
const hasFeature = document.featurePolicy?.allowsFeature('local-network-access');
console.log("iframe has LNA permission:", hasFeature);
```

**Common error:**
```
Permission was denied for this request to access the unknown address space
```

**Solution:** Add `allow="local-network-access"` to **all** parent iframes in hierarchy.

---

## 6. Backend: Standard CORS (Relaxed)

### What Changed

**Old PNA approach (deprecated):**
- Server must respond with `Access-Control-Allow-Private-Network: true`
- Server controls access via header

**New LNA approach (current):**
- Browser controls access via permission
- Server responds with standard CORS headers only
- No special LNA headers needed

### Required Server Headers

**Standard CORS preflight response:**

```http
OPTIONS /api/endpoint HTTP/1.1

HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://yourapp.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 86400
```

**No special headers for LNA.**

### Axum (Rust) Example

```rust
use tower_http::cors::CorsLayer;
use axum::http::Method;

let cors = CorsLayer::new()
    .allow_origin("https://yourapp.com".parse().unwrap())
    .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
    .allow_headers(Any)
    .allow_credentials(true);

Router::new()
    .route("/api/endpoint", get(handler))
    .layer(cors)
```

### Express (Node.js) Example

```javascript
const cors = require('cors');

app.use(cors({
  origin: 'https://yourapp.com',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
```

### What's Different from PNA

| Aspect | PNA (deprecated) | LNA (current) |
|--------|------------------|---------------|
| **Access-Control-Allow-Private-Network** | Required | Not needed |
| **Server control** | Yes (via header) | No (client-only) |
| **Preflight detection** | Check for `Access-Control-Request-Private-Network` | Not applicable |
| **Implementation** | Custom middleware for PNA | Standard CORS only |

---

## 7. Mixed Content: Detailed Explanation

### The Problem

**Normally:** HTTPS pages cannot make requests to HTTP endpoints (mixed content block)

```
https://myapp.com → http://192.168.1.100/api
❌ Blocked: Mixed Content
```

### LNA Mixed Content Relaxation

**After user grants LNA permission:** Browser relaxes mixed content rules for local endpoints

```
https://myapp.com → http://192.168.1.100/api
✅ Allowed (if LNA permission granted)
```

### How It Works

1. User visits `https://myapp.com`
2. App attempts `fetch("http://192.168.1.100/api")`
3. Browser shows LNA permission prompt
4. User clicks "Allow"
5. Browser **relaxes mixed content blocking** for local IPs
6. Request proceeds to `http://192.168.1.100/api`

### `targetAddressSpace` Parameter

For explicit control, use fetch option:

```javascript
fetch("http://example.com/api", {
  targetAddressSpace: "local"  // or "loopback"
})
```

**Effect:**
- If resolved IP matches declared space → mixed content exception granted
- If resolved IP doesn't match → request fails

**Example:**

```javascript
// example.com resolves to 192.168.1.100 (local space)
fetch("http://example.com/api", {
  targetAddressSpace: "local"  // ✅ Matches, allowed
})

fetch("http://example.com/api", {
  targetAddressSpace: "loopback"  // ❌ Doesn't match, fails
})
```

### Practical Scenarios

#### Scenario 1: Public HTTPS → Localhost HTTP

```javascript
// From: https://myapp.com
fetch("http://localhost:1135/api/models")
```

1. LNA permission prompt
2. If granted → mixed content relaxed
3. Request proceeds

#### Scenario 2: Public HTTPS → Private IP HTTP

```javascript
// From: https://myapp.com
fetch("http://192.168.1.100:8080/status")
```

1. LNA permission prompt
2. If granted → mixed content relaxed
3. Request proceeds

#### Scenario 3: Development (HTTP → HTTP)

```javascript
// From: http://localhost:3000
fetch("http://localhost:1135/api/models")
```

1. Both HTTP (no mixed content issue)
2. Same-origin-ish (localhost)
3. No LNA prompt needed

### IP Literal Exceptions

Private IP literals automatically bypass mixed content (but still subject to LNA):

```javascript
// From HTTPS page
fetch("http://192.168.0.1/api");  // Mixed content exception
fetch("http://10.0.0.5/api");     // Mixed content exception
fetch("http://127.0.0.1/api");    // Mixed content exception
```

### `.local` Domain Exception

`.local` domains (mDNS/Bonjour) get mixed content exception:

```javascript
// From HTTPS page
fetch("http://myserver.local/api");  // Mixed content exception
```

**Requires:** mDNS/Bonjour configuration on network

---

## 8. PNA vs LNA: Migration Guide

### Comparison Table

| Aspect | PNA (Private Network Access) | LNA (Local Network Access) |
|--------|-------------------------------|----------------------------|
| **Status** | Deprecated (paused 2024) | Active (Chrome 142+ Oct 2025) |
| **Mechanism** | CORS preflight with special headers | User permission prompt |
| **Enforcement point** | Server-side | Client-side |
| **Server control** | Yes (opt-in via header) | No (browser-controlled) |
| **Required header** | `Access-Control-Allow-Private-Network: true` | None (standard CORS only) |
| **Preflight check** | `Access-Control-Request-Private-Network: true` | Not applicable |
| **User involvement** | None | Explicit permission prompt |
| **Device identification** | `Private-Network-Access-Name`, `Private-Network-Access-ID` | Not in final spec |
| **Bypass method** | Server returns header | Enterprise policy only |

### What Developers Need to Change

#### If You Implemented PNA

**Remove:**
```javascript
// OLD: PNA middleware
app.use((req, res, next) => {
  if (req.headers['access-control-request-private-network']) {
    res.setHeader('Access-Control-Allow-Private-Network', 'true');
  }
  next();
});
```

**Keep:**
```javascript
// KEEP: Standard CORS
app.use(cors({
  origin: 'https://yourapp.com',
  methods: ['GET', 'POST'],
  credentials: true
}));
```

#### If You Never Implemented PNA

**No server changes needed.** Just ensure standard CORS is configured.

### Frontend Changes

**Add permission checking:**

```javascript
// NEW: Check LNA permission
const permission = await navigator.permissions.query({
  name: "local-network-access"
});

if (permission.state === "denied") {
  // Guide user to settings
}
```

**Add iframe delegation (if using iframes):**

```html
<!-- NEW: Delegate permission -->
<iframe allow="local-network-access" src="...">
```

### Timeline

- **Before Chrome 142** (< Oct 2025): PNA headers optional, no prompts
- **Chrome 142+** (Oct 2025 →): LNA enforced, permission prompts appear
- **Future**: PNA headers ignored entirely

---

## 9. Browser Support

### Chromium Browsers

#### Chrome
- **Version 142** (Oct 28, 2025): Full LNA enforcement
- **Version 138-141**: Testing via `chrome://flags/#local-network-access-check`
- **Pre-138**: No LNA enforcement

**Features:**
- Permission prompts for Fetch, XHR, SSE
- Permissions API support
- iframe delegation support
- Enterprise policy support

#### Microsoft Edge
- **Version 143** (Nov 2025): Full LNA enforcement
- Follows Chromium implementation
- Same features as Chrome

#### Brave
- Follows Chromium implementation (same timeline as Chrome 142)

### Firefox

**Status:** In development

**Version:** Nightly 143+ (as of Jan 2026)
- Permission-based approach (similar to LNA)
- Not yet in stable release

**Expected:** Future stable release will enforce similar restrictions

**Note:** [Firefox Bug #1481298](https://bugzilla.mozilla.org/show_bug.cgi?id=1481298) tracks implementation

### Safari/WebKit

**Status:** No web-level LNA implementation

**OS-level:** iOS 14+ / macOS Big Sur+
- "Local Network Privacy" for **native apps** only
- Apps must request permission to access local network
- **Web browsers exempt** from this requirement

**Web behavior:**
- Does not implement W3C Private Network Access spec
- Does not show permission prompts for web pages
- Enforces standard mixed content rules

**Future:** Discussions ongoing, no timeline announced

### Electron

**Status:** Affected (uses Chromium engine)

**Issue:** [electron/electron#48655](https://github.com/electron/electron/issues/48655)

**Impact:**
- Electron apps using Chromium 142+ inherit LNA behavior
- `webPreferences.allowRunningInsecureContent` does NOT bypass LNA
- Need to handle permissions or use enterprise policies

---

## 10. Enterprise Policies (Condensed)

Chrome Enterprise provides policies to manage LNA in managed environments.

### `LocalNetworkAccessAllowedForUrls`

**Purpose:** Pre-grant permission for specific origins

**Format:** List of URL patterns

**Example:**
```json
{
  "LocalNetworkAccessAllowedForUrls": [
    "http://localhost:*",
    "http://127.0.0.1:*",
    "http://192.168.*.*:*",
    "https://trusted-app.company.com"
  ]
}
```

**Effect:** Users never see permission prompt for these origins

### `LocalNetworkAccessBlockedForUrls`

**Purpose:** Pre-deny permission for specific origins

**Format:** List of URL patterns

**Example:**
```json
{
  "LocalNetworkAccessBlockedForUrls": [
    "https://untrusted-site.com",
    "https://*.ad-network.com"
  ]
}
```

**Effect:** Permission always denied, no prompt shown

### Deployment

**Google Admin Console:**
1. Devices → Chrome → Settings
2. Add policy configuration
3. Apply to organizational units

**Windows Group Policy:**
1. `HKLM\Software\Policies\Google\Chrome\LocalNetworkAccessAllowedForUrls`
2. Add URL patterns as string list

**macOS Configuration Profile:**
```xml
<key>LocalNetworkAccessAllowedForUrls</key>
<array>
  <string>http://localhost:*</string>
  <string>http://192.168.*.*:*</string>
</array>
```

### Best Practice

**For enterprise BodhiApp deployments:**

```json
{
  "LocalNetworkAccessAllowedForUrls": [
    "http://localhost:1135",
    "http://127.0.0.1:1135",
    "http://[::1]:1135",
    "http://10.*.*.*:1135",
    "http://172.16.*.*:1135",
    "http://192.168.*.*:1135"
  ]
}
```

This covers all common private network ranges on standard BodhiApp port.

---

## 11. Testing & Debugging

### Manual Testing

#### Enable LNA Early (Chrome 138-141)

```
chrome://flags/#local-network-access-check
```

Set to: **"Enabled (Blocking)"**

#### Check Current Permission State

**Browser DevTools:**
```javascript
navigator.permissions.query({ name: "local-network-access" })
  .then(p => console.log("LNA state:", p.state))
```

**Output:** `granted`, `prompt`, or `denied`

#### Reset Permission

**Chrome:**
1. Click lock icon in address bar
2. Find "Local network access"
3. Change to "Ask" or "Block"

**Or:**
```
chrome://settings/content/siteDetails?site=http://localhost:1135
```

### Common Error Messages

#### Error: Permission Denied

```
Access to fetch at 'http://192.168.1.100/api' from origin 'https://myapp.com' has been blocked by CORS policy: Permission was denied for this request to access the unknown address space.
```

**Cause:** User denied LNA permission, or no permission granted yet

**Solution:**
1. Check permission state
2. Guide user to grant permission
3. Or configure enterprise policy

#### Error: iframe Permission Denied

```
Permission was denied for this request to access the unknown address space
```

**When:** Making request from within iframe

**Cause:** Parent iframe missing `allow="local-network-access"`

**Solution:** Add attribute to **all** parent iframes in hierarchy

### DevTools Network Tab

**Blocked request:**
- Status: `(failed)` or `net::ERR_BLOCKED_BY_CLIENT`
- No response headers shown
- Request never leaves browser

**Successful request:**
- Status: `200 OK` (or appropriate)
- Response headers visible
- Request reached server

### Permission Settings Location

**Chrome:**
```
chrome://settings/content/localNetworkAccess
```

Shows:
- Sites allowed to access local network
- Sites blocked from accessing local network
- Default behavior

### Debugging Checklist

**When local network requests fail:**

1. ✅ Check permission state via API
2. ✅ Verify no permission denial in DevTools console
3. ✅ Confirm CORS headers on server (use `curl` or Postman)
4. ✅ Test from same address space (no LNA check)
5. ✅ Check iframe hierarchy for missing `allow` attributes
6. ✅ Try enterprise policy if applicable
7. ✅ Test in different browser (Firefox, Safari)

---

## 12. BodhiApp-Specific Considerations

### Deployment Scenarios

#### Tauri Desktop (External Browser)

**Flow:**
1. User launches BodhiApp
2. App starts Axum server on `localhost:1135`
3. App opens browser to `http://localhost:1135`
4. Browser classifies: loopback → loopback (no prompt)
   **OR** public → loopback (prompt if using HTTPS wrapper)

**Impact:** Minimal if using HTTP. If wrapping in HTTPS, expect prompt.

#### Docker/Self-Hosted

**Flow:**
1. Container runs on `192.168.1.100:1135`
2. User accesses from browser: `http://192.168.1.100:1135`
3. Browser classifies: public → local
4. **LNA permission prompt appears**

**Impact:** All users see prompt on first access

**Mitigation:**
- Document permission prompt in user guide
- Consider enterprise policy for managed deployments

#### Development Mode

**Flow:**
1. Next.js dev server: `localhost:3000`
2. API proxy to: `localhost:1135`
3. Browser classifies: loopback → loopback (same space)

**Impact:** None (same address space, no prompt)

### Standard CORS Configuration

**Current BodhiApp config** (`crates/routes_all/src/routes.rs:271-277`):

```rust
.layer(
  CorsLayer::new()
    .allow_origin(Any)
    .allow_methods(Any)
    .allow_headers(Any)
    .allow_credentials(false),
)
```

**No changes needed for LNA.** This continues to work as standard CORS.

### Recommendations

**For BodhiApp developers:**

1. **Document LNA behavior** in user guide
2. **Test permission flow** in Chrome 142+
3. **Consider UI messaging** before first API call
4. **Provide enterprise policy template** for business users

**Not needed:**
- Custom middleware for LNA headers
- Device identification headers
- Server-side permission checking

---

## 13. References

### Official Specifications

- [Local Network Access - WICG Draft (Jan 2026)](https://wicg.github.io/local-network-access/)
- [Chrome Platform Status: Local Network Access](https://chromestatus.com/feature/5152728072060928)

### Chrome Documentation

- [New permission prompt for Local Network Access | Chrome Blog](https://developer.chrome.com/blog/local-network-access)
- [Chrome 142 Release Notes](https://developer.chrome.com/release-notes/142)
- [Chrome Enterprise Policy List](https://chromeenterprise.google/policies/)

### Implementation Guides

- [Using navigator.permissions.query for Local Network Access](https://paulserban.eu/blog/post/using-navigatorpermissionsquery-for-local-network-access-in-chrome/)
- [Demystifying Nested iframes and the allow='local-network-access' Attribute](https://paulserban.eu/blog/post/demystifying-nested-iframes-and-the-allowlocal-network-access-attribute-in-chrome/)
- [Why Chrome Restricts Local Network Access (& How to Adapt)](https://www.paulserban.eu/blog/post/why-chrome-restricts-local-network-access-how-to-adapt/)
- [How to Debug Blocked Requests: Local-Network-Access in Chrome](https://www.paulserban.eu/blog/post/how-to-debug-blocked-requests-local-network-access-in-chrome/)

### Vendor Guides

- [Dynamsoft: Chromium 142 Local Network Access Issue](https://www.dynamsoft.com/web-twain/docs/faq/chromium-142-local-network-access-issue.html)
- [Esri: Chrome 142 and Edge 143 Permission Prompt](https://support.esri.com/en-us/knowledge-base/what-to-know-about-new-permission-prompt-in-google-chro-000039171)

### News & Analysis

- [Google Chrome 142 restricts local network access | gHacks](https://www.ghacks.net/2025/10/29/google-chrome-142-restricts-local-network-access/)

### Browser Issues

- [Firefox Bug #1481298: Private Network Access](https://bugzilla.mozilla.org/show_bug.cgi?id=1481298)
- [Electron Issue #48655: Local Network Access plans](https://github.com/electron/electron/issues/48655)
- [Office.js Issue #6281: Chrome 142+ local-network-access](https://github.com/officedev/office-js/issues/6281)
- [StackBlitz WebContainer Issue #2007: LNA compliance](https://github.com/stackblitz/webcontainer-core/issues/2007)

---

## Conclusion

Local Network Access represents a fundamental shift from server-controlled security (PNA) to user-controlled security (LNA). For BodhiApp:

**Key Takeaways:**

1. **Permission-first**: Browser prompts user, server has no control
2. **Frontend-heavy**: Handle permission states, iframe delegation, mixed content
3. **Backend-minimal**: Standard CORS only, no special headers
4. **Already compatible**: Current CORS config works with LNA

**Action Items:**

- ✅ Document permission prompt for users
- ✅ Test in Chrome 142+ environments
- ✅ Consider enterprise policy template
- ⏸️ No server code changes needed

LNA improves security for users while maintaining developer flexibility through clear permission boundaries.

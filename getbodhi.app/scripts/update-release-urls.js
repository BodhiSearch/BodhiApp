#!/usr/bin/env node

/**
 * Update .env.release_urls with latest GitHub release download URLs
 *
 * Usage:
 *   npm run update_releases         # Update .env.release_urls
 *   npm run update_releases:check   # Dry-run (check only, no updates)
 */

import { Octokit } from '@octokit/rest';
import fs from 'fs';

const octokit = new Octokit();
const OWNER = 'BodhiSearch';
const REPO = 'BodhiApp';

/**
 * Download release.json artifact from a GitHub release
 * This artifact is generated by the publish-docker.yml workflow and contains
 * actual build execution results (only successfully published variants)
 * @param {Object} release - The GitHub release object
 * @returns {Object|null} Parsed release.json or null if not found
 */
async function downloadDockerReleaseJson(release) {
  const releaseJsonAsset = release.assets.find((a) => a.name === 'release.json');

  if (!releaseJsonAsset) {
    console.warn(`  ⚠ No release.json artifact found for ${release.tag_name}`);
    return null;
  }

  try {
    // Download the artifact using GitHub API
    const { data } = await octokit.request('GET /repos/{owner}/{repo}/releases/assets/{asset_id}', {
      owner: OWNER,
      repo: REPO,
      asset_id: releaseJsonAsset.id,
      headers: {
        Accept: 'application/octet-stream',
      },
    });

    // Handle different data formats (string, Buffer, ArrayBuffer)
    let jsonString;
    if (typeof data === 'string') {
      jsonString = data;
    } else if (Buffer.isBuffer(data)) {
      jsonString = data.toString('utf-8');
    } else if (data instanceof ArrayBuffer) {
      jsonString = Buffer.from(data).toString('utf-8');
    } else if (typeof data === 'object') {
      // Already parsed JSON object
      return data;
    } else {
      throw new Error(`Unexpected data type: ${typeof data}`);
    }

    return JSON.parse(jsonString);
  } catch (error) {
    console.error(`  ✗ Failed to download release.json for ${release.tag_name}:`, error.message);
    return null;
  }
}

/**
 * Generate docker run command for a variant
 * @param {Object} variant - Variant data from workflow
 * @param {string} imageTag - Full image tag to use
 * @returns {string} Multi-line docker run command
 */
function generateRunCommand(variant, imageTag) {
  const baseFlags = [
    'docker run --name bodhiapp',
    '-p 1135:1135',
    '-v $(pwd)/bodhi_home:/data/bodhi_home',
    '-v $(pwd)/hf_home:/data/hf_home',
  ];

  // Add GPU-specific flags
  const gpuFlags = {
    cuda: ['--gpus all'],
    rocm: ['--device=/dev/kfd', '--device=/dev/dri', '--group-add video'],
  };

  const flags = [...baseFlags, ...(gpuFlags[variant.variant] || [])];

  // Join with line continuations
  return flags.join(' \\\n  ') + ' \\\n  ' + imageTag;
}

/**
 * Transform workflow release.json format to frontend format
 * Workflow format has variants as array with status field
 * Frontend format needs variants as object keyed by variant name
 * @param {Object} workflowJson - release.json from workflow
 * @returns {Object} Transformed data for frontend
 */
function transformDockerReleaseJson(workflowJson) {
  // Filter to only successfully built variants
  const successfulVariants = workflowJson.variants.filter((v) => v.status === 'success');

  // GPU type mapping from variant names
  const gpuTypeMap = {
    cuda: 'NVIDIA',
    rocm: 'AMD',
    vulkan: 'Cross-vendor',
    intel: 'Intel',
  };

  // Transform array to object keyed by variant name
  const variants = {};
  successfulVariants.forEach((v) => {
    const latestTag = v.tags[1] || v.tags[0]; // Use latest tag if available, fallback to versioned

    const variantData = {
      image_tag: v.tags[0].split(':')[1], // Extract tag after registry:
      latest_tag: v.tags[1] ? v.tags[1].split(':')[1] : `latest-${v.variant}`,
      platforms: v.platforms,
      pull_command: `docker pull ${latestTag}`, // Use latest tag for pull command
      run_command: generateRunCommand(v, latestTag), // Generate run command
      description: v.description,
    };

    // Add gpu_type if it's a GPU variant
    if (gpuTypeMap[v.variant]) {
      variantData.gpu_type = gpuTypeMap[v.variant];
    }

    variants[v.variant] = variantData;
  });

  return {
    version: workflowJson.version,
    tag: workflowJson.tag,
    released_at: workflowJson.timestamp,
    registry: `${workflowJson.registry}/${workflowJson.image_name}`,
    variants: variants,
  };
}

// Tag patterns to search for (extensible for future artifacts)
const TAG_PATTERNS = [
  {
    regex: /^app\/v/,
    type: 'desktop',
    platforms: [
      {
        id: 'macos',
        assetPattern: /Bodhi[\s.]App.*\.dmg$/,
        envVar: 'NEXT_PUBLIC_DOWNLOAD_URL_MACOS',
        platformKey: 'macos',
        archKey: 'silicon',
      },
      {
        id: 'windows',
        assetPattern: /Bodhi[\s.]App.*\.msi$/,
        envVar: 'NEXT_PUBLIC_DOWNLOAD_URL_WINDOWS',
        platformKey: 'windows',
        archKey: 'x64',
      },
      {
        id: 'linux',
        assetPattern: /Bodhi[\s.]App.*\.rpm$/,
        envVar: 'NEXT_PUBLIC_DOWNLOAD_URL_LINUX',
        platformKey: 'linux',
        archKey: 'x64',
      },
    ],
  },
  {
    regex: /^docker\/v/,
    type: 'docker',
    registry: 'ghcr.io/bodhisearch/bodhiapp',
  },
  // { regex: /^ts-client\/v/, envVar: 'NEXT_PUBLIC_TS_CLIENT_VERSION' },
  // { regex: /^napi\/v/, envVar: 'NEXT_PUBLIC_NAPI_VERSION' },
];

async function fetchLatestReleases() {
  const found = {};
  let desktopMetadata = null;
  let dockerMetadata = null;
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

  let page = 1;
  let shouldContinue = true;

  console.log('Fetching releases from GitHub...');

  // Count total items to find (desktop platforms + docker release)
  const desktopPlatforms = TAG_PATTERNS.find((p) => p.type === 'desktop')?.platforms?.length || 0;
  const dockerPatterns = TAG_PATTERNS.filter((p) => p.type === 'docker').length;
  const totalItems = desktopPlatforms + dockerPatterns;

  while (shouldContinue) {
    const { data: releases } = await octokit.repos.listReleases({
      owner: OWNER,
      repo: REPO,
      per_page: 100,
      page,
    });

    if (releases.length === 0) {
      console.log('No more releases to fetch');
      break;
    }

    console.log(`Processing page ${page} (${releases.length} releases)...`);

    for (const release of releases) {
      const releaseDate = new Date(release.created_at);

      // Stop if release is older than 6 months
      if (releaseDate < sixMonthsAgo) {
        console.log(`Reached 6-month limit at ${release.tag_name}`);
        shouldContinue = false;
        break;
      }

      // Check each tag pattern
      for (const pattern of TAG_PATTERNS) {
        if (pattern.regex.test(release.tag_name)) {
          // Handle Docker patterns
          if (pattern.type === 'docker') {
            if (!dockerMetadata) {
              console.log(`  Checking Docker release: ${release.tag_name}`);

              // Download release.json artifact from the release
              const workflowJson = await downloadDockerReleaseJson(release);

              if (workflowJson) {
                // Transform workflow format to frontend format
                dockerMetadata = transformDockerReleaseJson(workflowJson);

                found.docker = dockerMetadata;
                console.log(`✓ Found Docker release: ${release.tag_name}`);
                console.log(`  Variants: ${Object.keys(dockerMetadata.variants).join(', ')}`);
              } else {
                console.log(`  ⚠ Skipping ${release.tag_name} - no release.json artifact`);
              }
            }
          }
          // Handle desktop platform patterns
          else if (pattern.platforms) {
            for (const platform of pattern.platforms) {
              if (!found[platform.envVar]) {
                const asset = release.assets.find((a) => platform.assetPattern.test(a.name));
                if (asset) {
                  found[platform.envVar] = {
                    url: asset.browser_download_url,
                    filename: asset.name,
                    platformKey: platform.platformKey,
                    archKey: platform.archKey,
                  };
                  console.log(`✓ Found ${platform.id}: ${release.tag_name} -> ${asset.name}`);
                }
              }
            }

            // Store desktop release metadata from first matching release
            if (!desktopMetadata) {
              const versionMatch = release.tag_name.match(/v([\d.]+)$/);
              desktopMetadata = {
                version: versionMatch ? versionMatch[1] : release.tag_name,
                tag: release.tag_name,
                released_at: release.published_at || release.created_at,
              };
            }
          } else if (pattern.assetPattern) {
            // Legacy single-asset pattern
            if (!found[pattern.envVar]) {
              const asset = release.assets.find((a) => pattern.assetPattern.test(a.name));
              if (asset) {
                found[pattern.envVar] = {
                  url: asset.browser_download_url,
                  filename: asset.name,
                };
                console.log(`✓ Found ${pattern.envVar}: ${release.tag_name} -> ${asset.name}`);
              }
            }
          }
        }
      }

      // Check if we found everything
      const desktopFound =
        desktopPlatforms === 0 ||
        Object.keys(found).filter((k) => k.startsWith('NEXT_PUBLIC_DOWNLOAD')).length === desktopPlatforms;
      const dockerFound = dockerPatterns === 0 || dockerMetadata !== null;

      if (desktopFound && dockerFound) {
        shouldContinue = false;
        break;
      }
    }

    // If we fetched less than 100, it's the last page
    if (releases.length < 100) {
      break;
    }

    page++;
  }

  return { found, desktopMetadata, dockerMetadata };
}

function generateEnvFile(data, desktopMetadata, dockerMetadata, dryRun) {
  const lines = [
    '# Auto-generated download URLs for website',
    `# Last updated: ${new Date().toISOString().split('T')[0]}`,
    '#',
    '# This file is checked into git and loaded by Next.js build process.',
    '# To update: run `npm run update_releases` or `make website.update_releases`',
    '',
  ];

  // Add desktop app version and tag if available
  if (desktopMetadata) {
    lines.push('# Desktop app version and tag');
    lines.push(`NEXT_PUBLIC_APP_VERSION=${desktopMetadata.version}`);
    lines.push(`NEXT_PUBLIC_APP_TAG=${desktopMetadata.tag}`);
    lines.push('');
  }

  // Add Docker version and tag if available
  if (dockerMetadata) {
    lines.push('# Docker version and tag');
    lines.push(`NEXT_PUBLIC_DOCKER_VERSION=${dockerMetadata.version}`);
    lines.push(`NEXT_PUBLIC_DOCKER_TAG=${dockerMetadata.tag}`);
    lines.push(`NEXT_PUBLIC_DOCKER_REGISTRY=${dockerMetadata.registry}`);
    lines.push('');
  }

  // Add platform download URLs
  if (desktopMetadata) {
    lines.push('# Platform download URLs');
  }

  for (const [key, value] of Object.entries(data)) {
    if (key === 'docker') continue; // Skip docker metadata (already handled above)
    const url = typeof value === 'string' ? value : value.url;
    lines.push(`${key}=${url}`);
  }

  const content = lines.join('\n') + '\n';

  if (dryRun) {
    console.log('\n=== Dry-run mode - would write to .env.release_urls: ===\n');
    console.log(content);
    return;
  }

  fs.writeFileSync('.env.release_urls', content);
  console.log('\n✓ Updated .env.release_urls');
  console.log('  File:', '.env.release_urls');
  const varCount =
    Object.keys(data).length - (data.docker ? 1 : 0) + (desktopMetadata ? 2 : 0) + (dockerMetadata ? 3 : 0);
  console.log('  Variables updated:', varCount);
}

function generateReleasesJson(data, desktopMetadata, dockerMetadata, dryRun) {
  if (!desktopMetadata && !dockerMetadata) {
    console.log('\n⚠ Skipping releases.json generation - no release metadata available');
    return;
  }

  const releasesData = {};

  // Build desktop platform structure
  if (desktopMetadata) {
    const platforms = {};

    for (const value of Object.values(data)) {
      if (value.platformKey && value.archKey) {
        if (!platforms[value.platformKey]) {
          platforms[value.platformKey] = {};
        }
        platforms[value.platformKey][value.archKey] = {
          download_url: value.url,
          filename: value.filename,
        };
      }
    }

    releasesData.desktop = {
      version: desktopMetadata.version,
      tag: desktopMetadata.tag,
      released_at: desktopMetadata.released_at,
      platforms,
    };
  }

  // Add Docker data
  if (dockerMetadata) {
    releasesData.docker = {
      version: dockerMetadata.version,
      tag: dockerMetadata.tag,
      released_at: dockerMetadata.released_at,
      registry: dockerMetadata.registry,
      variants: dockerMetadata.variants,
    };
  }

  const content = JSON.stringify(releasesData, null, 2) + '\n';

  if (dryRun) {
    console.log('\n=== Dry-run mode - would write to public/releases.json: ===\n');
    console.log(content);
    return;
  }

  // Ensure public directory exists
  if (!fs.existsSync('public')) {
    fs.mkdirSync('public', { recursive: true });
  }

  fs.writeFileSync('public/releases.json', content);
  console.log('\n✓ Updated public/releases.json');
  console.log('  File:', 'public/releases.json');
  if (desktopMetadata) {
    const platforms = Object.keys(releasesData.desktop.platforms);
    console.log('  Desktop platforms:', platforms.length > 0 ? platforms.join(', ') : 'none');
  }
  if (dockerMetadata) {
    const variants = Object.keys(releasesData.docker.variants);
    console.log('  Docker variants:', variants.length > 0 ? variants.join(', ') : 'none');
  }
}

async function main() {
  const dryRun = process.argv.includes('--check');

  console.log(dryRun ? '=== Checking latest releases (dry-run) ===' : '=== Updating release URLs ===');
  console.log('');

  try {
    const { found, desktopMetadata, dockerMetadata } = await fetchLatestReleases();

    if (Object.keys(found).length === 0) {
      console.error('\n✗ No matching releases found!');
      console.error(
        '  Searched for patterns:',
        TAG_PATTERNS.map((p) => p.regex.source)
      );
      process.exit(1);
    }

    generateEnvFile(found, desktopMetadata, dockerMetadata, dryRun);
    generateReleasesJson(found, desktopMetadata, dockerMetadata, dryRun);

    if (!dryRun) {
      console.log('\nNext steps:');
      console.log('  1. Review changes: git diff .env.release_urls public/releases.json');
      console.log('  2. Test build: npm run build');
      console.log('  3. Commit changes: git add .env.release_urls public/releases.json && git commit');
    }
  } catch (error) {
    console.error('\n✗ Error:', error.message);
    if (error.response) {
      console.error('  GitHub API response:', error.response.status, error.response.statusText);
    }
    process.exit(1);
  }
}

main();

435 results - 57 files

crates/auth_middleware/src/auth_middleware.rs:
   405        .await?;
   406:     assert_eq!(StatusCode::IM_A_TEAPOT, response.status());
   407      let response_json = response.json::<TestResponse>().await?;
   408:     assert_eq!(
   409:       TestResponse {
   410:         x_resource_token,
   411:         authorization_header,
   412:         path: "/with_optional_auth".to_string(),
   413:       },
   414:       response_json
   415:     );
   416      Ok(())

   441      let response = router.clone().oneshot(req).await?;
   442:     assert_eq!(StatusCode::IM_A_TEAPOT, response.status());
   443      let response_json = response.json::<TestResponse>().await?;
   444:     assert_eq!(
   445:       TestResponse {
   446:         x_resource_token: None,
   447:         authorization_header: None,
   448:         path: path.to_string(),
   449:       },
   450:       response_json
   451:     );
   452      Ok(())

   476      let response = router.clone().oneshot(req).await?;
   477:     assert_eq!(StatusCode::SEE_OTHER, response.status());
   478:     assert_eq!(
   479:       "https://bodhi.app/ui/setup",
   480:       response.headers().get("Location").unwrap()
   481:     );
   482  

   540      let response = router.clone().oneshot(req).await?;
   541:     assert_eq!(expected_status, response.status());
   542      let api_error = response.json_obj::<Value>().await?;
   543:     assert_eq!(api_error, expected_error);
   544  

   577      let value: Value = response.json_obj().await?;
   578:     assert_eq!(StatusCode::UNAUTHORIZED, status);
   579:     assert_eq!(
   580:       value,
   581:       json! {{
   582:         "error": {
   583:           "message": "the algorithm in the token does not match the expected algorithm, expected: \u{2068}HS256\u{2069}, found: \u{2068}RS256\u{2069}",
   584:           "type": "authentication_error",
   585:           "code": "auth_error-alg_mismatch"
   586:         }
   587:       }}
   588:     );
   589  

   622      let value: Value = response.json_obj().await?;
   623:     assert_eq!(StatusCode::UNAUTHORIZED, status);
   624:     assert_eq!(
   625:       value,
   626:       json! {{
   627:         "error": {
   628:           "message": "the secure key id in the token does not match the expected key id, expected: \u{2068}other-kid\u{2069}, found: \u{2068}test-kid\u{2069}",
   629:           "type": "authentication_error",
   630:           "code": "auth_error-kid_mismatch"
   631:         }
   632:       }}
   633:     );
   634      assert_optional_auth_passthrough(&router).await?;

   659      let response = router.clone().oneshot(req).await?;
   660:     assert_eq!(StatusCode::INTERNAL_SERVER_ERROR, response.status());
   661      let actual: Value = response.json_obj().await?;
   662:     assert_eq!(
   663:       actual,
   664:       json! {{
   665:         "error": {
   666:           "message": "app registration info is missing, not found in secure storage",
   667:           "type": "authentication_error",
   668:           "code": "auth_error-app_reg_info_missing"
   669:         }
   670:       }}
   671:     );
   672      assert_optional_auth_passthrough(&router).await?;

   708      let value: Value = response.json_obj().await?;
   709:     assert_eq!(StatusCode::UNAUTHORIZED, status);
   710:     assert_eq!(
   711:       value,
   712:       json! {{
   713:         "error": {
   714:           "message": "authentication token issuer is invalid",
   715:           "type": "authentication_error",
   716:           "code": "json_web_token_error-InvalidIssuer"
   717:         }
   718:       }}
   719:     );
   720      assert_optional_auth_passthrough(&router).await?;

   768      let status = response.status();
   769:     assert_eq!(StatusCode::IM_A_TEAPOT, status);
   770  
   771      let response_json = response.json::<TestResponse>().await?;
   772:     assert_eq!(
   773:       TestResponse {
   774:         path: path.to_string(),
   775:         authorization_header: Some(format!("Bearer {token}")),
   776:         x_resource_token: Some(cached_token.to_string()),
   777:       },
   778:       response_json
   779:     );
   780      Ok(())

   827      let status = response.status();
   828:     assert_eq!(StatusCode::IM_A_TEAPOT, status);
   829      let response_json = response.json::<TestResponse>().await?;
   830:     assert_eq!(
   831:       TestResponse {
   832:         path: path.to_string(),
   833:         authorization_header: Some(format!("Bearer {token}")),
   834:         x_resource_token: Some("token-from-exchange".to_string()),
   835:       },
   836:       response_json
   837:     );
   838      Ok(())

   877      let response = router.oneshot(req).await?;
   878:     assert_eq!(StatusCode::IM_A_TEAPOT, response.status());
   879      let body = response.json::<TestResponse>().await?;
   880:     assert_eq!(
   881:       TestResponse {
   882:         path: path.to_string(),
   883:         authorization_header: None,
   884:         x_resource_token: Some(token),
   885:       },
   886:       body
   887:     );
   888      Ok(())

   956      let response = router.clone().oneshot(req).await?;
   957:     assert_eq!(StatusCode::IM_A_TEAPOT, response.status());
   958      let body = response.json::<TestResponse>().await?;
   959:     assert_eq!(
   960:       TestResponse {
   961:         path: path.to_string(),
   962:         authorization_header: None,
   963:         x_resource_token: Some("new_access_token".to_string()),
   964:       },
   965:       body
   966:     );
   967  

   969      let updated_record = session_service.session_store.load(&id).await?.unwrap();
   970:     assert_eq!(
   971:       "new_access_token",
   972:       updated_record
   973:         .data
   974:         .get("access_token")
   975:         .unwrap()
   976:         .as_str()
   977:         .unwrap()
   978:     );
   979:     assert_eq!(
   980:       "new_refresh_token",
   981:       updated_record
   982:         .data
   983:         .get("refresh_token")
   984:         .unwrap()
   985:         .as_str()
   986:         .unwrap()
   987:     );
   988  

  1053      let response = router.clone().oneshot(req).await?;
  1054:     assert_eq!(StatusCode::UNAUTHORIZED, response.status());
  1055      let actual: Value = response.json().await?;
  1056:     assert_eq!(
  1057:       actual,
  1058:       json! {{
  1059:         "error": {
  1060:           "message": "error connecting to internal service: \u{2068}Failed to refresh token\u{2069}",
  1061:           "type": "authentication_error",
  1062:           "code": "reqwest_error"
  1063:         }
  1064:       }}
  1065:     );
  1066      // Verify that the session was not updated
  1067      let updated_record = session_service.session_store.load(&id).await?.unwrap();
  1068:     assert_eq!(
  1069:       expired_token,
  1070:       updated_record
  1071:         .data
  1072:         .get("access_token")
  1073:         .unwrap()
  1074:         .as_str()
  1075:         .unwrap()
  1076:     );
  1077:     assert_eq!(
  1078:       "refresh_token",
  1079:       updated_record
  1080:         .data
  1081:         .get("refresh_token")
  1082:         .unwrap()
  1083:         .as_str()
  1084:         .unwrap()
  1085:     );
  1086  

crates/auth_middleware/src/utils.rs:
  38      let secret_service = SecretServiceStub::new().with_app_status(&expected);
  39:     assert_eq!(
  40:       expected,
  41:       app_status_or_default(&(Arc::new(secret_service) as Arc<dyn SecretService>))
  42:     );
  43      Ok(())

  49        &(Arc::new(SecretServiceStub::new()) as Arc<dyn SecretService>);
  50:     assert_eq!(AppStatus::default(), app_status_or_default(secret_service));
  51:     assert_eq!(AppStatus::Setup, app_status_or_default(secret_service));
  52      Ok(())

crates/bodhi/src-tauri/src/convert.rs:
  197      let result = build_manage_alias_command(input)?;
  198:     assert_eq!(expected, result);
  199      Ok(())

  251      let command = build_create_command(input)?;
  252:     assert_eq!(expected, command);
  253      Ok(())

  334      let result = build_serve_command(host, port)?;
  335:     assert_eq!(expected, result);
  336      Ok(())

  362      let result = build_list_command(remote, models)?;
  363:     assert_eq!(expected, result);
  364      Ok(())

  390      let pull_command: PullCommand = build_pull_command(input.0, input.1, input.2, input.3)?;
  391:     assert_eq!(expected, pull_command);
  392      Ok(())

crates/commands/src/cmd_cli.rs:
  179      let expected = Command::App { ui: false };
  180:     assert_eq!(expected, cli.command);
  181      Ok(())

  188      assert!(cli.is_err());
  189:     assert_eq!(
  190:       r#"error: unexpected argument '--extra' found
  191: 
  192: Usage: bodhi app [OPTIONS]
  193: 
  194: For more information, try '--help'.
  195: "#,
  196:       cli.unwrap_err().to_string()
  197:     );
  198      Ok(())

  215      };
  216:     assert_eq!(expected, cli.command);
  217      Ok(())

  233      assert!(cli.is_err());
  234:     assert_eq!(err_msg, cli.unwrap_err().to_string());
  235      Ok(())

  248      let expected = Command::List { remote, models };
  249:     assert_eq!(expected, cli.command);
  250      Ok(())

  262      assert!(cli.is_err());
  263:     assert_eq!(err_msg, cli.unwrap_err().to_string());
  264      Ok(())

  271      let expected = Command::Run { alias };
  272:     assert_eq!(expected, cli.command);
  273      Ok(())

  314      };
  315:     assert_eq!(expected, actual);
  316      Ok(())

  342      assert!(cli.is_err());
  343:     assert_eq!(err_msg, cli.unwrap_err().to_string());
  344      Ok(())

  459      };
  460:     assert_eq!(expected, actual);
  461      Ok(())

  516      assert!(actual.is_err());
  517:     assert_eq!(message, actual.unwrap_err().to_string());
  518      Ok(())

  539    fn test_cli_to_string(#[case] cmd: Command, #[case] expected: String) -> anyhow::Result<()> {
  540:     assert_eq!(expected, cmd.to_string());
  541      Ok(())

crates/commands/src/cmd_create.rs:
  189      };
  190:     assert_eq!(expected, updated_alias);
  191      Ok(())

  228        .unwrap();
  229:     assert_eq!(
  230:       Alias {
  231:         alias: "testalias:instruct".to_string(),
  232:         family: Some("testalias".to_string()),
  233:         repo: Repo::testalias(),
  234:         filename: Repo::testalias_filename(),
  235:         snapshot: SNAPSHOT.to_string(),
  236:         features: vec!["chat".to_string()],
  237:         chat_template: ChatTemplateType::Id(objs::ChatTemplateId::Llama3),
  238:         request_params: OAIRequestParams::default(),
  239:         context_params: GptContextParams::default()
  240:       },
  241:       created
  242:     );
  243      Ok(())

  282        .unwrap();
  283:     assert_eq!(
  284:       Alias {
  285:         alias: "testalias:instruct".to_string(),
  286:         family: Some("testalias".to_string()),
  287:         repo: Repo::try_from("MyFactory/testalias-gguf").unwrap(),
  288:         filename: "testalias.Q8_0.gguf".to_string(),
  289:         snapshot: SNAPSHOT.to_string(),
  290:         features: vec!["chat".to_string()],
  291:         chat_template: ChatTemplateType::Repo(Repo::try_from("MyFactory/testalias")?),
  292:         request_params: OAIRequestParams::default(),
  293:         context_params: GptContextParams::default()
  294:       },
  295:       created
  296:     );
  297      Ok(())

crates/commands/src/cmd_pull.rs:
  159        .ok_or(anyhow::anyhow!("alias not found"))?;
  160:     assert_eq!(
  161:       Alias {
  162:         alias: "testalias:instruct".to_string(),
  163:         family: Some("testalias".to_string()),
  164:         repo: Repo::try_from("MyFactory/testalias-gguf")?,
  165:         filename: "testalias.Q8_0.gguf".to_string(),
  166:         snapshot: SNAPSHOT.to_string(),
  167:         features: vec!["chat".to_string()],
  168:         chat_template: ChatTemplateType::Id(objs::ChatTemplateId::Llama3),
  169:         request_params: OAIRequestParams::default(),
  170:         context_params: GptContextParams::default()
  171:       },
  172:       created_alias
  173:     );
  174      Ok(())

  220      let content = fs::read_to_string(alias)?;
  221:     assert_eq!(
  222:       r#"alias: testalias:instruct
  223: family: testalias
  224: repo: MyFactory/testalias-gguf
  225: filename: testalias.Q8_0.gguf
  226: snapshot: 5007652f7a641fe7170e0bad4f63839419bd9213
  227: features:
  228: - chat
  229: chat_template: llama3
  230: "#,
  231:       content
  232:     );
  233      Ok(())

crates/commands/src/objs_ext.rs:
   66      let row = alias.into_row();
   67:     assert_eq!(
   68:       Row::from(vec![
   69:         Cell::new("testalias:instruct"),
   70:         Cell::new("MyFactory/testalias-gguf"),
   71:         Cell::new("testalias.Q8_0.gguf"),
   72:         Cell::new("5007652f"),
   73:         Cell::new("llama3"),
   74:       ]),
   75:       row
   76:     );
   77      Ok(())

   95      ]);
   96:     assert_eq!(expected, row);
   97      Ok(())

  111      ]);
  112:     assert_eq!(expected, row);
  113      Ok(())

crates/errmeta_derive/src/lib.rs:
   588    fn test_is_transparent(#[case] variant: Variant, #[case] expected: bool) {
   589:     assert_eq!(is_transparent(&variant), expected);
   590    }

   634      let error_meta = parse_enum_meta_attrs(&[attr]);
   635:     assert_eq!(error_meta, expected);
   636    }

   683      let error_meta = parse_struct_meta_attrs(&[attr]);
   684:     assert_eq!(error_meta, expected);
   685    }

   725      let generated = generate_attribute_method(&name, &variants, method);
   726:     assert_eq!(generated.to_string(), expected.to_string());
   727    }

   740      let args_method = generate_args_method(name, &input.data);
   741:     assert_eq!(
   742:       args_method.to_string(),
   743:       quote! {
   744:         match self {
   745:           TestEnum::Variant1 { field1, field2 } => {
   746:             let mut map = ::std::collections::HashMap::new();
   747              map.insert(stringify!(field1).to_string(), format!("{}", field1));

   826      let method_impls = enum_method_impls(quote! { pub });
   827:     assert_eq!(
   828:       output.to_string(),
   829:       quote! {
   830:         impl TestEnum {
   831:           #method_impls
   832:         }
   833:       }
   834:       .to_string()
   835:     );
   836    }

   858  
   859:     assert_eq!(output.to_string(), expected.to_string());
   860    }

   909  
   910:     assert_eq!(output.to_string(), expected.to_string());
   911    }

   929      };
   930:     assert_eq!(output.to_string(), expected.to_string());
   931    }

   972  
   973:     assert_eq!(output.to_string(), expected.to_string());
   974    }

   993  
   994:     assert_eq!(args_method.to_string(), expected.to_string());
   995    }

  1011  
  1012:     assert_eq!(args_method.to_string(), expected.to_string());
  1013    }

  1026  
  1027:     assert_eq!(args_method.to_string(), expected.to_string());
  1028    }

  1075      };
  1076:     assert_eq!(output.to_string(), expected.to_string());
  1077    }

  1111  
  1112:     assert_eq!(args_method.to_string(), expected.to_string());
  1113    }

  1139  
  1140:     assert_eq!(args_method.to_string(), expected.to_string());
  1141    }

crates/errmeta_derive/tests/test_args_as_expr.rs:
  124    let error_metas = ErrorMetas::from(&error);
  125:   assert_eq!(error_metas, expected);
  126  }

crates/errmeta_derive/tests/test_args_delegate.rs:
  75  fn test_args_delegate(#[case] error: TestArgsDelegate, #[case] args: HashMap<String, String>) {
  76:   assert_eq!(error.args(), args);
  77  }

crates/errmeta_derive/tests/test_error_metadata.rs:
  183    let error_metas = ErrorMetas::from(&error);
  184:   assert_eq!(error_metas, expected);
  185  }

crates/integration-tests/tests/test_live_api_ping.rs:
  27    let response = client.get(ping_endpoint).send().await?;
  28:   assert_eq!(response.status(), StatusCode::OK);
  29    Ok(())

crates/integration-tests/tests/test_live_chat_completions_non_streamed.rs:
  42      .await?;
  43:   assert_eq!(200, response.status());
  44    let response = response.json::<Value>().await?;

  51    };
  52:   assert_eq!(
  53:     expected,
  54:     response["choices"][0]["message"]["content"]
  55:       .as_str()
  56:       .unwrap()
  57:   );
  58:   assert_eq!("llama2:7b-chat", response["model"]);
  59:   assert_eq!("stop", response["choices"][0]["finish_reason"]);
  60    Ok(())

crates/integration-tests/tests/test_live_chat_completions_streamed.rs:
  44      .await?;
  45:   assert_eq!(response.status(), StatusCode::OK);
  46    let response = response.text().await?;

  69      .collect::<Vec<_>>();
  70:   assert_eq!(expected, actual);
  71    let expected: Value = serde_json::from_str(r#"[{"delta":{},"finish_reason":"stop","index":0}]"#)?;
  72    let last = streams.last().unwrap()["choices"].clone();
  73:   assert_eq!(expected, last);
  74    Ok(())

crates/llama_server_proc/src/error.rs:
  81    fn test_error_types() {
  82:     assert_eq!(
  83:       ServerError::ServerNotReady.error_type(),
  84:       ErrorType::InternalServer.to_string()
  85:     );
  86:     assert_eq!(
  87:       ServerError::TimeoutError(30).error_type(),
  88:       ErrorType::InternalServer.to_string()
  89:     );
  90    }

  93    fn test_error_status_codes() {
  94:     assert_eq!(ServerError::ServerNotReady.status(), 500);
  95:     assert_eq!(ServerError::StartupError("test".to_string()).status(), 500);
  96    }

crates/llama_server_proc/tests/test_server_proc.rs:
   94    let response = server.chat_completions(&request_body).await?;
   95:   assert_eq!(200, response.status());
   96    let response_body = response.json::<Value>().await.unwrap();
   97  
   98:   assert_eq!(
   99:     expected_content,
  100:     response_body["choices"][0]["message"]["content"]
  101:       .as_str()
  102:       .unwrap()
  103:   );
  104:   assert_eq!("llama2:7b-chat", response_body["model"]);
  105:   assert_eq!("stop", response_body["choices"][0]["finish_reason"]);
  106  

  122    let response = server.chat_completions(&request_body).await?;
  123:   assert_eq!(response.status(), 200);
  124    let response_text = response.text().await.unwrap();

  144  
  145:   assert_eq!(expected_content, actual);
  146  

  149    let last = streams.last().unwrap()["choices"].clone();
  150:   assert_eq!(expected, last);
  151  

crates/objs/src/alias.rs:
   70      };
   71:     assert_eq!(expected, alias.config_filename());
   72    }

  135      let actual = serde_yaml::to_string(&alias)?;
  136:     assert_eq!(expected, actual);
  137      Ok(())

  192      let actual = serde_yaml::from_str(serialized)?;
  193:     assert_eq!(expected, actual);
  194      Ok(())

  205      };
  206:     assert_eq!(
  207:       format!("{}", alias),
  208:       "Alias { alias: test:alias, repo: test/repo, filename: test.gguf, snapshot: main }"
  209:     );
  210    }

crates/objs/src/app_error.rs:
  189      let response = router.oneshot(req).await?;
  190:     assert_eq!(status, response.status());
  191      let bytes = response.into_body().collect().await.unwrap().to_bytes();

  193      let response_json = serde_json::from_str::<Value>(&str)?;
  194:     assert_eq!(response_json, expected);
  195      Ok(())

crates/objs/src/chat_template_type.rs:
  141    ) -> anyhow::Result<()> {
  142:     assert_eq!(Repo::try_from(expected)?, Repo::from(id));
  143      Ok(())

  151  
  152:     assert_eq!(template1, template2);
  153      assert_ne!(template1, template3);

  177      let deser: Test = serde_json::from_str(&input)?;
  178:     assert_eq!(deser, Test { template: expected });
  179      Ok(())

  197      let ser = serde_json::to_string(&Test { template: input })?;
  198:     assert_eq!(ser, format!("{{\"template\":{}}}", expected));
  199      Ok(())

crates/objs/src/chat_template.rs:
  378          .replace("\\n", "\n");
  379:       assert_eq!(expected, prompt);
  380      } else if expected["exception"]

  416      let empty = serde_json::from_str::<ChatTemplate>(&content)?;
  417:     assert_eq!(expected, empty);
  418      Ok(())

  429      assert!(config.is_err());
  430:     assert_eq!(expected, config.unwrap_err().to_string());
  431      Ok(())

  446      );
  447:     assert_eq!(expected, chat_template);
  448      Ok(())

  494      );
  495:     assert_eq!(expected, chat_template);
  496      Ok(())

  532      let expected = ChatTemplate::new(chat_template_version(), None, None);
  533:     assert_eq!(expected, chat_template);
  534      Ok(())

  548      let expected = ChatTemplate::new(chat_template_version(), None, None);
  549:     assert_eq!(expected, chat_template);
  550      Ok(())

  589      );
  590:     assert_eq!(expected, chat_template);
  591      Ok(())

  619      );
  620:     assert_eq!(expected, chat_template);
  621      Ok(())

crates/objs/src/error.rs:
  277        .unwrap();
  278:     assert_eq!(response.status(), StatusCode::BAD_REQUEST);
  279      let response = parse::<Value>(response).await;
  280:     assert_eq!(
  281:       response,
  282:       json! {{
  283:         "error": {
  284:           "message": "failed to parse the request body as JSON, error: \u{2068}Expected request with `Content-Type: application/json`\u{2069}",
  285:           "type": "invalid_request_error",
  286:           "code": "json_rejection_error"
  287:         }
  288:       }}
  289:     );
  290    }

crates/objs/src/hub_file.rs:
  122      );
  123:     assert_eq!(expected, local_model);
  124      Ok(())

  135      };
  136:     assert_eq!(
  137:       format!("{}", hub_file),
  138:       "HubFile { repo: test/repo, filename: test.gguf, snapshot: abc123 }"
  139:     );
  140    }

crates/objs/src/localization_service.rs:
  294      let result = localization_service.get_message(&lang_id, message_key, args)?;
  295:     assert_eq!(result, expected.to_string());
  296      Ok(())

  328      let result = localization_service.get_message(&lang_id, message_key, args)?;
  329:     assert_eq!(result, expected.to_string());
  330      Ok(())

  373      let result = localization_service.get_message(&lang_id, message_key, args)?;
  374:     assert_eq!(result, expected.to_string());
  375  

  399      assert!(result.is_err());
  400:     assert_eq!(
  401:       result.unwrap_err(),
  402:       LocalizationSetupError::LocaleNotSupported(LocaleNotSupportedError::new("en-UK".to_string()))
  403:     );
  404    }

  411      assert!(result.is_err());
  412:     assert_eq!(
  413:       result.unwrap_err(),
  414:       LocalizationSetupError::LocaleNotSupported(LocaleNotSupportedError::new("en-UK".to_string()))
  415:     );
  416    }

  432        LocalizationMessageError::LocaleNotSupported(LocaleNotSupportedError { locale }) => {
  433:         assert_eq!(locale, "ja-JP");
  434        }

  467        LocalizationMessageError::MessageNotFound(message) => {
  468:         assert_eq!(message, "missing-pattern");
  469        }

  494        LocalizationMessageError::FormatPattern(message) => {
  495:         assert_eq!(message, "Resolver error: Unknown variable: $nonexistent");
  496        }

  520      for result in results {
  521:       assert_eq!(result.unwrap(), "Hello, World!".to_string());
  522      }

crates/objs/src/oai.rs:
  185  
  186:     assert_eq!(request.frequency_penalty, Some(0.5));
  187:     assert_eq!(request.max_tokens, Some(100));
  188:     assert_eq!(request.presence_penalty, Some(0.2));
  189:     assert_eq!(request.seed, Some(42));
  190:     assert_eq!(
  191:       request.stop,
  192:       Some(Stop::StringArray(vec!["END".to_string()]))
  193:     );
  194:     assert_eq!(request.temperature, Some(0.7));
  195:     assert_eq!(request.top_p, Some(0.9));
  196:     assert_eq!(request.user, Some("test_user".to_string()));
  197    }

  219  
  220:     assert_eq!(request.frequency_penalty, Some(0.5));
  221:     assert_eq!(request.max_tokens, Some(50)); // Should not be updated
  222:     assert_eq!(request.presence_penalty, None);
  223:     assert_eq!(request.seed, None);
  224:     assert_eq!(request.stop, None);
  225:     assert_eq!(request.temperature, Some(0.5)); // Should not be updated
  226:     assert_eq!(request.top_p, Some(0.9));
  227:     assert_eq!(request.user, None);
  228    }

  232      let result = validate_range("2.5", 0.0, 2.0);
  233:     assert_eq!(
  234:       result.unwrap_err(),
  235:       "The value 2.5 is out of range. It must be between 0.0 and 2.0 inclusive."
  236:     );
  237  
  238      let result = validate_range("invalid", 0, 10);
  239:     assert_eq!(
  240:       result.unwrap_err(),
  241:       "'invalid' is not a valid number. Please enter a number between 0 and 10."
  242:     );
  243    }

crates/objs/src/repo.rs:
  108      assert!(repo.is_ok());
  109:     assert_eq!(repo.unwrap().to_string(), input);
  110      Ok(())

  125        ObjValidationError::ValidationErrors(errors) => {
  126:         assert_eq!(errors.errors().len(), 1);
  127:         assert_eq!(
  128:           errors.to_string(),
  129:           "value: does not match the huggingface repo pattern 'username/repo'"
  130:         );
  131        }

crates/objs/src/utils.rs:
  39    fn test_to_safe_filename(#[case] input: &str, #[case] expected: &str) {
  40:     assert_eq!(to_safe_filename(input), expected);
  41    }

crates/objs/src/gguf/metadata.rs:
  254    fn verify_basic_metadata(metadata: &GGUFMetadata) {
  255:     assert_eq!(metadata.magic(), GGUF_MAGIC);
  256:     assert_eq!(metadata.version(), 3);
  257:     assert_eq!(
  258:       metadata
  259:         .metadata()
  260:         .get("general.architecture")
  261:         .unwrap()
  262:         .as_str()
  263:         .unwrap(),
  264:       "llama"
  265:     );
  266    }

  277      let metadata = GGUFMetadata::new(PathBuf::from(input).as_path())?;
  278:     assert_eq!(metadata.magic(), GGUF_MAGIC);
  279:     assert_eq!(metadata.version(), version);
  280:     assert_eq!(metadata.metadata().len(), 1);
  281  

  293      // Sample0 should only have the architecture field
  294:     assert_eq!(metadata.metadata().len(), 1);
  295      Ok(())

  308      // Test all KV data types
  309:     assert_eq!(md.get("test_uint8").unwrap().as_u8()?, 255);
  310:     assert_eq!(md.get("test_int8").unwrap().as_i8()?, -128);
  311:     assert_eq!(md.get("test_uint16").unwrap().as_u16()?, 65535);
  312:     assert_eq!(md.get("test_int16").unwrap().as_i16()?, -32768);
  313:     assert_eq!(md.get("test_uint32").unwrap().as_u32()?, 4294967295);
  314:     assert_eq!(md.get("test_int32").unwrap().as_i32()?, -2147483648);
  315:     assert_eq!(
  316:       md.get("test_uint64").unwrap().as_u64()?,
  317:       18446744073709551615
  318:     );
  319:     assert_eq!(
  320:       md.get("test_int64").unwrap().as_i64()?,
  321:       -9223372036854775808
  322:     );
  323      assert!((md.get("test_float32").unwrap().as_f32()? - 3.14159).abs() < f32::EPSILON);
  324      assert!((md.get("test_float64").unwrap().as_f64()? - 2.718281828459045).abs() < f64::EPSILON);
  325:     assert_eq!(md.get("test_bool").unwrap().as_bool()?, true);
  326:     assert_eq!(md.get("test_string").unwrap().as_str()?, "Hello GGUF!");
  327  

  329      if let GGUFValue::Array(arr) = md.get("test_array_int").unwrap() {
  330:       assert_eq!(arr.len(), 5);
  331        for (i, val) in arr.iter().enumerate() {
  332:         assert_eq!(val.as_i32()?, (i + 1) as i32);
  333        }

  336      if let GGUFValue::Array(arr) = md.get("test_array_str").unwrap() {
  337:       assert_eq!(arr.len(), 3);
  338:       assert_eq!(arr[0].as_str()?, "a");
  339:       assert_eq!(arr[1].as_str()?, "b");
  340:       assert_eq!(arr[2].as_str()?, "c");
  341      }

  343      // Test original KV data
  344:     assert_eq!(md.get("context_length").unwrap().as_u32()?, 2048);
  345      assert!((md.get("rope_freq_base").unwrap().as_f32()? - 10000.0).abs() < f32::EPSILON);

  347      // Total number of KV pairs (including general.architecture)
  348:     assert_eq!(metadata.metadata().len(), 17);
  349      Ok(())

  362      // Basic token info
  363:     assert_eq!(md.get("vocab_size").unwrap().as_u32()?, 100);
  364  
  365      // Special tokens
  366:     assert_eq!(md.get("tokenizer.ggml.bos_token_id").unwrap().as_u32()?, 1);
  367:     assert_eq!(md.get("tokenizer.ggml.eos_token_id").unwrap().as_u32()?, 2);
  368:     assert_eq!(
  369:       md.get("tokenizer.ggml.padding_token_id")
  370:         .unwrap()
  371:         .as_u32()?,
  372:       3
  373:     );
  374:     assert_eq!(
  375:       md.get("tokenizer.ggml.seperator_token_id")
  376:         .unwrap()
  377:         .as_u32()?,
  378:       4
  379:     );
  380  

  382      if let GGUFValue::Array(tokens) = md.get("tokenizer.ggml.tokens").unwrap() {
  383:       assert_eq!(tokens.len(), 3);
  384:       assert_eq!(tokens[0].as_str()?, "<s>");
  385:       assert_eq!(tokens[1].as_str()?, "</s>");
  386:       assert_eq!(tokens[2].as_str()?, "<pad>");
  387      }

  389      // Token settings
  390:     assert_eq!(
  391:       md.get("tokenizer.ggml.add_bos_token").unwrap().as_bool()?,
  392:       true
  393:     );
  394:     assert_eq!(
  395:       md.get("tokenizer.ggml.add_eos_token").unwrap().as_bool()?,
  396:       true
  397:     );
  398:     assert_eq!(
  399:       md.get("tokenizer.ggml.add_space_prefix")
  400:         .unwrap()
  401:         .as_bool()?,
  402:       true
  403:     );
  404  
  405      // Tokenizer settings
  406:     assert_eq!(md.get("tokenizer.ggml.model").unwrap().as_str()?, "llama");
  407:     assert_eq!(
  408:       md.get("tokenizer.ggml.remove_extra_whitespaces")
  409:         .unwrap()
  410:         .as_bool()?,
  411:       true
  412:     );
  413  

crates/objs/src/test_utils/error.rs:
  12    let message = service.get_message(&EN_US, code, Some(args)).unwrap();
  13:   assert_eq!(
  14:     message
  15:       .to_string()
  16:       .replace("\u{2068}", "")
  17:       .replace("\u{2069}", ""),
  18:     expected
  19:   );
  20  }

crates/routes_all/src/routes_proxy.rs:
   91      let res = app.clone().oneshot(req).await.unwrap();
   92:     assert_eq!(res.status(), StatusCode::OK);
   93:     assert_eq!(res.text().await.unwrap(), "Test response");
   94  

  105        .unwrap();
  106:     assert_eq!(res.status(), StatusCode::OK);
  107:     assert_eq!(res.text().await.unwrap(), "Proxied response");
  108  

  114      let res = app.oneshot(req).await.unwrap();
  115:     assert_eq!(res.status(), StatusCode::NOT_FOUND);
  116  

crates/routes_app/src/routes_create.rs:
  248        .await?;
  249:     assert_eq!(response.status(), StatusCode::CREATED);
  250      let response = response.json::<AliasResponse>().await?;
  251:     assert_eq!(response, expected);
  252      Ok(())

  283        .await?;
  284:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  285      let response = response.json::<Value>().await?;
  286:     assert_eq!(
  287:       response,
  288:       json! {{
  289:         "error": {
  290:           "type": "not_found_error",
  291:           "code": "hub_file_not_found_error",
  292:           "message": "file '\u{2068}fakemodel.Q4_0.gguf\u{2069}' not found in huggingface repo '\u{2068}FakeFactory/not-exists\u{2069}', snapshot '\u{2068}main\u{2069}'"
  293:         }
  294:       }}
  295:     );
  296      Ok(())

  327  
  328:     assert_eq!(response.status(), StatusCode::OK);
  329      let updated_alias = response.json::<AliasResponse>().await?;
  330:     assert_eq!(
  331:       AliasResponseBuilder::tinyllama_builder()
  332:         .family(Some("tinyllama".to_string()))
  333:         .request_params(
  334:           OAIRequestParamsBuilder::default()
  335:             .temperature(0.8)
  336:             .max_tokens(2000_u16)
  337:             .build()
  338:             .unwrap()
  339:         )
  340:         .context_params(
  341:           GptContextParamsBuilder::default()
  342:             .n_ctx(4096)
  343:             .build()
  344:             .unwrap()
  345:         )
  346:         .build()
  347:         .unwrap(),
  348:       updated_alias
  349:     );
  350      Ok(())

  377  
  378:     assert_eq!(response.status(), StatusCode::BAD_REQUEST);
  379      let response = response.json::<Value>().await?;
  380:     assert_eq!(
  381:       response,
  382:       json! {{
  383:         "error": {
  384:           "type": "invalid_request_error",
  385:           "code": "create_alias_error-alias_mismatch",
  386:           "message": "alias in path '\u{2068}llama3:instruct\u{2069}' does not match alias in request '\u{2068}llama3:different\u{2069}'"
  387:         }
  388:       }}
  389:     );
  390      Ok(())

  421  
  422:     assert_eq!(response.status(), StatusCode::BAD_REQUEST);
  423      let response = response.json::<Value>().await?;
  424:     assert_eq!(
  425:       response,
  426:       json! {{
  427:         "error": {
  428:           "type": "invalid_request_error",
  429:           "code": "create_alias_error-alias_not_present",
  430:           "message": "alias is not present in request"
  431:         }
  432:       }}
  433:     );
  434      Ok(())

  485  
  486:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  487      let response = response.json::<Value>().await?;
  488:     assert_eq!(
  489:       response,
  490:       json! {{
  491:         "error": {
  492:           "type": "not_found_error",
  493:           "code": "hub_file_not_found_error",
  494:           "message": "file '\u{2068}tinyllama-1.1b-chat-v0.3.Q4_K_S.gguf\u{2069}' not found in huggingface repo '\u{2068}TheBloke/TinyLlama-1.1B-Chat-v0.3-GGUF\u{2069}', snapshot '\u{2068}main\u{2069}'"
  495:         }
  496:       }}
  497:     );
  498      Ok(())

crates/routes_app/src/routes_login.rs:
   347      assert!(location.starts_with(login_url));
   348:     assert_eq!(status, StatusCode::FOUND);
   349  

   351      let query_params: HashMap<_, _> = url.query_pairs().into_owned().collect();
   352:     assert_eq!(query_params.get("response_type").unwrap(), "code");
   353:     assert_eq!(query_params.get("client_id").unwrap(), "test_client_id");
   354:     assert_eq!(query_params.get("redirect_uri").unwrap(), callback_url);
   355      assert!(query_params.contains_key("state"));
   356      assert!(query_params.contains_key("code_challenge"));
   357:     assert_eq!(query_params.get("code_challenge_method").unwrap(), "S256");
   358:     assert_eq!(query_params.get("scope").unwrap(), "openid email profile");
   359  

   427        .await?;
   428:     assert_eq!(resp.status(), status);
   429      assert!(resp

   457      let (generated_verifier, challenge) = generate_pkce();
   458:     assert_eq!(generated_verifier.len(), 43);
   459:     assert_eq!(challenge.len(), 43);
   460    }

   536      resp.assert_status(StatusCode::FOUND);
   537:     assert_eq!(
   538:       resp.headers().get(LOCATION).unwrap(),
   539:       "http://frontend.localhost:3000/ui/home"
   540:     );
   541      let session_id = resp.cookie("bodhiapp_session_id");

   546      let access_token = access_token.as_str().unwrap();
   547:     assert_eq!(access_token, token);
   548      let refresh_token = session_service

   552      let refresh_token = refresh_token.as_str().unwrap();
   553:     assert_eq!(refresh_token, "test_refresh_token");
   554      Ok(())

   582        .await?;
   583:     assert_eq!(resp.status(), StatusCode::INTERNAL_SERVER_ERROR);
   584      let json = resp.json::<Value>().await?;
   585:     assert_eq!(
   586:       json,
   587:       json! {{
   588:         "error": {
   589:           "message": "login info not found in session, are cookies enabled?",
   590:           "code": "login_error-session_info_not_found",
   591:           "type": "internal_server_error"
   592:         }
   593:       }}
   594:     );
   595      Ok(())

   658        "invalid request, reason: \u{2068}".to_string() + expected_error + "\u{2069}";
   659:     assert_eq!(
   660:       error,
   661:       json! {{
   662:         "error": {
   663:           "message": expected_message,
   664:           "code": "bad_request_error",
   665:           "type": "invalid_request_error"
   666:         }}
   667:       }
   668:     );
   669      Ok(())

   732      let error = resp.json::<Value>();
   733:     assert_eq!(
   734:       error,
   735:       json! {{
   736:         "error": {
   737:           "message": "error from auth service: \u{2068}network error\u{2069}",
   738:           "code": "auth_service_error-auth_service_api_error",
   739:           "type": "internal_server_error"
   740:         }
   741:       }}
   742:     );
   743      Ok(())

   788      let location = location.to_str().unwrap();
   789:     assert_eq!("http://localhost:1135/ui/login", location);
   790      let record = session_service.get_session_record(session_id).await;

   818        .unwrap();
   819:     assert_eq!(response.status(), StatusCode::OK);
   820      let response_json = response.json::<Value>().await.unwrap();
   821:     assert_eq!(
   822:       "testuser@email.com",
   823:       response_json["email"].as_str().unwrap(),
   824:     );
   825      Ok(())

   847        .unwrap();
   848:     assert_eq!(response.status(), StatusCode::OK);
   849      let response_json = response.json::<UserInfo>().await?;
   850:     assert_eq!(
   851:       UserInfo {
   852:         logged_in: false,
   853:         email: None,
   854:       },
   855:       response_json
   856:     );
   857      Ok(())

   881        .unwrap();
   882:     assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
   883      let response = response.json::<Value>().await?;
   884:     assert_eq!(
   885:       response,
   886:       json! {{
   887:         "error": {
   888:           "message": "authentication token is invalid",
   889:           "code": "json_web_token_error-InvalidToken",
   890:           "type": "authentication_error"
   891:         }
   892:       }}
   893:     );
   894      Ok(())

  1072    ) -> anyhow::Result<()> {
  1073:     assert_eq!(response.status(), StatusCode::FOUND);
  1074:     assert_eq!(
  1075:       response.headers().get("Location").unwrap(),
  1076:       "http://frontend.localhost:3000/ui/home"
  1077:     );
  1078      let secret_service = app_service.secret_service();
  1079      let updated_status = secret_service.app_status().unwrap();
  1080:     assert_eq!(AppStatus::Ready, updated_status);
  1081      Ok(())

crates/routes_app/src/routes_pull.rs:
  302  
  303:     assert_eq!(response.status(), StatusCode::CREATED);
  304      let download_request = response.json::<DownloadRequest>().await?;
  305:     assert_eq!(download_request.repo, Repo::testalias().to_string());
  306:     assert_eq!(download_request.filename, Repo::testalias_q4());
  307:     assert_eq!(download_request.status, DownloadStatus::Pending);
  308  

  320        .unwrap();
  321:     assert_eq!(final_status.status, DownloadStatus::Completed);
  322      Ok(())

  357  
  358:     assert_eq!(response.status(), StatusCode::BAD_REQUEST);
  359      let error_body = response.json::<Value>().await?;
  360:     assert_eq!(
  361:       error_body,
  362:       json! {{
  363:         "error": {
  364:           "message": "file \u{2068}testalias.Q8_0.gguf\u{2069} already exists in repo \u{2068}MyFactory/testalias-gguf\u{2069} with snapshot \u{2068}main\u{2069}",
  365:           "code": "pull_error-file_already_exists",
  366:           "type": "invalid_request_error"
  367:         }
  368:       }}
  369:     );
  370      Ok(())

  410  
  411:     assert_eq!(response.status(), StatusCode::OK);
  412      let download_request = response.json::<DownloadRequest>().await?;
  413:     assert_eq!(download_request.id, pending_request.id);
  414:     assert_eq!(download_request.repo, Repo::testalias().to_string());
  415:     assert_eq!(download_request.filename, Repo::testalias_q4());
  416:     assert_eq!(download_request.status, DownloadStatus::Pending);
  417  

  456  
  457:     assert_eq!(response.status(), StatusCode::CREATED);
  458      let download_request = response.json::<DownloadRequest>().await?;
  459:     assert_eq!(download_request.repo, Repo::testalias().to_string());
  460:     assert_eq!(download_request.filename, Repo::testalias_q4());
  461:     assert_eq!(download_request.status, DownloadStatus::Pending);
  462  

  472        .unwrap();
  473:     assert_eq!(final_status.status, DownloadStatus::Completed);
  474      Ok(())

  501        .await?;
  502:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  503      let response = response.json::<Value>().await?;
  504:     assert_eq!(
  505:       response,
  506:       json! {{
  507:         "error": {
  508:           "message": "remote model alias '\u{2068}non_existent:alias\u{2069}' not found, check your alias and try again",
  509:           "type": "not_found_error",
  510:           "code": "remote_model_not_found_error"
  511:         }
  512:       }}
  513:     );
  514      Ok(())

  547  
  548:     assert_eq!(response.status(), StatusCode::OK);
  549      let download_request = response.json::<DownloadRequest>().await?;
  550:     assert_eq!(download_request.id, test_request.id);
  551:     assert_eq!(download_request.status, DownloadStatus::Pending);
  552  

  582  
  583:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  584      let response = response.json::<Value>().await?;
  585:     assert_eq!(
  586:       response,
  587:       json! {{
  588:         "error": {
  589:           "message": "item '\u{2068}non_existent_id\u{2069}' of type '\u{2068}download_requests\u{2069}' not found in db",
  590:           "type": "not_found_error",
  591:           "code": "item_not_found"
  592:         }
  593:       }}
  594:     );
  595      Ok(())

crates/routes_app/src/routes_setup.rs:
  170        .await?;
  171:     assert_eq!(resp.status(), StatusCode::OK);
  172      let value = resp.json::<AppInfo>().await?;
  173:     assert_eq!(expected, value);
  174      Ok(())

  210  
  211:     assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
  212      let body = resp.json::<Value>().await?;
  213:     assert_eq!(
  214:       body,
  215:       json! {{
  216:         "error": {
  217:           "message": "app is already setup",
  218:           "code": "app_service_error-already_setup",
  219:           "type": "invalid_request_error",
  220:         }
  221:       }}
  222:     );
  223  
  224      let secret_service = app_service.secret_service();
  225:     assert_eq!(secret_service.authz().unwrap(), true);
  226:     assert_eq!(secret_service.app_status().unwrap(), AppStatus::Ready);
  227      let app_reg_info = secret_service.app_reg_info().unwrap();

  293  
  294:     assert_eq!(StatusCode::OK, response.status());
  295      let secret_service = app_service.secret_service();
  296:     assert_eq!(expected_status, secret_service.app_status().unwrap(),);
  297:     assert_eq!(secret_service.authz().unwrap(), request.authz);
  298      let app_reg_info = secret_service.app_reg_info().unwrap();
  299:     assert_eq!(request.authz, app_reg_info.is_some());
  300      Ok(())

  341  
  342:     assert_eq!(resp.status(), StatusCode::INTERNAL_SERVER_ERROR);
  343      let body = resp.json::<Value>().await?;
  344:     assert_eq!(
  345:       body,
  346:       json! {{
  347:         "error": {
  348:           "message": "error connecting to internal service: \u{2068}failed to register as resource server\u{2069}",
  349:           "code": "reqwest_error",
  350:           "type": "internal_server_error",
  351:         }
  352:       }}
  353:     );
  354      Ok(())

  391        .await?;
  392:     assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
  393      let body = resp.json::<Value>().await?;
  394:     assert_eq!(
  395:       body,
  396:       json! {{
  397:         "error": {
  398:           "message": expected_error,
  399:           "type": "invalid_request_error",
  400:           "code": "json_rejection_error"
  401:         }
  402:       }}
  403:     );
  404      Ok(())

crates/routes_app/src/routes_ui.rs:
  144        .await?;
  145:     assert_eq!(2, response.as_array().length().unwrap());
  146      let expected_1: Value = serde_json::from_str(&format!(

  149      ))?;
  150:     assert_eq!(expected_1, response[0]);
  151      let expected_2: Value = serde_json::from_str(&format!(

  154      ))?;
  155:     assert_eq!(expected_2, response[1]);
  156      Ok(())

  200      let expected = serde_json::from_str::<Value>(&expected)?;
  201:     assert_eq!(expected, response);
  202      Ok(())

  238        .await?;
  239:     assert_eq!("", response);
  240      let convos = router

  278        .await?;
  279:     assert_eq!(StatusCode::OK, response.status());
  280      let convos = db_service.list_conversations().await?;

  308        .await?;
  309:     assert_eq!(StatusCode::INTERNAL_SERVER_ERROR, response.status());
  310      let response = response.json::<Value>().await?;
  311:     assert_eq!(
  312:       response,
  313:       json! {{
  314:         "error": {
  315:           "message": "no rows returned by a query that expected to return at least one row",
  316:           "code": "sqlx_error",
  317:           "type": "internal_server_error"
  318:         }
  319:       }}
  320:     );
  321      Ok(())

  357        .await?;
  358:     assert_eq!(StatusCode::CREATED, response.status());
  359      let location = response

  367      let from_db = db_service.get_conversation_with_messages(chat_id).await?;
  368:     assert_eq!(1713590479, from_db.created_at.timestamp());
  369:     assert_eq!(2, from_db.messages.len());
  370:     assert_eq!("What is the capital of France?", from_db.title);
  371:     assert_eq!(
  372:       "What is the capital of France?",
  373:       from_db.messages.first().unwrap().content.as_ref().unwrap()
  374:     );
  375:     assert_eq!("user", from_db.messages.first().unwrap().role);
  376:     assert_eq!(
  377:       "The capital of France is Paris.",
  378:       from_db.messages.get(1).unwrap().content.as_ref().unwrap()
  379:     );
  380:     assert_eq!("assistant", from_db.messages.get(1).unwrap().role);
  381      let text = response.text().await?;
  382:     assert_eq!("", text);
  383      Ok(())

  416        .await?;
  417:     assert_eq!(StatusCode::CREATED, response.status());
  418  

  436        .await?;
  437:     // assert_eq!(StatusCode::CREATED, response.status());
  438:     assert_eq!("", response.text().await?);
  439      let from_db = db_service.get_conversation_with_messages("NEWID07").await?;
  440:     assert_eq!(2, from_db.messages.len());
  441:     assert_eq!(
  442:       "What is the capital of France?",
  443:       from_db.messages.first().unwrap().content.as_ref().unwrap()
  444:     );
  445:     assert_eq!(
  446:       "The capital of France is Paris.",
  447:       from_db.messages.get(1).unwrap().content.as_ref().unwrap()
  448:     );
  449      Ok(())

crates/routes_oai/src/routes_chat.rs:
  101        .unwrap();
  102:     assert_eq!(StatusCode::OK, response.status());
  103      let result: CreateChatCompletionResponse = response.json().await.unwrap();
  104:     assert_eq!(
  105:       "The day that comes after Monday is Tuesday.",
  106:       result
  107:         .choices
  108:         .first()
  109:         .unwrap()
  110:         .message
  111:         .content
  112:         .as_ref()
  113:         .unwrap()
  114:     );
  115      Ok(())

  187        .await?;
  188:     assert_eq!(StatusCode::OK, response.status());
  189      let response: Vec<CreateChatCompletionStreamResponse> = response.sse().await?;

  201      });
  202:     assert_eq!("  After Monday, the next day is Tuesday.", content);
  203      Ok(())

crates/routes_oai/src/routes_models.rs:
  191        .await?;
  192:     assert_eq!(response["page"], 1);
  193:     assert_eq!(response["page_size"], 30);
  194:     assert_eq!(response["total"], 6);
  195      let data = response["data"].as_array().unwrap();
  196      assert!(!data.is_empty());
  197:     assert_eq!(
  198:       data.first().unwrap()["alias"].as_str().unwrap(),
  199:       "FakeFactory/fakemodel-gguf:Q4_0"
  200:     );
  201      Ok(())

  218        .await?;
  219:     assert_eq!(response["page"], 2);
  220:     assert_eq!(response["page_size"], 4);
  221:     assert_eq!(response["total"], 6);
  222      let data = response["data"].as_array().unwrap();
  223:     assert_eq!(data.len(), 2);
  224      Ok(())

  242  
  243:     assert_eq!(response["page_size"], 100);
  244      Ok(())

  287  
  288:     assert_eq!(expected, *first_alias);
  289      Ok(())

  327        .await?;
  328:     assert_eq!(response.status(), StatusCode::OK);
  329      let alias_response = response.json::<AliasResponse>().await?;
  330      let expected = AliasResponse::llama3();
  331:     assert_eq!(expected, alias_response);
  332      Ok(())

  348        .await?;
  349:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  350      let response = response.json::<Value>().await?;
  351:     assert_eq!(
  352:       response,
  353:       json! {{
  354:         "error": {
  355:           "message": "alias '\u{2068}non_existent_alias\u{2069}' not found in $BODHI_HOME/aliases",
  356:           "code": "alias_not_found_error",
  357:           "type": "not_found_error"
  358:         }
  359:       }}
  360:     );
  361      Ok(())

  376        .await?;
  377:     assert_eq!(response.status(), StatusCode::OK);
  378      let response = response.json::<Vec<ChatTemplateType>>().await?;
  379  
  380:     assert_eq!(14, response.len());
  381      for template_id in ChatTemplateId::iter() {

crates/routes_oai/src/routes_oai_models.rs:
   90  
   91:     assert_eq!(response.status(), StatusCode::OK);
   92      let response = response.json::<Value>().await?;
   93:     assert_eq!(
   94:       response,
   95:       json! {{
   96:         "object": "list",
   97:         "data": [
   98:           {
   99:             "id": "llama3:instruct",
  100:             "object": "model",
  101:             "created": 0,
  102:             "owned_by": "system"
  103:           },
  104:           {
  105:             "id": "testalias-exists:instruct",
  106:             "object": "model",
  107:             "created": 0,
  108:             "owned_by": "system"
  109:           },
  110:           {
  111:             "id": "tinyllama:instruct",
  112:             "object": "model",
  113:             "created": 0,
  114:             "owned_by": "system"
  115:           },
  116:           {
  117:             "id": "FakeFactory/fakemodel-gguf:Q4_0",
  118:             "object": "model",
  119:             "created": 0,
  120:             "owned_by": "system"
  121:           },
  122:           {
  123:             "id": "TheBloke/Llama-2-7B-Chat-GGUF:Q8_0",
  124:             "object": "model",
  125:             "created": 0,
  126:             "owned_by": "system"
  127:           },
  128:           {
  129:             "id": "TheBloke/TinyLlama-1.1B-Chat-v0.3-GGUF:Q2_K",
  130:             "object": "model",
  131:             "created": 0,
  132:             "owned_by": "system"
  133:           },
  134:         ]
  135:       }}
  136:     );
  137      Ok(())

  151  
  152:     assert_eq!(response.status(), StatusCode::OK);
  153      let response = response.json::<Value>().await?;
  154:     assert_eq!(
  155:       response,
  156:       json! {{
  157:         "id": "llama3:instruct",
  158:         "object": "model",
  159:         "created": 0,
  160:         "owned_by": "system",
  161:       }}
  162:     );
  163      Ok(())

  180  
  181:     assert_eq!(response.status(), StatusCode::NOT_FOUND);
  182      Ok(())

crates/routes_oai/src/routes_ollama.rs:
  488        .await?;
  489:     assert_eq!(6, response["models"].as_array().length().unwrap());
  490      let llama3 = response["models"]

  495        .unwrap();
  496:     assert_eq!(llama3["digest"], "5007652f7a641fe7170e0bad4f63839419bd9213");
  497      Ok(())

  514        .await?;
  515:     assert_eq!(
  516:       json! {
  517:       {
  518:         "families": null,
  519:         "family": "llama3",
  520:         "format": "gguf",
  521:         "parameter_size": "",
  522:         "parent_model": null,
  523:         "quantization_level": ""
  524:       }},
  525:       response["details"]
  526:     );
  527:     assert_eq!("llama3", response["template"]);
  528:     assert_eq!(
  529:       r#"n_keep: 24
  530: stop:
  531: - <|start_header_id|>
  532: - <|end_header_id|>
  533: - <|eot_id|>
  534: "#,
  535:       response["parameters"].as_str().unwrap()
  536:     );
  537      Ok(())

crates/server_app/src/interactive.rs:
  271        )) => {
  272:         assert_eq!(filename, "notexists.Q8_0.gguf");
  273:         assert_eq!(repo, "MyFactory/testalias-gguf");
  274:         assert_eq!(snapshot, "5007652f7a641fe7170e0bad4f63839419bd9213");
  275        }

crates/server_app/src/run.rs:
   90        RunCommandError::RemoteModelNotFound(RemoteModelNotFoundError { alias }) => {
   91:         assert_eq!(alias, "testalias:notexists");
   92        }

  131        .unwrap();
  132:     assert_eq!(
  133:       Alias {
  134:         alias: "testalias:q4_instruct".to_string(),
  135:         family: Some("testalias".to_string()),
  136:         repo: Repo::testalias(),
  137:         filename: Repo::testalias_q4(),
  138:         snapshot: SNAPSHOT.to_string(),
  139:         features: vec!["chat".to_string()],
  140:         chat_template: ChatTemplateType::Id(ChatTemplateId::Llama3),
  141:         request_params: OAIRequestParams::default(),
  142:         context_params: GptContextParams::default(),
  143:       },
  144:       created
  145:     );
  146      Ok(())

crates/server_app/src/server.rs:
  145        .await?;
  146:     assert_eq!("pong", response);
  147      shutdown

crates/server_core/src/direct_sse.rs:
  251        .unwrap();
  252:     assert_eq!(StatusCode::OK, response.status());
  253      let response = response.direct_sse().await.unwrap();
  254:     assert_eq!(3, response.len());
  255:     assert_eq!(
  256:       vec![
  257:         "value 1".to_string(),
  258:         "value 2".to_string(),
  259:         "value 3".to_string()
  260:       ],
  261:       response
  262:     );
  263      Ok(())

  293        .unwrap();
  294:     assert_eq!(StatusCode::OK, response.status());
  295      let response = response.direct_sse().await.unwrap();
  296:     assert_eq!(6, response.len());
  297:     assert_eq!(
  298:       vec![
  299:         "value 1".to_string(),
  300:         ":".to_string(),
  301:         "value 2".to_string(),
  302:         ":".to_string(),
  303:         "value 3".to_string(),
  304:         ":".to_string(),
  305:       ],
  306:       response
  307:     );
  308      Ok(())

crates/server_core/src/fwd_sse.rs:
  64  
  65:     assert_eq!(response.status(), StatusCode::OK);
  66:     assert_eq!(response.headers()["content-type"], "text/event-stream");
  67      let response = response.direct_sse().await?;
  68:     assert_eq!(6, response.len());
  69:     assert_eq!(
  70:       vec![
  71:         "data: message 1".to_string(),
  72:         "".to_string(),
  73:         "data: message 2".to_string(),
  74:         "".to_string(),
  75:         "data: message 3".to_string(),
  76:         "".to_string(),
  77:       ],
  78:       response
  79:     );
  80      Ok(())

crates/server_core/src/router_state.rs:
  102        RouterStateError::AliasNotFound(err) => {
  103:         assert_eq!("not-found", err.0);
  104        }

  170        RouterStateError::ContextError(ContextError::Server(ServerError::StartupError(msg))) => {
  171:         assert_eq!("test error", msg);
  172        }

crates/server_core/src/shared_rw.rs:
  240      let result = ModelLoadStrategy::choose(loaded_alias, request_alias);
  241:     assert_eq!(result, expected);
  242      Ok(())

crates/services/src/auth_service.rs:
  359      let app_reg_info = result.unwrap();
  360:     assert_eq!(
  361:       AppRegInfo {
  362:         public_key: "test-public-key".to_string(),
  363:         alg: Algorithm::RS256,
  364:         kid: "test-kid".to_string(),
  365:         issuer: "test-issuer".to_string(),
  366:         client_id: "test-client".to_string(),
  367:         client_secret: "test-secret".to_string(),
  368:       },
  369:       app_reg_info
  370:     );
  371      mock_server.assert();

  446      let (access_token, refresh_token) = result.unwrap();
  447:     assert_eq!(access_token.secret(), new_access_token);
  448:     assert_eq!(refresh_token.secret(), new_refresh_token);
  449  

crates/services/src/cache_service.rs:
  47      cache_service.set("key1", "value1");
  48:     assert_eq!(cache_service.get("key1"), Some("value1".to_string()));
  49  
  50      cache_service.remove("key1");
  51:     assert_eq!(cache_service.get("key1"), None);
  52    }

crates/services/src/data_service.rs:
  354      let remote_model = service.find_remote_model(&alias)?;
  355:     assert_eq!(found, remote_model.is_some());
  356      Ok(())

  365      let expected_2 = RemoteModel::testalias();
  366:     assert_eq!(7, models.len());
  367      assert!(models.contains(&expected_1));

  377      let expected = Alias::testalias_exists();
  378:     assert_eq!(Some(expected), alias);
  379      Ok(())

  386      let result = service.list_aliases()?;
  387:     assert_eq!(6, result.len());
  388      assert!(result.contains(&Alias::llama3()));

  434      expected.alias = "tinyllama:mymodel".to_string();
  435:     assert_eq!(expected, new_alias);
  436      Ok(())

  449      let content = service.read_file(folder.clone(), filename)?;
  450:     assert_eq!(b"test content".to_vec(), content);
  451  

  467      let content = fs::read(&file_path)?;
  468:     assert_eq!(b"test content".to_vec(), content);
  469  

  473      let content = fs::read(&root_file_path)?;
  474:     assert_eq!(b"test content in root".to_vec(), content);
  475  

  489      let content = fs::read(&file_path)?;
  490:     assert_eq!(b"new content".to_vec(), content);
  491  

crates/services/src/env_wrapper.rs:
   63      std::env::set_var("TEST_KEY", "test_value");
   64:     assert_eq!(wrapper.var("TEST_KEY").unwrap(), "test_value");
   65      std::env::remove_var("TEST_KEY");

   71      wrapper.set_var("CUSTOM_KEY", "custom_value");
   72:     assert_eq!(wrapper.var("CUSTOM_KEY").unwrap(), "custom_value");
   73    }

   95      wrapper.load(temp_file.path());
   96:     assert_eq!(std::env::var("TEST_ENV_VAR").unwrap(), "test_value");
   97      std::env::remove_var("TEST_ENV_VAR");

  103      wrapper.set_var("OVERWRITE_KEY", "first_value");
  104:     assert_eq!(wrapper.var("OVERWRITE_KEY").unwrap(), "first_value");
  105      wrapper.set_var("OVERWRITE_KEY", "second_value");
  106:     assert_eq!(wrapper.var("OVERWRITE_KEY").unwrap(), "second_value");
  107    }

crates/services/src/hub_service.rs:
   598      );
   599:     assert_eq!(expected, local_model_file);
   600      let expected = format!(

   604      );
   605:     assert_eq!(expected, fs::read_to_string(local_model_file.path())?);
   606      Ok(())

   641        }) => {
   642:         assert_eq!(actual_error.to_string(), error);
   643:         assert_eq!(error_status, 401);
   644:         assert_eq!(actual_repo, repo);
   645:         assert_eq!(kind, HubApiErrorKind::MayBeNotExists);
   646        }

   689        }) => {
   690:         assert_eq!(actual_error.to_string(), error);
   691:         assert_eq!(error_status, 403);
   692:         assert_eq!(repo.to_string(), "amir36/test-gated-repo".to_string());
   693:         assert_eq!(kind, HubApiErrorKind::GatedAccess);
   694        }

   735        }) => {
   736:         assert_eq!(actual_error.to_string(), error);
   737:         assert_eq!(error_status, 404);
   738:         assert_eq!(actual_repo, "amir36/not-exists");
   739:         assert_eq!(kind, HubApiErrorKind::NotExists);
   740        }

   777        .to_string();
   778:     assert_eq!(expected, path.display().to_string());
   779      let expected = format!(

   783      );
   784:     assert_eq!(expected, fs::read_to_string(path)?);
   785      Ok(())

   801      let content = fs::read_to_string(local_model_file.path())?;
   802:     assert_eq!(expected, content);
   803      Ok(())

   843      let snapshot = "9ca625120374ddaae21f067cb006517d14dc91a6";
   844:     assert_eq!(
   845:       HubFile::new(
   846:         service.hf_cache(),
   847:         repo.clone(),
   848:         filename.to_string(),
   849:         snapshot.to_string(),
   850:         Some(704),
   851:       ),
   852:       hub_file
   853:     );
   854      Ok(())

   884      );
   885:     assert_eq!(6, models.len());
   886      models.sort();
   887:     assert_eq!(&expected_1, models.first().unwrap());
   888      Ok(())

   895      let repos = service.list_local_tokenizer_configs();
   896:     assert_eq!(5, repos.len(), "Expected 5 repos with tokenizer configs");
   897      let expected_repos: HashSet<Repo> = [

   907      let result_set: HashSet<Repo> = repos.into_iter().collect();
   908:     assert_eq!(
   909:       expected_repos, result_set,
   910:       "Mismatch in expected and actual repos"
   911:     );
   912      Ok(())

   927      let exists = service.local_file_exists(&repo, filename, Some(snapshot))?;
   928:     assert_eq!(expected, exists);
   929      Ok(())

  1004  
  1005:     assert_eq!(expected, aliases);
  1006      Ok(())

crates/services/src/init_service.rs:
  176    fn test_init_service_error_messages(#[case] error: InitServiceError, #[case] message: String) {
  177:     assert_eq!(message, error.to_string());
  178    }

  190      let result = init_service.setup_bodhi_home()?;
  191:     assert_eq!(bodhi_home, result);
  192      Ok(())

  205      let result = init_service.setup_bodhi_home()?;
  206:     assert_eq!(temp_dir.path().join(".cache").join("bodhi-dev"), result);
  207      Ok(())

  258  
  259:     assert_eq!(result, hf_home);
  260      assert!(hf_home.join("hub").exists());

  303  
  304:     assert_eq!(result, expected_hf_home);
  305      assert!(expected_hf_home.join("hub").exists());

  322  
  323:     assert_eq!(result, logs_dir);
  324      assert!(logs_dir.exists());

  347  
  348:     assert_eq!(result, expected_logs_dir);
  349      assert!(expected_logs_dir.exists());

crates/services/src/secret_service.rs:
  320      let value = service.get_secret_string("test_key").unwrap();
  321:     assert_eq!(value, Some("test_value".to_string()));
  322:     assert_eq!(cache.get("test_key"), Some("test_value".to_string()));
  323  
  324      service.delete_secret("test_key").unwrap();
  325:     assert_eq!(service.get_secret_string("test_key")?, None);
  326:     assert_eq!(cache.as_ref().get("test_key"), None);
  327      Ok(())

  351      let retrieved_object: Option<TestObject> = get_secret(&service, "test_object").unwrap();
  352:     assert_eq!(retrieved_object, Some(test_object));
  353  

  355      let deleted_object: Option<TestObject> = get_secret(&service, "test_object").unwrap();
  356:     assert_eq!(deleted_object, None);
  357      Ok(())

  364      service.set_secret_string("test-key", "test-value")?;
  365:     assert_eq!(
  366:       service.get_secret_string("test-key")?,
  367:       Some("test-value".to_string())
  368:     );
  369      drop(service);

  388      service.set_secret_string("test-key", "test-value")?;
  389:     assert_eq!(
  390:       service.get_secret_string("test-key")?,
  391:       Some("test-value".to_string())
  392:     );
  393  

  400      let value = service2.get_secret_string("test-key")?;
  401:     assert_eq!(value, Some("test-value".to_string()));
  402  

  412      // Verify it exists
  413:     assert_eq!(
  414:       service.get_secret_string("test-key")?,
  415:       Some("test-value".to_string())
  416:     );
  417  

  421      // Verify it's gone
  422:     assert_eq!(service.get_secret_string("test-key")?, None);
  423  

crates/services/src/service_ext.rs:
  107      let retrieved_info = service.app_reg_info()?.expect("Should have app reg info");
  108:     assert_eq!(retrieved_info, app_reg_info);
  109  
  110      let initial_status = service.app_status()?;
  111:     assert_eq!(initial_status, AppStatus::default());
  112  

  114      service.set_app_status(&new_status)?;
  115:     assert_eq!(service.app_status()?, new_status);
  116  

crates/services/src/setting_service.rs:
  201      let service = DefaultSettingService::new(Arc::new(mock_env), path.clone());
  202:     assert_eq!(
  203:       service.get_setting("TEST_KEY"),
  204:       Some("file_value".to_string())
  205:     );
  206      Ok(())

  218      let service = DefaultSettingService::new(Arc::new(mock_env), path);
  219:     assert_eq!(
  220:       service.get_setting("TEST_KEY"),
  221:       Some("env_value".to_string())
  222:     );
  223      Ok(())

  250      let retrieved: Option<TestConfig> = get_setting(&service, "TEST_CONFIG")?;
  251:     assert_eq!(retrieved, Some(test_config));
  252      Ok(())

  275        let service = DefaultSettingService::new(Arc::new(mock_env), path.clone());
  276:       assert_eq!(
  277:         service.get_setting("TEST_KEY"),
  278:         Some("test_value".to_string())
  279:       );
  280      }
  281      let contents = std::fs::read_to_string(path)?;
  282:     assert_eq!(contents, "TEST_KEY: test_value\n");
  283      Ok(())

  298      service.set_setting("TEST_KEY", "test_value")?;
  299:     assert_eq!(
  300:       service.get_setting("TEST_KEY"),
  301:       Some("test_value".to_string())
  302:     );
  303  
  304      service.delete_setting("TEST_KEY")?;
  305:     assert_eq!(service.get_setting("TEST_KEY"), None);
  306      let contents = std::fs::read_to_string(path)?;
  307:     assert_eq!("{}\n", contents);
  308  

  334      let retrieved: Option<TestConfig> = get_setting(&service, "TEST_CONFIG").unwrap();
  335:     assert_eq!(retrieved, Some(test_config));
  336  

  341      let deleted: Option<TestConfig> = get_setting(&service, "TEST_CONFIG").unwrap();
  342:     assert_eq!(deleted, None);
  343      Ok(())

crates/services/src/db/objs.rs:
  154      let result: Conversation = serde_json::from_str(&input)?;
  155:     assert_eq!(expected, result);
  156      Ok(())

  177      let content = serde_json::to_string(&obj).unwrap();
  178:     assert_eq!(expected, content);
  179      Ok(())

crates/services/src/db/service.rs:
  469      let convos = service.list_conversations().await?;
  470:     assert_eq!(1, convos.len());
  471      conversation.updated_at = now;
  472:     assert_eq!(&conversation, convos.first().unwrap());
  473      Ok(())

  499      let convos = service.list_conversations().await?;
  500:     assert_eq!(1, convos.len());
  501:     assert_eq!(&conversation, convos.first().unwrap());
  502      Ok(())

  519      let convos = service.list_conversations().await?;
  520:     assert_eq!(2, convos.len());
  521      Ok(())

  547        .await?;
  548:     assert_eq!(&message, convos.messages.first().unwrap());
  549      Ok(())

  627      assert!(fetched.is_some());
  628:     assert_eq!(request, fetched.unwrap());
  629      Ok(())

  655      let fetched = service.get_download_request(&request.id).await?.unwrap();
  656:     assert_eq!(
  657:       DownloadRequest {
  658:         id: request.id,
  659:         repo: "test/repo".to_string(),
  660:         filename: "test_file.gguf".to_string(),
  661:         status: DownloadStatus::Completed,
  662:         created_at: now,
  663:         updated_at: now + chrono::Duration::hours(1),
  664:       },
  665:       fetched
  666:     );
  667      Ok(())

  699      let pending_downloads = service.list_pending_downloads().await?;
  700:     assert_eq!(1, pending_downloads.len());
  701:     assert_eq!(pending_request, pending_downloads[0]);
  702      Ok(())

  722      };
  723:     assert_eq!(pending_request, expected_request);
  724      Ok(())

  738      assert!(fetched_request.is_some());
  739:     assert_eq!(fetched_request.unwrap(), inserted_request);
  740      Ok(())

  760      let page1 = service.list_pending_requests(1, 2).await?;
  761:     assert_eq!(page1.len(), 2);
  762      let page2 = service.list_pending_requests(2, 2).await?;
  763:     assert_eq!(page2.len(), 1);
  764      for (i, request) in page1.iter().chain(page2.iter()).enumerate() {

  771        };
  772:       assert_eq!(request, &expected_request);
  773      }

crates/services/src/db/sqlite_pool.rs:
  23        DbError::SqlxError(SqlxError { source }) => {
  24:         assert_eq!(
  25:           source.to_string(),
  26:           "error returned from database: (code: 14) unable to open database file"
  27:         );
  28        }

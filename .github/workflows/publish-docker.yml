name: Publish Docker Image (Multi-Variant)

on:
  push:
    tags:
      - 'docker/v*'
      - 'docker-dev/v*'

# Prevent concurrent releases
concurrency:
  group: docker-release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  packages: write
  id-token: write

env:
  CI: true
  REGISTRY: ghcr.io
  IMAGE_NAME_RAW: ${{ github.repository }}

jobs:
  # Extract version information (shared by all builds)
  extract-version:
    runs-on: ubuntu-latest
    outputs:
      tag_version: ${{ steps.version.outputs.tag_version }}
      release_version: ${{ steps.version.outputs.release_version }}
      build_variant: ${{ steps.version.outputs.build_variant }}
      image_suffix: ${{ steps.version.outputs.image_suffix }}
      is_development: ${{ steps.version.outputs.is_development }}
      image_name: ${{ steps.version.outputs.image_name }}
      app_version: ${{ steps.version.outputs.app_version }}
      commit_sha: ${{ steps.version.outputs.commit_sha }}
    steps:
      - name: Extract version information
        id: version
        run: |
          # Convert repository name to lowercase for Docker registry
          IMAGE_NAME=$(echo "${{ env.IMAGE_NAME_RAW }}" | tr '[:upper:]' '[:lower:]')
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          # Extract the version and variant from the tag
          if [[ $GITHUB_REF == refs/tags/docker/v* ]]; then
            TAG_VERSION=${GITHUB_REF#refs/tags/docker/v}  # Extracts just "1.2.3"
            APP_VERSION=${GITHUB_REF#refs/tags/}          # Extracts "docker/v1.2.3"
            BUILD_VARIANT="production"
            IMAGE_SUFFIX=""
            IS_DEVELOPMENT="false"
          elif [[ $GITHUB_REF == refs/tags/docker-dev/v* ]]; then
            TAG_VERSION=${GITHUB_REF#refs/tags/docker-dev/v}  # Extracts just "1.2.3"
            APP_VERSION=${GITHUB_REF#refs/tags/}               # Extracts "docker-dev/v1.2.3"
            BUILD_VARIANT="development"
            IMAGE_SUFFIX="-development"
            IS_DEVELOPMENT="true"
          else
            echo "Error: Unsupported tag format: $GITHUB_REF"
            exit 1
          fi
          echo "tag_version=$TAG_VERSION" >> $GITHUB_OUTPUT
          echo "release_version=$TAG_VERSION" >> $GITHUB_OUTPUT
          echo "build_variant=$BUILD_VARIANT" >> $GITHUB_OUTPUT
          echo "image_suffix=$IMAGE_SUFFIX" >> $GITHUB_OUTPUT
          echo "is_development=$IS_DEVELOPMENT" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT

  # Build all variants using matrix strategy
  build-variants:
    needs: extract-version
    runs-on: ubuntu-latest-4-cores
    timeout-minutes: 90
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        variant:
          - cpu
          - cuda
          - rocm
          - cann
          - intel
          - musa
          # - vulkan
        include:
          - variant: cpu
            platforms: 'linux/amd64,linux/arm64'
            description: 'Multi-platform: AMD64 + ARM64'
            docker_flags: '-p 8080:8080'
            hardware_req: 'x86_64 (AMD64) or ARM64 processors (auto-detected)'
            special_note: '⭐ **Multi-platform support**: This image automatically selects the correct architecture (AMD64 or ARM64) for your platform.'
          - variant: cuda
            platforms: 'linux/amd64'
            description: 'NVIDIA GPU acceleration'
            docker_flags: '--gpus all -p 8080:8080'
            hardware_req: 'NVIDIA GPU with CUDA 12.4+ support (AMD64 only)'
            special_note: ''
          - variant: rocm
            platforms: 'linux/amd64'
            description: 'AMD GPU acceleration'
            docker_flags: '--device=/dev/kfd --device=/dev/dri --group-add video -p 8080:8080'
            hardware_req: 'AMD GPU with ROCm 6.4+ support (AMD64 only)'
            special_note: ''
          - variant: cann
            platforms: 'linux/amd64,linux/arm64'
            description: 'Huawei Ascend NPU acceleration'
            docker_flags: '--device=/dev/davinci0 --device=/dev/davinci_manager --device=/dev/devmm_svm --device=/dev/hisi_hdc -p 8080:8080'
            hardware_req: 'Huawei Ascend NPU with CANN 8.1+ support (AMD64 + ARM64)'
            special_note: '⭐ **Multi-platform support**: This image automatically selects the correct architecture (AMD64 or ARM64) for your platform.'
          - variant: intel
            platforms: 'linux/amd64'
            description: 'Intel GPU acceleration (SYCL)'
            docker_flags: '--device=/dev/dri -p 8080:8080'
            hardware_req: 'Intel GPU with OneAPI 2025.2.2+ support (AMD64 only)'
            special_note: ''
          - variant: musa
            platforms: 'linux/amd64'
            description: 'Moore Threads GPU acceleration'
            docker_flags: '--device=/dev/musa -p 8080:8080'
            hardware_req: 'Moore Threads GPU with MUSA rc4.3.0+ support (AMD64 only)'
            special_note: ''
          # - variant: vulkan
          #   platforms: 'linux/amd64'
          #   description: 'Cross-vendor GPU acceleration'
          #   docker_flags: '--device=/dev/dri -p 8080:8080'
          #   hardware_req: 'GPU with Vulkan API support (AMD64 only)'
          #   special_note: ''
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Initialize submodules
        run: |
          git config --global url.https://gh_pat:${{ secrets.GH_PAT }}@github.com/.insteadOf git@github.com:
          git submodule sync --recursive
          git submodule update --init --recursive --depth=1
          git config --global --unset url.https://gh_pat:${{ secrets.GH_PAT }}@github.com/.insteadOf

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ${{ matrix.variant }} image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./devops/${{ matrix.variant }}.Dockerfile
          platforms: ${{ matrix.platforms }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ needs.extract-version.outputs.image_name }}:${{ needs.extract-version.outputs.tag_version }}-${{ matrix.variant }}${{ needs.extract-version.outputs.image_suffix }}
            ${{ env.REGISTRY }}/${{ needs.extract-version.outputs.image_name }}:latest-${{ matrix.variant }}${{ needs.extract-version.outputs.image_suffix }}
          cache-from: |
            type=gha,scope=${{ matrix.variant }}-${{ needs.extract-version.outputs.build_variant }}
            type=gha,scope=${{ matrix.variant }}-deps
          cache-to: |
            type=gha,mode=max,scope=${{ matrix.variant }}-${{ needs.extract-version.outputs.build_variant }}
            type=gha,mode=max,scope=${{ matrix.variant }}-deps
          build-args: |
            BUILD_VARIANT=${{ needs.extract-version.outputs.build_variant }}
            BODHI_VERSION=${{ needs.extract-version.outputs.app_version }}
            BODHI_COMMIT_SHA=${{ needs.extract-version.outputs.commit_sha }}
            CI_DOCKER=true

      - name: Create build info artifact
        if: always()
        env:
          BUILD_STATUS: ${{ steps.build.outcome }}
          BUILD_DIGEST: ${{ steps.build.outputs.digest }}
          VARIANT: ${{ matrix.variant }}
          PLATFORMS: ${{ matrix.platforms }}
          DESCRIPTION: ${{ matrix.description }}
          DOCKER_FLAGS: ${{ matrix.docker_flags }}
          HARDWARE_REQ: ${{ matrix.hardware_req }}
          SPECIAL_NOTE: ${{ matrix.special_note }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ needs.extract-version.outputs.image_name }}
          TAG_VERSION: ${{ needs.extract-version.outputs.tag_version }}
          IMAGE_SUFFIX: ${{ needs.extract-version.outputs.image_suffix }}
          BUILD_VARIANT: ${{ needs.extract-version.outputs.build_variant }}
          APP_VERSION: ${{ needs.extract-version.outputs.app_version }}
          COMMIT_SHA: ${{ needs.extract-version.outputs.commit_sha }}
        run: |
          # Create base info
          jq -n \
            --arg variant "$VARIANT" \
            --arg status "$BUILD_STATUS" \
            --arg platforms "$PLATFORMS" \
            --arg dockerfile "./devops/$VARIANT.Dockerfile" \
            --arg description "$DESCRIPTION" \
            --arg docker_flags "$DOCKER_FLAGS" \
            --arg hardware_req "$HARDWARE_REQ" \
            --arg special_note "$SPECIAL_NOTE" \
            '{
              variant: $variant,
              status: $status,
              platforms: ($platforms | split(",")),
              dockerfile: $dockerfile,
              description: $description,
              docker_flags: $docker_flags,
              hardware_req: $hardware_req,
              special_note: $special_note
            }' > build-info-$VARIANT.json

          # Add success-specific info if build succeeded
          if [ "$BUILD_STATUS" = "success" ]; then
            jq \
              --arg registry "$REGISTRY" \
              --arg image_name "$IMAGE_NAME" \
              --arg tag_version "$TAG_VERSION" \
              --arg image_suffix "$IMAGE_SUFFIX" \
              --arg digest "$BUILD_DIGEST" \
              --arg build_variant "$BUILD_VARIANT" \
              --arg app_version "$APP_VERSION" \
              --arg commit_sha "$COMMIT_SHA" \
              '. + {
                tags: [
                  "\($registry)/\($image_name):\($tag_version)-\(.variant)\($image_suffix)",
                  "\($registry)/\($image_name):latest-\(.variant)\($image_suffix)"
                ],
                digest: $digest,
                build_args: {
                  BUILD_VARIANT: $build_variant,
                  BODHI_VERSION: $app_version,
                  BODHI_COMMIT_SHA: $commit_sha,
                  CI_DOCKER: "true"
                }
              }' build-info-$VARIANT.json > tmp.json
            mv tmp.json build-info-$VARIANT.json
          fi

          echo "Build info for $VARIANT:"
          cat build-info-$VARIANT.json | jq .

      - name: Upload build info artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ matrix.variant }}
          path: build-info-${{ matrix.variant }}.json
          retention-days: 7


  # Create release (CPU image is now built as multi-platform directly)
  # No separate manifest creation needed as build-variants creates multi-platform images

  # Collect all build information into release.json artifact
  collect-release-info:
    needs: [extract-version, build-variants]
    if: always() && !cancelled()
    runs-on: ubuntu-latest
    steps:
      - name: Download all build info artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-info-*
          path: build-artifacts
          merge-multiple: false

      - name: Combine build info into release.json
        env:
          REGISTRY: ${{ env.REGISTRY }}
        run: |
          # Create the base structure
          jq -n \
            --arg version "${{ needs.extract-version.outputs.tag_version }}" \
            --arg tag "${{ github.ref_name }}" \
            --arg registry "$REGISTRY" \
            --arg image_name "${{ needs.extract-version.outputs.image_name }}" \
            --arg build_variant "${{ needs.extract-version.outputs.build_variant }}" \
            --arg commit_sha "${{ needs.extract-version.outputs.commit_sha }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{
              version: $version,
              tag: $tag,
              registry: $registry,
              image_name: $image_name,
              build_variant: $build_variant,
              commit_sha: $commit_sha,
              timestamp: $timestamp,
              variants: []
            }' > release.json

          # Find all build-info JSON files
          VARIANTS=$(find build-artifacts -name 'build-info-*.json' -type f | sort)

          # Build the variants array
          VARIANTS_JSON="[]"
          for info_file in $VARIANTS; do
            if [ -f "$info_file" ]; then
              echo "Processing: $info_file"
              VARIANT_DATA=$(cat "$info_file")
              VARIANTS_JSON=$(echo "$VARIANTS_JSON" | jq --argjson variant "$VARIANT_DATA" '. + [$variant]')
            fi
          done

          # Update release.json with variants
          jq --argjson variants "$VARIANTS_JSON" '.variants = $variants' release.json > release.tmp.json
          mv release.tmp.json release.json

          # Pretty print the result
          echo "Generated release.json:"
          cat release.json | jq .

      - name: Upload release info artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-info
          path: release.json
          retention-days: 90

  # Create GitHub Release if at least one variant succeeds
  create-release:
    needs: [extract-version, build-variants, collect-release-info]
    if: always() && !cancelled()
    runs-on: ubuntu-latest
    steps:
      - name: Download release info artifact
        uses: actions/download-artifact@v4
        with:
          name: release-info
          path: release-artifacts

      - name: Generate dynamic release body
        env:
          REGISTRY: ${{ env.REGISTRY }}
        run: |
          # Read release.json
          RELEASE_JSON="release-artifacts/release.json"

          # Extract basic info
          VERSION=$(jq -r '.version' "$RELEASE_JSON")
          BUILD_VARIANT=$(jq -r '.build_variant' "$RELEASE_JSON")
          IMAGE_NAME=$(jq -r '.image_name' "$RELEASE_JSON")
          REGISTRY=$(jq -r '.registry' "$RELEASE_JSON")
          AUTH_SERVER="${{ needs.extract-version.outputs.build_variant == 'production' && 'https://id.getbodhi.app' || 'https://main-id.getbodhi.app' }}"

          # Start building the release body
          cat > release_body.md <<EOF
          # BodhiApp Docker Images Release ${VERSION} (${BUILD_VARIANT})

          ## Available Variants

          EOF

          # Get successful variants
          SUCCESS_VARIANTS=$(jq -r '.variants[] | select(.status == "success") | @json' "$RELEASE_JSON")

          if [ -z "$SUCCESS_VARIANTS" ]; then
            echo "⚠️ No variants were successfully built in this release." >> release_body.md
          else
            # Generate section for each successful variant
            echo "$SUCCESS_VARIANTS" | while IFS= read -r variant_json; do
              VARIANT=$(echo "$variant_json" | jq -r '.variant')
              DESCRIPTION=$(echo "$variant_json" | jq -r '.description')
              DOCKER_FLAGS=$(echo "$variant_json" | jq -r '.docker_flags')
              SPECIAL_NOTE=$(echo "$variant_json" | jq -r '.special_note')
              VARIANT_TAG=$(echo "$variant_json" | jq -r '.tags[0]')

              # Capitalize first letter for title
              VARIANT_UPPER=$(echo "$VARIANT" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')

              cat >> release_body.md <<VARIANT_EOF
          ### ${VARIANT_UPPER} Variant (${DESCRIPTION})
          \`\`\`bash
          docker pull ${VARIANT_TAG}
          docker run ${DOCKER_FLAGS} \\
            -v ./bodhi_home:/data/bodhi_home \\
            -v ./hf_home:/data/hf_home \\
            ${VARIANT_TAG}
          \`\`\`

          VARIANT_EOF

              # Add special note if present
              if [ -n "$SPECIAL_NOTE" ] && [ "$SPECIAL_NOTE" != "null" ] && [ "$SPECIAL_NOTE" != "" ]; then
                echo "$SPECIAL_NOTE" >> release_body.md
                echo "" >> release_body.md
              fi
            done
          fi

          # Add Image Details section
          cat >> release_body.md <<EOF

          ## Image Details
          - **Build Variant**: ${BUILD_VARIANT}
          - **Registry**: ${REGISTRY}/${IMAGE_NAME}
          - **Version**: ${VERSION}
          - **Auth Server**: ${AUTH_SERVER}

          ## Platform Support
          EOF

          # List platforms for each successful variant
          echo "$SUCCESS_VARIANTS" | while IFS= read -r variant_json; do
            VARIANT=$(echo "$variant_json" | jq -r '.variant')
            PLATFORMS=$(echo "$variant_json" | jq -r '.platforms | join(", ")')
            echo "- **${VARIANT}**: ${PLATFORMS}" >> release_body.md
          done

          # Add Hardware Requirements section
          cat >> release_body.md <<EOF

          ## Hardware Requirements

          EOF

          echo "$SUCCESS_VARIANTS" | while IFS= read -r variant_json; do
            VARIANT=$(echo "$variant_json" | jq -r '.variant')
            VARIANT_UPPER=$(echo "$VARIANT" | awk '{print toupper($0)}')
            HW_REQ=$(echo "$variant_json" | jq -r '.hardware_req')
            echo "- **${VARIANT_UPPER}**: ${HW_REQ}" >> release_body.md
          done

          # Add Benefits section
          cat >> release_body.md <<EOF

          ## Benefits

          - **Multi-platform CPU**: Automatic architecture detection for ARM64 and AMD64
          - **Faster Builds**: No llama-server compilation during build
          - **GPU Acceleration**: Hardware-optimized variants available
          - **Smaller Images**: Optimized runtime images
          - **Better Caching**: Improved Docker layer caching
          EOF

          # List failed variants if any
          FAILED_VARIANTS=$(jq -r '.variants[] | select(.status != "success") | .variant' "$RELEASE_JSON")
          if [ -n "$FAILED_VARIANTS" ]; then
            cat >> release_body.md <<EOF

          ## Build Status

          The following variants failed to build and are not available in this release:
          EOF
            echo "$FAILED_VARIANTS" | while read -r variant; do
              echo "- ❌ ${variant}" >> release_body.md
            done
          fi

          echo "Generated release body:"
          cat release_body.md

      - name: Check if at least one variant was published
        id: check
        run: |
          VARIANTS=("cpu" "cuda" "rocm" "cann" "intel" "musa")
          SUCCESS=false

          for variant in "${VARIANTS[@]}"; do
            TAG="${{ env.REGISTRY }}/${{ needs.extract-version.outputs.image_name }}:${{ needs.extract-version.outputs.tag_version }}-${variant}${{ needs.extract-version.outputs.image_suffix }}"
            echo "Checking if image exists: $TAG"
            if docker manifest inspect "$TAG" >/dev/null 2>&1; then
              echo "✓ Published: $TAG"
              SUCCESS=true
            else
              echo "✗ Not found: $TAG"
            fi
          done

          if [ "$SUCCESS" = "true" ]; then
            echo "At least one variant was successfully published"
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            echo "ERROR: No variants were successfully published"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Create GitHub Release
        if: steps.check.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: 'Docker Images ${{ needs.extract-version.outputs.build_variant }} ${{ needs.extract-version.outputs.tag_version }}'
          body_path: release_body.md
          draft: false
          prerelease: ${{ needs.extract-version.outputs.is_development == 'true' }}
          files: |
            release-artifacts/release.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Output image details
        run: |
          RELEASE_JSON="release-artifacts/release.json"
          IMAGE_NAME=$(jq -r '.image_name' "$RELEASE_JSON")
          REGISTRY=$(jq -r '.registry' "$RELEASE_JSON")

          # Get list of successful variants
          SUCCESSFUL_VARIANTS=$(jq -r '.variants[] | select(.status == "success") | .variant' "$RELEASE_JSON" | tr '\n' ', ' | sed 's/,$//')

          # Get first successful variant tag for example
          EXAMPLE_TAG=$(jq -r '.variants[] | select(.status == "success") | .tags[0]' "$RELEASE_JSON" | head -n 1)

          echo "::notice title=Docker Images Published::Multi-variant images published to ${REGISTRY}/${IMAGE_NAME}"
          echo "::notice title=Available Variants::${SUCCESSFUL_VARIANTS}"
          if [ -n "$EXAMPLE_TAG" ]; then
            echo "::notice title=Example Pull::docker pull ${EXAMPLE_TAG}"
          fi

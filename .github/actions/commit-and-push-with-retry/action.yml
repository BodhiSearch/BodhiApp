name: commit-and-push-with-retry
description: Commit changes and push to remote with retry logic and upstream sync

inputs:
  branch:
    description: "Branch to push to"
    required: false
    default: "main"
  commit-message:
    description: "Commit message"
    required: true
  files:
    description: "Files to add (space-separated or multiline)"
    required: true
  max-retries:
    description: "Maximum number of push retry attempts"
    required: false
    default: "3"
  fetch-depth:
    description: "Fetch depth for upstream sync (0 for full history)"
    required: false
    default: "1"
  bump-command:
    description: "Command to regenerate changes on retry (runs after rebase)"
    required: false
    default: ""

runs:
  using: composite
  steps:
    - name: Configure Git
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Checkout target branch
      shell: bash
      run: |
        # Handle detached HEAD state (common when triggered by tags)
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [[ "$CURRENT_BRANCH" == "HEAD" ]] || [[ "$CURRENT_BRANCH" != "${{ inputs.branch }}" ]]; then
          echo "Not on ${{ inputs.branch }} (current: $CURRENT_BRANCH), switching..."

          # Stash any uncommitted changes before switching
          if [[ -n $(git status --porcelain) ]]; then
            echo "Stashing uncommitted changes before branch switch"
            git stash push -m "Temporary stash for branch switch"
            NEEDS_UNSTASH=1
          else
            NEEDS_UNSTASH=0
          fi

          git fetch origin ${{ inputs.branch }}
          git checkout ${{ inputs.branch }}
          git pull origin ${{ inputs.branch }}

          # Restore stashed changes
          if [[ $NEEDS_UNSTASH -eq 1 ]]; then
            echo "Restoring stashed changes"
            git stash pop
          fi
        else
          echo "Already on branch ${{ inputs.branch }}"
        fi

    - name: Fetch and sync with upstream
      shell: bash
      run: |
        echo "Fetching latest changes from origin/${{ inputs.branch }}"
        if [[ "${{ inputs.fetch-depth }}" == "0" ]]; then
          git fetch origin ${{ inputs.branch }}
        else
          git fetch --depth=${{ inputs.fetch-depth }} origin ${{ inputs.branch }}
        fi

        # Check if there are any local uncommitted changes
        if [[ -n $(git status --porcelain) ]]; then
          echo "Note: Uncommitted changes detected - will be committed after sync"
          git status --short

          # Stash changes temporarily to allow rebase
          echo "Stashing local changes"
          git stash push -m "Temporary stash for version bump"
          STASHED=1
        else
          STASHED=0
        fi

        # Pull latest changes with rebase to handle any upstream commits
        echo "Rebasing with origin/${{ inputs.branch }}"
        git pull --rebase origin ${{ inputs.branch }} || {
          echo "Error: Failed to rebase with origin/${{ inputs.branch }}"
          echo "There may be conflicts that need manual resolution"
          exit 1
        }

        # Restore stashed changes if any
        if [[ $STASHED -eq 1 ]]; then
          echo "Restoring stashed changes"
          git stash pop || {
            echo "Error: Failed to restore stashed changes"
            echo "There may be conflicts that need manual resolution"
            exit 1
          }
        fi

    - name: Commit changes
      shell: bash
      run: |
        echo "Adding files for commit"
        # Support both space-separated and multiline file patterns
        FILES="${{ inputs.files }}"
        git add $FILES

        # Check if there are changes to commit
        if git diff --cached --quiet; then
          echo "Warning: No changes to commit"
          exit 0
        fi

        echo "Committing changes"
        git commit -m "${{ inputs.commit-message }}"

    - name: Push with retry logic
      shell: bash
      run: |
        MAX_RETRIES=${{ inputs.max-retries }}
        BUMP_CMD="${{ inputs.bump-command }}"

        for i in $(seq 1 $MAX_RETRIES); do
          echo "Push attempt $i/$MAX_RETRIES"

          if git push origin ${{ inputs.branch }}; then
            echo "Successfully pushed to origin/${{ inputs.branch }}"
            exit 0
          fi

          # If this wasn't the last attempt, try to rebase and retry
          if [[ $i -lt $MAX_RETRIES ]]; then
            echo "Push failed, rebasing and retrying..."

            # Reset the commit we just made
            git reset --hard HEAD~1

            # Sync with upstream
            if ! git pull --rebase origin ${{ inputs.branch }}; then
              echo "Error: Failed to rebase after failed push"
              echo "There may be conflicts that need manual resolution"
              exit 1
            fi

            # Re-run bump command if provided
            if [[ -n "$BUMP_CMD" ]]; then
              echo "Re-running bump command..."
              eval "$BUMP_CMD"
            fi

            # Re-add and commit
            git add ${{ inputs.files }}
            if ! git diff --cached --quiet; then
              git commit -m "${{ inputs.commit-message }}"
            else
              echo "No changes after re-bump, nothing to push"
              exit 0
            fi
          fi
        done

        echo "Error: Failed to push after $MAX_RETRIES attempts"
        exit 1

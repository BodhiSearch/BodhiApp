{"version":3,"file":"inject.js","mappings":"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","sources":["webpack://bodhi-browser/./src-ext/shared/constants.ts","webpack://bodhi-browser/./src-ext/shared/utils.ts","webpack://bodhi-browser/./src-ext/inject.ts"],"sourcesContent":["// Shared constants for Bodhi Browser Extension\n\nexport const CONTENT_TYPE_JSON = 'application/json';\nexport const CONTENT_TYPE_HEADER = 'Content-Type';\nexport const DEFAULT_API_BASE_URL = 'http://localhost:1135';\nexport const DEFAULT_REQUEST_TIMEOUT = 150000; // 2.5 minutes\nexport const BODHI_STREAM_PORT = 'BODHI_STREAM_PORT';\nexport const STORAGE_KEY_BACKEND_URL = 'backendUrl';\nexport const HTTP_METHOD_GET = 'GET';\nexport const HTTP_METHOD_POST = 'POST';\nexport const ENDPOINT_PING = '/ping';\nexport const ENDPOINT_CHAT_COMPLETIONS = '/v1/chat/completions';\nexport const SSE_DONE_MARKER = '[DONE]';\nexport const SSE_DATA_PREFIX = 'data: ';\nexport const SSE_CHUNK_DELIMITER = '\\n\\n';\n\n// Document states\nexport const DOCUMENT_STATE_COMPLETE = 'complete';\n\n// Event names\nexport const EVENT_INITIALIZED = 'bodhiext:initialized';\n\n// Origin fallback\nexport const ORIGIN_WILDCARD = '*';\n\n// Error messages\nexport const ERROR_MISSING_REQUEST_ID = 'Invalid message format: missing requestId or request';\nexport const ERROR_CONNECTION_CLOSED = 'Connection closed unexpectedly';\n\nexport const MESSAGE_TYPES = {\n  API_REQUEST: 'BODHI_API_REQUEST',\n  API_RESPONSE: 'BODHI_API_RESPONSE',\n  STREAM_REQUEST: 'BODHI_STREAM_REQUEST',\n  STREAM_CHUNK: 'BODHI_STREAM_CHUNK',\n  STREAM_ERROR: 'BODHI_STREAM_ERROR',\n  ERROR: 'BODHI_ERROR',\n  GET_EXTENSION_ID: 'BODHI_GET_EXTENSION_ID',\n  SET_EXTENSION_ID: 'BODHI_SET_EXTENSION_ID',\n  TEST_CONNECTION: 'BODHI_TEST_CONNECTION',\n  TEST_CONNECTION_RESPONSE: 'BODHI_TEST_CONNECTION_RESPONSE',\n};\n","/* global RequestInit */\n/// <reference lib=\"dom\" />\n/// Shared utility functions for Bodhi Browser Extension\nimport {\n  MESSAGE_TYPES,\n  CONTENT_TYPE_HEADER,\n  CONTENT_TYPE_JSON,\n  HTTP_METHOD_GET,\n  SSE_DONE_MARKER,\n  SSE_DATA_PREFIX,\n  DEFAULT_REQUEST_TIMEOUT,\n} from './constants.js';\nimport { ApiResponse, ApiResponseMessage, SSEChunk } from './types.js';\n\n// Status code ranges\nconst HTTP_STATUS_OK_MIN = 200;\nconst HTTP_STATUS_OK_MAX = 299;\n\n// Create a shared logger instance\nconst isProd = process.env.NODE_ENV === 'production';\n\nfunction parseLoggerArgs(args: any): any[] {\n  if (typeof args === 'function') {\n    const result = args();\n    if (Array.isArray(result)) {\n      return result;\n    } else if (typeof result === 'object') {\n      return [JSON.stringify(result)];\n    } else {\n      return [result];\n    }\n  } else if (Array.isArray(args)) {\n    return args;\n  } else if (args && typeof args === 'object') {\n    return [JSON.stringify(args)];\n  } else if (args !== undefined) {\n    return [args];\n  }\n  return [];\n}\n\nexport const createLogger = (tag: string) => ({\n  /**\n   * Enhanced info logger for dev/prod optimization.\n   * Usage:\n   *   logger.info('msg', [val1, val2])\n   *   logger.info('msg', () => [val1, val2])\n   *   logger.info('msg', () => ({foo: bar}))\n   *   logger.info('msg', {foo: bar})\n   */\n  info: (message: string, args?: any): void => {\n    if (isProd) return;\n    const values = parseLoggerArgs(args);\n    console.info(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n  /**\n   * Enhanced error logger for dev/prod optimization.\n   * Usage:\n   *   logger.error('msg', [val1, val2])\n   *   logger.error('msg', () => [val1, val2])\n   *   logger.error('msg', () => ({foo: bar}))\n   *   logger.error('msg', {foo: bar})\n   *   logger.error('msg', error)\n   */\n  error: (message: string, args?: any): void => {\n    const values = parseLoggerArgs(args);\n    console.error(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n});\n\nconst logger = createLogger('shared');\n\n/**\n * Centralized error handler to standardize error management across all components\n */\nexport const handleError = (\n  error: Error | string,\n  tag: string = 'unknown',\n  context: Record<string, any> = {}\n): Error => {\n  const errorMessage = typeof error === 'string' ? error : error.message;\n  const errorObj = typeof error === 'string' ? new Error(error) : error;\n\n  // Add context to the error object for debugging\n  Object.assign(errorObj, { context, location: tag });\n\n  // Log the error with contextual information\n  logger.error('Error', { tag, errorMessage, context, stack: errorObj.stack, error: errorObj });\n  return errorObj;\n};\n\n/**\n * Creates an error object with additional properties\n */\nexport const createErrorWithDetails = (message: string, status: number, body: any): Error => {\n  const error: any = new Error(message);\n  error.status = status;\n  error.body = body;\n  return error;\n};\n\n/**\n * Extracts error message from response body if available\n */\nexport const getErrorMessageFromResponse = (\n  response: ApiResponse | undefined,\n  defaultMessage: string\n): string => {\n  if (response?.body?.error?.message) {\n    return response.body.error.message;\n  }\n  return defaultMessage;\n};\n\n/**\n * Checks if a response status indicates success\n */\nexport const isSuccessResponse = (status: number): boolean => {\n  return status >= HTTP_STATUS_OK_MIN && status < HTTP_STATUS_OK_MAX;\n};\n\nexport const createRequestOptions = (\n  method: string,\n  headers: Record<string, string> = {},\n  body: any = null\n): RequestInit => {\n  const options: RequestInit = {\n    method,\n    headers: {\n      [CONTENT_TYPE_HEADER]: CONTENT_TYPE_JSON,\n      ...headers,\n    },\n  };\n  if (method !== HTTP_METHOD_GET && body) {\n    options.body = JSON.stringify(body);\n  }\n  return options;\n};\n\nexport const createErrorResponse = (\n  message: string,\n  requestId: string,\n  isStream: boolean = false\n): ApiResponseMessage => {\n  return {\n    type: isStream ? MESSAGE_TYPES.STREAM_ERROR : MESSAGE_TYPES.API_RESPONSE,\n    requestId,\n    response: {\n      body: {\n        error: {\n          message,\n        },\n      },\n      status: 0,\n      headers: {},\n    },\n  };\n};\n\nexport const parseResponse = async (response: Response): Promise<ApiResponse> => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER) || '';\n  const isJson = contentType.includes(CONTENT_TYPE_JSON);\n  const body = isJson ? await response.json() : await response.text();\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return {\n    body,\n    status: response.status,\n    headers,\n  };\n};\n\nexport const handleFetchError = (\n  error: Error,\n  responseHandler: (response: ApiResponseMessage) => void,\n  requestId: string,\n  isStream: boolean = false\n): void => {\n  logger.error('Error fetching from API', { error });\n  responseHandler(createErrorResponse(error.message, requestId, isStream));\n};\n\nexport const processSSEChunk = (chunk: string): SSEChunk | null => {\n  if (!chunk || chunk.trim() === '') return null;\n\n  // Check for the done marker\n  if (chunk.includes(SSE_DONE_MARKER)) {\n    return { done: true };\n  }\n\n  try {\n    // Check if the chunk starts with the expected data prefix\n    if (!chunk.startsWith(SSE_DATA_PREFIX)) {\n      // If it's a keep-alive comment or other non-data line, ignore it\n      if (chunk.startsWith(':')) {\n        logger.info('Received SSE keep-alive comment');\n        return null;\n      }\n      // Handle malformed chunks\n      logger.info(`Received malformed SSE chunk: ${chunk}`);\n      return null;\n    }\n\n    // Remove \"data: \" prefix from the chunk and parse JSON\n    const jsonStr = chunk.replace(new RegExp(`^${SSE_DATA_PREFIX}`), '');\n    const parsedData = JSON.parse(jsonStr);\n\n    // Validate the parsed data has the expected structure\n    if (parsedData && typeof parsedData === 'object') {\n      return parsedData as SSEChunk;\n    } else {\n      logger.error('Received unexpected SSE data structure', { jsonStr });\n      // Return a typed object instead of raw string\n      return { data: jsonStr };\n    }\n  } catch (error) {\n    const err = error as Error;\n    logger.error('Error processing SSE chunk', { chunk, error: err.message });\n    // Return a typed object instead of raw string\n    return { data: chunk, error: err.message };\n  }\n};\n\n/**\n * Makes an HTTP request with standardized error handling.\n * Can be used in both background and inject scripts.\n */\nexport const makeHttpRequest = async (\n  url: string,\n  options: RequestInit,\n  timeout: number = DEFAULT_REQUEST_TIMEOUT\n): Promise<Response> => {\n  try {\n    // Create an AbortController for timeout handling\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n\n    // Add the signal to the options\n    const requestOptions = {\n      ...options,\n      signal: controller.signal,\n    };\n\n    // Make the request\n    const response = await fetch(url, requestOptions);\n    clearTimeout(id);\n\n    return response;\n  } catch (error) {\n    if ((error as any)?.name === 'AbortError') {\n      throw new Error(`Request timeout after ${timeout}ms: ${url}`);\n    }\n    throw error;\n  }\n};\n","/**\n * Bodhi Browser Plugin inject script\n * Creates the interface that is exposed to web pages\n */\n\n'use strict';\n\n// Use IIFE to avoid polluting global namespace\n/* global EventListener */\n/// <reference lib=\"dom\" />\nimport {\n  DEFAULT_API_BASE_URL,\n  DEFAULT_REQUEST_TIMEOUT,\n  MESSAGE_TYPES,\n  ORIGIN_WILDCARD,\n  EVENT_INITIALIZED,\n  HTTP_METHOD_GET,\n  HTTP_METHOD_POST,\n  ENDPOINT_PING,\n  ENDPOINT_CHAT_COMPLETIONS,\n} from './shared/constants.js';\n\nimport {\n  ApiResponse,\n  ApiRequestMessage,\n  GetExtensionIdMessage,\n  ServerStateInfo,\n} from './shared/types.js';\n\nimport {\n  createErrorWithDetails,\n  getErrorMessageFromResponse,\n  isSuccessResponse,\n  createLogger,\n} from './shared/utils.js';\n\n(function () {\n  //-----------------------------------------------------------------------------------\n  // CONSTANTS AND CONFIGURATION\n  //-----------------------------------------------------------------------------------\n\n  // Stream timeout is longer than regular request timeout\n  const DEFAULT_STREAM_TIMEOUT = 120000; // 120 seconds\n\n  // Error messages\n  const ERROR_REQUEST_TIMEOUT = 'Request timed out';\n  const ERROR_STREAM_ERROR = 'Stream error';\n  const ERROR_UNKNOWN_ERROR = 'Unknown error';\n\n  // Type definitions\n  interface StreamController {\n    enqueue: (chunk: any) => void;\n    error: (err: Error) => void;\n    complete: () => void;\n  }\n\n  interface RequestCallbacks {\n    resolve: (value: any) => void;\n    reject: (reason?: any) => void;\n  }\n\n  interface BodhiExtInterface {\n    _private: {\n      requests: Map<string, RequestCallbacks>;\n      streams: Map<string, StreamController>;\n      baseUrl: string;\n      generateId: () => string;\n      handleApiResponse: (event: MessageEvent) => void;\n      sendApiRequest: (\n        method: string,\n        endpoint: string,\n        body?: any,\n        headers?: Record<string, string>\n      ) => Promise<{ body: any; headers: Record<string, string>; status: number }>;\n      sendStreamRequest: (\n        method: string,\n        endpoint: string,\n        body?: any,\n        headers?: Record<string, string>\n      ) => ReadableStream;\n      requestExtensionId: () => void;\n      _getExtensionId: () => Promise<string>;\n    };\n    extension_id: string | null;\n    ping: () => Promise<any>;\n    serverState: () => Promise<ServerStateInfo>;\n    chat: {\n      completions: {\n        create: (params: any) => Promise<any> | AsyncIterable<any>;\n      };\n    };\n  }\n\n  // Logger for consistent message formatting\n  const logger = createLogger('inject.js');\n\n  logger.info('Interface initializing');\n\n  //-----------------------------------------------------------------------------------\n  // INTERFACE IMPLEMENTATION\n  //-----------------------------------------------------------------------------------\n\n  /**\n   * Creates the bodhiext interface and attaches it to the window object\n   */\n  const createInterface = (): void => {\n    // Check if the interface already exists\n    if (typeof (window as any).bodhiext !== 'undefined') {\n      logger.info('Interface already exists, skipping initialization');\n      return;\n    }\n\n    // Create the interface object with better encapsulation\n    const bodhiextInterface: BodhiExtInterface = {\n      // Private properties - not directly accessible\n      _private: {\n        // Keep track of pending requests\n        requests: new Map<string, RequestCallbacks>(),\n\n        // Keep track of active streams\n        streams: new Map<string, StreamController>(),\n\n        // Base URL for creating path references\n        baseUrl: DEFAULT_API_BASE_URL,\n\n        // Generate a random ID for each request - more secure with crypto\n        generateId: (): string => {\n          try {\n            // Use crypto for secure random values if available\n            if (window.crypto && window.crypto.randomUUID) {\n              return window.crypto.randomUUID();\n            }\n\n            // Fallback to less secure but still functional method\n            return (\n              Math.random().toString(36).substring(2, 15) +\n              Math.random().toString(36).substring(2, 15)\n            );\n          } catch (error) {\n            logger.error('Error generating request ID', { error });\n            // Last resort fallback\n            return `req_${Date.now()}_${Math.floor(Math.random() * 1000)}`;\n          }\n        },\n\n        /**\n         * Handles API response messages\n         */\n        handleApiResponse: (event: MessageEvent): void => {\n          if (!event.data || !event.data.type) {\n            logger.info('Ignoring API response with no type', { data: event.data });\n            return;\n          }\n\n          try {\n            const { type, requestId, response } = event.data;\n\n            // Use switch statement based on message type\n            switch (type) {\n              case MESSAGE_TYPES.API_RESPONSE:\n                handleRegularResponse(requestId, response);\n                break;\n\n              case MESSAGE_TYPES.STREAM_CHUNK:\n                handleStreamChunk(requestId, response);\n                break;\n\n              case MESSAGE_TYPES.STREAM_ERROR:\n                handleStreamError(requestId, response);\n                break;\n\n              case MESSAGE_TYPES.ERROR:\n                handleGenericError(requestId, response);\n                break;\n\n              case MESSAGE_TYPES.SET_EXTENSION_ID:\n                handleSetExtensionId(event.data.extension_id);\n                break;\n            }\n          } catch (error) {\n            logger.error('Error handling API response', { error });\n          }\n        },\n\n        // Generic request method\n        sendApiRequest: function (\n          method: string,\n          endpoint: string,\n          body: any = null,\n          headers: Record<string, string> = {}\n        ): Promise<{ body: any; headers: Record<string, string>; status: number }> {\n          return new Promise((resolve, reject) => {\n            try {\n              const requestId = this.generateId();\n\n              // Store both resolve and reject functions for when we get a response\n              this.requests.set(requestId, { resolve, reject });\n\n              // Send the API request message to the content script\n              window.postMessage(\n                {\n                  type: MESSAGE_TYPES.API_REQUEST,\n                  requestId,\n                  request: {\n                    method,\n                    endpoint,\n                    body,\n                    headers,\n                  },\n                } as ApiRequestMessage,\n                window.origin || ORIGIN_WILDCARD\n              );\n\n              // Set a timeout to clean up if no response is received\n              setTimeout(() => {\n                if (this.requests.has(requestId)) {\n                  this.requests.delete(requestId);\n                  reject(new Error(`${ERROR_REQUEST_TIMEOUT}: ${endpoint}`));\n                }\n              }, DEFAULT_REQUEST_TIMEOUT);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        },\n\n        // Streaming request method\n        sendStreamRequest: function (\n          method: string,\n          endpoint: string,\n          body: any = null,\n          headers: Record<string, string> = {}\n        ): ReadableStream {\n          // Create an ID for this streaming request\n          const requestId = this.generateId();\n\n          // Create an async iterator using ReadableStream\n          const stream = new ReadableStream({\n            start: (controller: ReadableStreamDefaultController) => {\n              // Store the controller for this stream\n              this.streams.set(requestId, {\n                enqueue: (chunk: any) => controller.enqueue(chunk),\n                error: (err: Error) => controller.error(err),\n                complete: () => controller.close(),\n              });\n\n              // Send the stream request\n              window.postMessage(\n                {\n                  type: MESSAGE_TYPES.STREAM_REQUEST,\n                  requestId,\n                  request: {\n                    method,\n                    endpoint,\n                    body,\n                    headers,\n                  },\n                } as ApiRequestMessage,\n                window.origin || ORIGIN_WILDCARD\n              );\n\n              // Set a timeout to clean up if no response is received\n              setTimeout(() => {\n                if (this.streams.has(requestId)) {\n                  const streamController = this.streams.get(requestId)!;\n                  streamController.error(new Error(`${ERROR_REQUEST_TIMEOUT}: ${endpoint}`));\n                  this.streams.delete(requestId);\n                }\n              }, DEFAULT_STREAM_TIMEOUT);\n            },\n            cancel: (reason: any) => {\n              // Clean up if the consumer cancels the stream\n              if (this.streams.has(requestId)) {\n                this.streams.delete(requestId);\n                logger.info('Stream was cancelled', { requestId, reason });\n              }\n            },\n          });\n\n          // Return a reader that will yield chunks as they arrive\n          return stream;\n        },\n\n        // Request the extension ID from content script\n        requestExtensionId: function (): void {\n          window.postMessage(\n            {\n              type: MESSAGE_TYPES.GET_EXTENSION_ID,\n            } as GetExtensionIdMessage,\n            window.origin || ORIGIN_WILDCARD\n          );\n        },\n\n        // Internal method to get extension ID\n        _getExtensionId: function (): Promise<string> {\n          // If we already have the extension_id, return it\n          if (bodhiextInterface.extension_id) {\n            return Promise.resolve(bodhiextInterface.extension_id);\n          }\n\n          // Otherwise, request it and wait for it to be set\n          return new Promise(resolve => {\n            // Listen for the event that's dispatched when extension_id is set\n            const onInitialized = (event: CustomEvent) => {\n              window.removeEventListener(EVENT_INITIALIZED, onInitialized as EventListener);\n              resolve(event.detail.extensionId);\n            };\n\n            window.addEventListener(EVENT_INITIALIZED, onInitialized as EventListener);\n\n            // Request the extension ID\n            this.requestExtensionId();\n          });\n        },\n      },\n\n      // Extension ID property will be set when content script provides it\n      extension_id: null,\n\n      // Public API methods\n      // Ping implemented using the generic request mechanism\n      ping: function (): Promise<any> {\n        return this._private\n          .sendApiRequest(HTTP_METHOD_GET, ENDPOINT_PING)\n          .then(response => response.body);\n      },\n\n      // Server state method to get server status information\n      serverState: function (): Promise<ServerStateInfo> {\n        return this._private\n          .sendApiRequest(HTTP_METHOD_GET, '/bodhi/v1/info')\n          .then(response => {\n            // Handle network errors (status 0 means network failure)\n            if (response.status === 0) {\n              return {\n                status: 'unreachable' as const,\n                url: this._private.baseUrl,\n                error: {\n                  message: response.body?.error?.message || 'Failed to connect to server',\n                  type: 'network_error',\n                },\n              };\n            }\n\n            // Handle successful response (status 200)\n            if (response.status === 200 && response.body) {\n              return {\n                status: response.body.status,\n                version: response.body.version,\n                url: this._private.baseUrl,\n              };\n            }\n\n            // Handle server error response (status 500 or other error codes)\n            if (response.status >= 400) {\n              return {\n                status: 'error' as const,\n                url: this._private.baseUrl,\n                error: response.body?.error || {\n                  message: `Server returned status ${response.status}`,\n                  type: 'server_error',\n                },\n              };\n            }\n\n            // Handle unexpected response format\n            return {\n              status: 'error' as const,\n              url: this._private.baseUrl,\n              error: {\n                message: 'Unexpected response format from server',\n                type: 'response_error',\n              },\n            };\n          })\n          .catch(error => {\n            // Handle any other errors that might occur\n            return {\n              status: 'unreachable' as const,\n              url: this._private.baseUrl,\n              error: {\n                message: error.message || 'Failed to connect to server',\n                type: 'network_error',\n              },\n            };\n          });\n      },\n\n      // Chat API\n      chat: {\n        completions: {\n          // Create a chat completion\n          create: function (params: any): Promise<any> | AsyncIterable<any> {\n            // Check if this is a streaming request\n            if (params && params.stream === true) {\n              // Get a reference to the private streaming request method\n              const streamRequestMethod = bodhiextInterface._private.sendStreamRequest.bind(\n                bodhiextInterface._private\n              );\n\n              // Make the streaming request\n              const readableStream = streamRequestMethod(\n                HTTP_METHOD_POST,\n                ENDPOINT_CHAT_COMPLETIONS,\n                params\n              );\n\n              // Create an async iterator wrapper compatible with OpenAI SDK pattern\n              return {\n                [Symbol.asyncIterator]: async function* () {\n                  const reader = readableStream.getReader();\n                  try {\n                    while (true) {\n                      const { done, value } = await reader.read();\n                      if (done) {\n                        break;\n                      }\n                      yield value.body;\n                    }\n                  } finally {\n                    reader.releaseLock();\n                  }\n                },\n              };\n            }\n\n            // Non-streaming request - use the regular API\n            return bodhiextInterface._private\n              .sendApiRequest(HTTP_METHOD_POST, ENDPOINT_CHAT_COMPLETIONS, params)\n              .then(response => response.body);\n          },\n        },\n      },\n    };\n\n    //-----------------------------------------------------------------------------------\n    // RESPONSE HANDLERS\n    //-----------------------------------------------------------------------------------\n\n    /**\n     * Handle regular API responses\n     */\n    const handleRegularResponse = (requestId: string, response: ApiResponse): void => {\n      if (!requestId || !bodhiextInterface._private.requests.has(requestId)) {\n        logger.info('No matching request found for API response', { requestId });\n        return;\n      }\n      // Get the resolve function\n      const { resolve } = bodhiextInterface._private.requests.get(requestId)!;\n      // Always resolve with the response object, regardless of HTTP status code\n      // This allows the client to handle HTTP errors appropriately by checking the status\n      resolve(response);\n\n      bodhiextInterface._private.requests.delete(requestId);\n    };\n\n    /**\n     * Handle streaming chunks\n     */\n    const handleStreamChunk = (requestId: string, response: ApiResponse): void => {\n      if (!requestId || !bodhiextInterface._private.streams.has(requestId)) {\n        return;\n      }\n\n      const streamController = bodhiextInterface._private.streams.get(requestId)!;\n\n      if (!isSuccessResponse(response.status)) {\n        const errorMessage = getErrorMessageFromResponse(response, ERROR_STREAM_ERROR);\n        streamController.error(\n          createErrorWithDetails(errorMessage, response.status, response.body)\n        );\n        bodhiextInterface._private.streams.delete(requestId);\n        return;\n      }\n\n      if (response.body && response.body.done) {\n        streamController.complete();\n        bodhiextInterface._private.streams.delete(requestId);\n        return;\n      }\n\n      streamController.enqueue(response);\n    };\n\n    /**\n     * Handle stream errors\n     */\n    const handleStreamError = (requestId: string, response: ApiResponse): void => {\n      if (!requestId || !bodhiextInterface._private.streams.has(requestId)) {\n        logger.info('No matching stream found for STREAM_ERROR', { requestId });\n        return;\n      }\n\n      const streamController = bodhiextInterface._private.streams.get(requestId)!;\n      const errorMessage = getErrorMessageFromResponse(response, ERROR_STREAM_ERROR);\n\n      streamController.error(createErrorWithDetails(errorMessage, response.status, response.body));\n\n      bodhiextInterface._private.streams.delete(requestId);\n    };\n\n    /**\n     * Handle generic errors\n     */\n    const handleGenericError = (requestId: string, response: ApiResponse): void => {\n      if (!requestId) return;\n\n      // Check if this is for a stream request\n      if (bodhiextInterface._private.streams.has(requestId)) {\n        const streamController = bodhiextInterface._private.streams.get(requestId)!;\n        const errorMessage = getErrorMessageFromResponse(response, ERROR_STREAM_ERROR);\n\n        streamController.error(\n          createErrorWithDetails(errorMessage, response.status, response.body)\n        );\n\n        // Clean up the stream\n        bodhiextInterface._private.streams.delete(requestId);\n      }\n      // Otherwise it might be for a regular request that wasn't properly handled\n      else if (bodhiextInterface._private.requests.has(requestId)) {\n        const { reject } = bodhiextInterface._private.requests.get(requestId)!;\n        const errorMessage = getErrorMessageFromResponse(response, ERROR_UNKNOWN_ERROR);\n\n        reject(createErrorWithDetails(errorMessage, response.status, response.body));\n\n        // Clean up\n        bodhiextInterface._private.requests.delete(requestId);\n      }\n    };\n\n    /**\n     * Handle setting the extension ID\n     */\n    const handleSetExtensionId = (extensionId: string): void => {\n      // Only set the ID and dispatch the event if not already set\n      if (!bodhiextInterface.extension_id) {\n        bodhiextInterface.extension_id = extensionId;\n        logger.info('Extension ID set', { extension_id: bodhiextInterface.extension_id });\n\n        // Dispatch a custom event to notify that bodhiext is initialized\n        window.dispatchEvent(\n          new CustomEvent(EVENT_INITIALIZED, {\n            detail: {\n              extensionId: bodhiextInterface.extension_id,\n            },\n          })\n        );\n        logger.info('Dispatched event', { event: EVENT_INITIALIZED });\n      }\n    };\n\n    // Create the public interface by exposing only the public methods\n    const publicInterface: PublicBodhiExtInterface = {\n      sendApiRequest: bodhiextInterface._private.sendApiRequest.bind(bodhiextInterface._private),\n      sendStreamRequest: bodhiextInterface._private.sendStreamRequest.bind(\n        bodhiextInterface._private\n      ),\n      ping: bodhiextInterface.ping.bind(bodhiextInterface),\n      serverState: bodhiextInterface.serverState.bind(bodhiextInterface),\n      chat: bodhiextInterface.chat,\n      getExtensionId() {\n        return bodhiextInterface._private._getExtensionId();\n      },\n    };\n\n    // Freeze the interface to prevent modifications\n    Object.freeze(publicInterface);\n\n    // Define a non-configurable, non-writable property on window\n    Object.defineProperty(window, 'bodhiext', {\n      value: publicInterface,\n      writable: false,\n      configurable: false,\n    });\n\n    // Listen for API responses\n    window.addEventListener('message', bodhiextInterface._private.handleApiResponse);\n\n    // Request the extension ID right away\n    bodhiextInterface._private.requestExtensionId();\n\n    logger.info('Interface successfully created');\n  };\n  createInterface();\n})();\n\n// Public interface for window.bodhiext\ninterface PublicBodhiExtInterface {\n  /**\n   * Send a generic API request to the extension backend.\n   * @param method HTTP method (GET, POST, etc)\n   * @param endpoint API endpoint (e.g. '/v1/chat/completions')\n   * @param body Optional request body\n   * @param headers Optional headers\n   * @returns Promise resolving to { body, headers, status }\n   */\n  sendApiRequest: (\n    method: string,\n    endpoint: string,\n    body?: any,\n    headers?: Record<string, string>\n  ) => Promise<{ body: any; headers: Record<string, string>; status: number }>;\n\n  /**\n   * Send a streaming API request to the extension backend.\n   * @param method HTTP method (GET, POST, etc)\n   * @param endpoint API endpoint (e.g. '/v1/chat/completions')\n   * @param body Optional request body\n   * @param headers Optional headers\n   * @returns ReadableStream yielding streamed response chunks\n   */\n  sendStreamRequest: (\n    method: string,\n    endpoint: string,\n    body?: any,\n    headers?: Record<string, string>\n  ) => ReadableStream;\n\n  ping: () => Promise<any>;\n\n  /**\n   * Get server state information from /bodhi/v1/info endpoint.\n   * @returns Promise resolving to server state information\n   */\n  serverState: () => Promise<{\n    status: 'setup' | 'ready' | 'resource-admin' | 'error' | 'unreachable';\n    version?: string;\n    url?: string;\n    error?: {\n      message: string;\n      type?: string;\n      code?: string;\n      param?: string;\n    };\n  }>;\n\n  chat: {\n    completions: {\n      create: (params: any) => Promise<any> | AsyncIterable<any>;\n    };\n  };\n  getExtensionId: () => Promise<string>;\n}\n"],"names":["HTTP_METHOD_POST","ENDPOINT_CHAT_COMPLETIONS","EVENT_INITIALIZED","createLogger","tag","info","message","args","error","values","result","Array","isArray","JSON","stringify","undefined","parseLoggerArgs","console","createErrorWithDetails","status","body","Error","getErrorMessageFromResponse","response","defaultMessage","ERROR_REQUEST_TIMEOUT","ERROR_STREAM_ERROR","logger","window","bodhiext","bodhiextInterface","_private","requests","Map","streams","baseUrl","generateId","crypto","randomUUID","Math","random","toString","substring","Date","now","floor","handleApiResponse","event","data","type","requestId","handleRegularResponse","handleStreamChunk","handleStreamError","handleGenericError","handleSetExtensionId","extension_id","sendApiRequest","method","endpoint","headers","Promise","resolve","reject","this","set","postMessage","request","origin","setTimeout","has","delete","sendStreamRequest","ReadableStream","start","controller","enqueue","chunk","err","complete","close","get","cancel","reason","requestExtensionId","_getExtensionId","onInitialized","removeEventListener","detail","extensionId","addEventListener","ping","then","serverState","url","version","catch","chat","completions","create","params","stream","readableStream","bind","streamRequestMethod","Symbol","asyncIterator","async","reader","getReader","done","value","read","releaseLock","streamController","errorMessage","dispatchEvent","CustomEvent","publicInterface","getExtensionId","Object","freeze","defineProperty","writable","configurable","createInterface"],"sourceRoot":""}
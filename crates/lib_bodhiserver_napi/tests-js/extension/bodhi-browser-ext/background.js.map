{"version":3,"file":"background.js","mappings":"AAEO,MAAMA,EAAoB,mBACpBC,EAAsB,eACtBC,EAAuB,wBAGvBC,EAA0B,aAM1BC,EAAkB,SAgBlBC,EAEG,qBAFHA,EAIG,qBAJHA,EAMJ,cANIA,EAUe,iCCErB,MAAMC,EAAgBC,IAAgB,CAS3CC,KAAM,CAACC,EAAiBC,OAcxBC,MAAO,CAACF,EAAiBC,KACvB,MAAME,EA5CV,SAAyBF,GACvB,GAAoB,mBAATA,EAAqB,CAC9B,MAAMG,EAASH,IACf,OAAII,MAAMC,QAAQF,GACTA,EACoB,iBAAXA,EACT,CAACG,KAAKC,UAAUJ,IAEhB,CAACA,EAEZ,CAAO,OAAIC,MAAMC,QAAQL,GAChBA,EACEA,GAAwB,iBAATA,EACjB,CAACM,KAAKC,UAAUP,SACLQ,IAATR,EACF,CAACA,GAEH,EACT,CA0BmBS,CAAgBT,GAC/BU,QAAQT,MAAM,UAAUJ,MAAQE,OAAcG,MAI5CS,EAASf,EAAa,UAKfgB,EAAc,CACzBX,EACAJ,EAAc,UACdgB,EAA+B,CAAC,KAEhC,MAAMC,EAAgC,iBAAVb,EAAqBA,EAAQA,EAAMF,QACzDgB,EAA4B,iBAAVd,EAAqB,IAAIe,MAAMf,GAASA,EAOhE,OAJAgB,OAAOC,OAAOH,EAAU,CAAEF,UAASM,SAAUtB,IAG7Cc,EAAOV,MAAM,QAAS,CAAEJ,MAAKiB,eAAcD,UAASO,MAAOL,EAASK,MAAOnB,MAAOc,IAC3EA,GAiCIM,EAAuB,CAClCC,EACAC,EAAkC,CAAC,EACnCC,EAAY,QAEZ,MAAMC,EAAuB,CAC3BH,SACAC,QAAS,CACP,CAAChC,GAAsBD,KACpBiC,IAMP,MDhI6B,QC6HzBD,GAA8BE,IAChCC,EAAQD,KAAOlB,KAAKC,UAAUiB,IAEzBC,GAGIC,EAAsB,CACjC3B,EACA4B,EACAC,GAAoB,KAEb,CACLC,KAAMD,ED/GM,qBC+GkCjC,EAC9CgC,YACAG,SAAU,CACRN,KAAM,CACJvB,MAAO,CACLF,YAGJgC,OAAQ,EACRR,QAAS,CAAC,KAKHS,EAAgBC,MAAOH,IAClC,MAEMN,GAFcM,EAASP,QAAQW,IAAI3C,IAAwB,IACtC4C,SAAS7C,SACRwC,EAASM,aAAeN,EAASO,OACvDd,EAAkC,CAAC,EAIzC,OAHAO,EAASP,QAAQe,QAAQ,CAACC,EAAOC,KAC/BjB,EAAQiB,GAAOD,IAEV,CACLf,OACAO,OAAQD,EAASC,OACjBR,YAcSkB,EAAmBC,IAC9B,IAAKA,GAA0B,KAAjBA,EAAMC,OAAe,OAAO,KAG1C,GAAID,EAAMP,SDhLmB,UCiL3B,MAAO,CAAES,MAAM,GAGjB,IAEE,IAAKF,EAAMG,WAAWnD,GAEpB,OAAIgD,EAAMG,WAAW,MACnBlC,EAAOb,KAAK,mCACL,OAGTa,EAAOb,KAAK,iCAAiC4C,KACtC,MAIT,MAAMI,EAAUJ,EAAMK,QAAQ,IAAIC,OAAO,IAAItD,KAAoB,IAC3DuD,EAAa3C,KAAK4C,MAAMJ,GAG9B,OAAIG,GAAoC,iBAAfA,EAChBA,GAEPtC,EAAOV,MAAM,yCAA0C,CAAE6C,YAElD,CAAEK,KAAML,GAEnB,CAAE,MAAO7C,GACP,MAAMmD,EAAMnD,EAGZ,OAFAU,EAAOV,MAAM,6BAA8B,CAAEyC,QAAOzC,MAAOmD,EAAIrD,UAExD,CAAEoD,KAAMT,EAAOzC,MAAOmD,EAAIrD,QACnC,GAOWsD,EAAkBpB,MAC7BqB,EACA7B,EACA8B,EDnOqC,QCqOrC,IAEE,MAAMC,EAAa,IAAIC,gBACjBC,EAAKC,WAAW,IAAMH,EAAWI,QAASL,GAG1CM,EAAiB,IAClBpC,EACHqC,OAAQN,EAAWM,QAIfhC,QAAiBiC,MAAMT,EAAKO,GAGlC,OAFAG,aAAaN,GAEN5B,CACT,CAAE,MAAO7B,GACP,GAA6B,eAAxBA,GAAegE,KAClB,MAAM,IAAIjD,MAAM,yBAAyBuC,QAAcD,KAEzD,MAAMrD,CACR,GCxNF,IAAIiE,EAAe1E,EAEnB,MAAM,EAASI,EAAa,iBAyGtBuE,EAAiB,CACrBb,EACA7B,EACA2C,EACAzC,EACAC,GAAoB,KAEpByB,EAAgBC,EAAK7B,GAClB4C,KAAKpC,MAAMH,IACV,IAAKA,EAASwC,GAAI,CAChB,MAAMC,QAAuBvC,EAAcF,GAM3C,YALAsC,EAAgB,CACdvC,KAAMD,EAAWjC,EAA6BA,EAC9CgC,YACAG,SAAUyC,GAGd,CAEA,GAAI3C,EAlHsB,EAC9BE,EACAsC,EACAzC,KAEA,MAAM6C,EAAS1C,EAASN,KAAMiD,YACxBC,EAAU,IAAIC,YACpB,IAAIC,EAAS,GAEb,MAAMC,EAAO5C,UACX,IACE,MAAM,KAAEW,EAAI,MAAEL,SAAgBiC,EAAOK,OACrC,GAAIjC,EAAM,CAER,GAAIgC,GAA4B,KAAlBA,EAAOjC,OAAe,CAClC,MAAMQ,EAAOV,EAAgBmC,GACzBzB,GACFiB,EAAgB,CACdvC,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM2B,EACNpB,OAAQD,EAASC,OACjBR,QAAS,CAAC,KAIhBqD,EAAS,EACX,CAWA,YATAR,EAAgB,CACdvC,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CAAEoB,MAAM,GACdb,OAAQD,EAASC,OACjBR,QAAS,CAAC,IAIhB,CAGAqD,GAAUF,EAAQI,OAAOvC,EAAO,CAAEwC,QAAQ,IAG1C,MAAMC,EAASJ,EAAOK,MFnFO,QEoF7BL,EAASI,EAAOE,OAAS,GAGzB,IAAK,MAAMxC,KAASsC,EAAQ,CAC1B,IAAKtC,GAA0B,KAAjBA,EAAMC,OAAe,SAEnC,MAAMQ,EAAOV,EAAgBC,GAC7B,GAAIS,IAEFiB,EAAgB,CACdvC,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM2B,EACNpB,OAAQD,EAASC,OACjBR,QAAS,CAAC,KAIV4B,EAAKP,MACP,MAGN,CAGAiC,GACF,CAAE,MAAO5E,GACP,MAAMmD,EAAMnD,EACZ,EAAOA,MAAM,gCAAiC,CAAEA,MAAOmD,IACvDgB,EAAgB1C,EAAoB0B,EAAIrD,QAAS4B,GAAW,IAG5D,IACE6C,EAAOW,QACT,CAAE,MAAOlF,GACP,EAAOA,MAAM,0BAA2B,CAAEA,SAC5C,CACF,GAGF4E,KA4BMO,CAAwBtD,EAAUsC,EAAiBzC,OAC9C,CAEL,MAAM4C,QAAuBvC,EAAcF,GAC3CsC,EAAgB,CACdvC,KAAMlC,EACNgC,YACAG,SAAUyC,GAEd,IAEDc,MAAMpF,GDJqB,EAC9BA,EACAmE,EACAzC,EACAC,GAAoB,KAEpBjB,EAAOV,MAAM,0BAA2B,CAAEA,UAC1CmE,EAAgB1C,EAAoBzB,EAAMF,QAAS4B,EAAWC,KCH5C0D,CAAiBrF,EAAgBmE,EAAiBzC,EAAWC,KAyCjF2D,OAAOC,QAAQC,YAAYC,YAAYC,IACrC,IACE,EAAO7F,KAAK,kBAAmB,CAAE8F,OAAQD,EAAQC,SAG1B,YAAnBD,EAAQC,QAEVL,OAAOM,KAAKC,OAAO,CACjBxC,IAAKiC,OAAOC,QAAQO,OAAO,gBAE7B,EAAOjG,KAAK,2CACgB,WAAnB6F,EAAQC,QAEjB,EAAO9F,KAAK,oBAAqB,CAAEkG,gBAAiBL,EAAQK,iBAEhE,CAAE,MAAO/F,GACPW,EAAYX,EAAgB,4BAA6B,CAAE0F,WAC7D,IAYFJ,OAAOC,QAAQS,UAAUP,YAAYQ,IFlPJ,sBEmP3BA,EAAKjC,KAKTiC,EAAKC,UAAUT,YAAYzD,MAAOlC,IAChC,EAAOD,KAAK,6BAA8B,CAAE+B,KAAM9B,EAAQ8B,OAC1D,IACE,MAAMF,EAAY5B,GAAS4B,WAAa,GACxC,GFlOY,yBEkOR5B,EAAQ8B,KAGV,OAFA,EAAO5B,MAAM,6CAA8C,CAAE4B,KAAM9B,EAAQ8B,YAC3EqE,EAAKE,YAAY1E,EAAoB,uBAAwBC,GAAW,IAI1E,MAAM0E,EAAgBC,EAAuBvG,GAE7C,GAAKsG,EAAqCxE,OAASlC,EAGjD,OAFA,EAAOM,MAAM,8BAA+B,CAAE0B,mBAC9CuE,EAAKE,YAAYC,GAInB,EAAOvG,KAAK,+BAAgC,CAAE6B,cAC9C,MAAM,OAAEL,EAAM,SAAEiF,EAAQ,KAAE/E,EAAI,QAAED,EAAU,CAAC,GAAM8E,EAC3CxC,EAAiBxC,EAAqBC,EAAQC,EAASC,GAG7D2C,EAFY,GAAGD,IAAeqC,IAEV1C,EAAgB/B,GAAYoE,EAAKE,YAAYtE,GAAWH,GAAW,EACzF,CAAE,MAAO1B,GACP,MAAM0B,EAAa5B,EAAgBoD,MAAMxB,WAAa,GACtDf,EAAYX,EAAgB,0BAA2B,CACrD0B,YACA6E,YAAazG,EAAQ8B,OAEvBqE,EAAKE,YAAY1E,EAAqBzB,EAAgBF,QAAS4B,GAAW,GAC5E,IAnCA,EAAO1B,MAAM,oBAAqB,CAAEwG,SAAUP,EAAKjC,SA2MvDsB,OAAOC,QAAQW,UAAUT,YACvB,CAAC3F,EAAoD2G,EAAQC,KAC3D,EAAO7G,KAAK,6BAA8B,CAAE8G,SAAUF,EAAOhD,KAE7D,IACE,MAAM/B,EAAY5B,GAAS4B,WAAa,GAGxC,GFvaa,0BEuaT5B,EAAQ8B,KAGV,OAFA,EAAO/B,KAAK,qCAAsC,CAAE6B,cArK/B,EAC3B5B,EACA4G,KAEA,MAAM,QAAEE,EAAO,UAAElF,GAAc5B,EAE/B,IAEE,IAAI+G,IAAID,EACV,CAAE,MAiBA,YAhBAF,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQ,QACRuB,IAAKuD,EACL5G,MAAO,CACLF,QAAS,IAAI8G,6EACbhF,KAAM,qBAGVE,OAAQ,EACRR,QAAS,CAAC,IAIhB,CAGA,MAAM+B,EAAM,GAAGuD,kBACThD,EAAiBxC,EAAqB,MAAO,CAAC,EAAG,MAEvDgC,EAAgBC,EAAKO,GAClBQ,KAAKpC,MAAMH,IACV,MAAMyC,QAAuBvC,EAAcF,GAG3C,GAA8B,IAA1ByC,EAAexC,OAqBnB,GAA8B,MAA1BwC,EAAexC,QAAkBwC,EAAe/C,KAClDmF,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQwC,EAAe/C,KAAKO,OAC5BgF,QAASxC,EAAe/C,KAAKuF,QAC7BzD,IAAKuD,GAEP9E,OAAQ,IACRR,QAASgD,EAAehD,eAX9B,CAkBA,GAAIgD,EAAexC,QAAU,IAAK,CAChC,MAAMiF,EACJzC,EAAe/C,MAAMvB,OAAOF,SAC5B,gCAAgCwE,EAAexC,SAiBjD,YAhBA4E,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQ,QACRuB,IAAKuD,EACL5G,MAAO,CACLF,QAAS,iBAAiBiH,IAC1BnF,KAAM,iBAGVE,OAAQwC,EAAexC,OACvBR,QAASgD,EAAehD,UAI9B,CAGAoF,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQ,QACRuB,IAAKuD,EACL5G,MAAO,CACLF,QAAS,yCACT8B,KAAM,mBAGVE,OAAQwC,EAAexC,OACvBR,QAASgD,EAAehD,UAxC5B,MAnCEoF,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQ,cACRuB,IAAKuD,EACL5G,MAAO,CACLF,QAAS,0BAA0B8G,sEACnChF,KAAM,kBAGVE,OAAQ,EACRR,QAAS,CAAC,OAkEjB8D,MAAMpF,IACL,MAAMmD,EAAMnD,EACZ,EAAOA,MAAM,2BAA4B,CAAEA,MAAOmD,EAAIrD,QAAS8G,UAASlF,cAGxE,IAAIsF,EAAc,qBAAqBJ,MACnCzD,EAAIrD,QAAQoC,SAAS,SACvB8E,GAAe,mEACN7D,EAAIrD,QAAQoC,SAAS,WAC9B8E,GAAe,qEAEfA,GAAe,UAAU7D,EAAIrD,UAG/B4G,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAU,CACRN,KAAM,CACJO,OAAQ,cACRuB,IAAKuD,EACL5G,MAAO,CACLF,QAASkH,EACTpF,KAAM,kBAGVE,OAAQ,EACRR,QAAS,CAAC,QAqBZ2F,CAAqBnH,EAAkC4G,IAChD,EAGT,GFrbS,sBEqbL5G,EAAQ8B,KAMV,OALA,EAAO5B,MAAM,6CAA8C,CACzD4B,KAAM9B,EAAQ8B,KACdF,mBAEFgF,EAAajF,EAAoB,uBAAwBC,IAI3D,MAAM0E,EAAgBC,EAAuBvG,GAE7C,GAAKsG,EAAqCxE,OAASlC,EAGjD,OAFA,EAAOM,MAAM,iCAAkC,CAAE0B,mBACjDgF,EAAaN,GAIf,MAAM,OAAE/E,EAAM,SAAEiF,EAAQ,KAAE/E,EAAI,QAAED,EAAU,CAAC,GAAM8E,EACjD,EAAOvG,KAAK,+BAAgC,CAAEwB,SAAQiF,WAAU5E,cAEhE,MAAMkC,EAAiBxC,EAAqBC,EAAQC,EAASC,GAkB7D,OAfA6B,EAFY,GAAGa,IAAeqC,IAET1C,GAClBQ,KAAKpC,MAAMH,IACV,MAAMyC,QAAuBvC,EAAcF,GAC3C6E,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAUyC,MAGbc,MAAMpF,IACL,MAAMmD,EAAMnD,EACZ,EAAOA,MAAM,0BAA2B,CAAEA,MAAOmD,EAAIrD,QAAS4B,cAC9DgF,EAAajF,EAAoB0B,EAAIrD,QAAS4B,OAG3C,CACT,CAAE,MAAO1B,GACP,MAAM0B,EAAY5B,GAAS4B,WAAa,GAClCyB,EAAMnD,EACZ,EAAOA,MAAM,mCAAoC,CAAEA,MAAOmD,EAAIrD,QAAS4B,cACvEgF,EAAajF,EAAoB0B,EAAIrD,QAAS4B,GAChD,IAgBJ,MAAM2E,EAA0BvG,IAE9B,MAAM,KAAE8B,EAAI,UAAEF,EAAS,QAAEwF,GAAYpH,EAC/BuB,EAAS6F,GAAS7F,OAClBiF,EAAWY,GAASZ,SAE1B,IAAIa,EAAe,GAanB,OAZKvF,EAEOF,EAEAwF,EAEA7F,EAEAiF,IACVa,EAAe,YAFfA,EAAe,SAFfA,EAAe,UAFfA,EAAe,YAFfA,EAAe,OAWbA,EACK,CACLvF,KAAMlC,EACNgC,UAAWA,GAAa,GACxBG,SAAU,CACRC,OAAQ,EACRR,QAAS,CAAC,EACVC,KAAM,CACJvB,MAAO,CACLF,QAAS,8BAA8BqH,QAQ1C,CAAEb,SADaA,EAAS1D,WAAW,KAAO0D,EAAW,IAAIA,IAC9BjF,SAAQE,KAAM2F,EAAQ3F,KAAMD,QAAS4F,EAAQ5F,SAAW,CAAC,IAQ7FgE,OAAOC,QAAQ6B,kBAAkB3B,YAAY,CAAC3F,EAA4B2G,EAAQC,KAChF,EAAO7G,KAAK,qCAAsC,CAAE8G,SAAUF,EAAOhD,KAErE,IAEE,MAAM2C,EAAgBC,EAAuBvG,GACvC4B,EAAY5B,EAAQ4B,UAG1B,GAAK0E,EAAqCxE,OAASlC,EAGjD,OAFA,EAAOG,KAAK,mCAAoC,CAAE6B,mBAClDgF,EAAaN,GAIf,MAAM,OAAE/E,EAAM,SAAEiF,EAAQ,KAAE/E,EAAI,QAAED,EAAU,CAAC,GAAM8E,EAC3CxC,EAAiBxC,EAAqBC,EAAQC,EAASC,GAqB7D,OAlBA6B,EAFY,GAAGa,IAAeqC,IAET1C,GAClBQ,KAAKpC,MAAMH,IACV,MAAMyC,QAAuBvC,EAAcF,GAC3C6E,EAAa,CACX9E,KAAMlC,EACNgC,YACAG,SAAUyC,MAGbc,MAAMpF,IACL,MAAMmD,EAAMnD,EACZW,EAAYwC,EAAK,kCAAmC,CAClDzB,YACAiF,SAAUF,EAAOhD,KAEnBiD,EAAajF,EAAoB0B,EAAIrD,QAAS4B,GAAa,QAGxD,CACT,CAAE,MAAO1B,GACP,MAAMmD,EAAMnD,EACZW,EAAYwC,EAAK,kCAAmC,CAClDoD,YAAazG,GAAS8B,KACtBF,UAAW5B,GAAS4B,UACpBiF,SAAUF,EAAOhD,KAEnBiD,EAAajF,EAAoB0B,EAAIrD,QAASA,GAAS4B,WAAa,IACtE,IAYF4D,OAAOC,QAAQ8B,kBAAkB5B,YAAYQ,IAC3C,EAAOpG,KAAK,gDAAiD,CAC3D8G,SAAUV,EAAKQ,QAAQhD,IAAM,YAG/B,IAEEwC,EAAKC,UAAUT,YAAYzD,MAAOkF,IAEhC,MAAMd,EAAgBC,EAAuBa,GACvCxF,EAAYwF,EAAQxF,UAE1B,IAEE,GAAK0E,EAAqCxE,OAASlC,EAEjD,YADAuG,EAAKE,YAAYC,GAInB,MAAM,SAAEE,EAAQ,OAAEjF,EAAM,KAAEE,EAAI,QAAED,EAAU,CAAC,GAAM8E,EAC3CxC,EAAiBxC,EAAqBC,EAAQC,EAASC,GAG7D2C,EAFY,GAAGD,IAAeqC,IAI5B1C,EACA/B,GAAYoE,EAAKE,YAAYtE,GAC7BH,GAAa,IACb,EAEJ,CAAE,MAAO1B,GACP,MAAMmD,EAAMnD,EACZW,EAAYwC,EAAK,4CAA6C,CAC5DzB,YACAiF,SAAUV,EAAKQ,QAAQhD,KAEzBwC,EAAKE,YAAY1E,EAAoB0B,EAAIrD,QAAS4B,GAAa,IAAI,GACrE,IAIFuE,EAAKqB,aAAa7B,YAAY,KAC5B,EAAO5F,KAAK,yBAA0B,CAAE8G,SAAUV,EAAKQ,QAAQhD,IAAM,aAGzE,CAAE,MAAOzD,GACPW,EAAYX,EAAgB,kCAAmC,CAC7D2G,SAAUV,EAAKQ,QAAQhD,IAE3B,IAzeoB,MACpB,IACE,EAAO5D,KAAK,yCAGZyF,OAAOiC,QAAQC,MAAMvF,IAAI,CAACzC,GAA0BU,IAC9CA,EAAOV,IACTyE,EAAe/D,EAAOV,GACtB,EAAOK,KAAK,+BAAgC,CAAEoE,kBAE9C,EAAOpE,KAAK,4BAA6B,CAAEoE,mBAK/CqB,OAAOiC,QAAQE,UAAUhC,YAAY,CAACiC,EAASC,KAChC,UAATA,GAAoBD,EAAQlI,KAC9ByE,EAAeyD,EAAQlI,GAAyBoI,UAAYrI,EAC5D,EAAOM,KAAK,sBAAuB,CAAEoE,mBAG3C,CAAE,MAAOjE,GACPW,EAAYX,EAAgB,8BAC9B,GA2dA6H","sources":["webpack://bodhi-browser/./src-ext/shared/constants.ts","webpack://bodhi-browser/./src-ext/shared/utils.ts","webpack://bodhi-browser/./src-ext/background.ts"],"sourcesContent":["// Shared constants for Bodhi Browser Extension\n\nexport const CONTENT_TYPE_JSON = 'application/json';\nexport const CONTENT_TYPE_HEADER = 'Content-Type';\nexport const DEFAULT_API_BASE_URL = 'http://localhost:1135';\nexport const DEFAULT_REQUEST_TIMEOUT = 150000; // 2.5 minutes\nexport const BODHI_STREAM_PORT = 'BODHI_STREAM_PORT';\nexport const STORAGE_KEY_BACKEND_URL = 'backendUrl';\nexport const HTTP_METHOD_GET = 'GET';\nexport const HTTP_METHOD_POST = 'POST';\nexport const ENDPOINT_PING = '/ping';\nexport const ENDPOINT_CHAT_COMPLETIONS = '/v1/chat/completions';\nexport const SSE_DONE_MARKER = '[DONE]';\nexport const SSE_DATA_PREFIX = 'data: ';\nexport const SSE_CHUNK_DELIMITER = '\\n\\n';\n\n// Document states\nexport const DOCUMENT_STATE_COMPLETE = 'complete';\n\n// Event names\nexport const EVENT_INITIALIZED = 'bodhiext:initialized';\n\n// Origin fallback\nexport const ORIGIN_WILDCARD = '*';\n\n// Error messages\nexport const ERROR_MISSING_REQUEST_ID = 'Invalid message format: missing requestId or request';\nexport const ERROR_CONNECTION_CLOSED = 'Connection closed unexpectedly';\n\nexport const MESSAGE_TYPES = {\n  API_REQUEST: 'BODHI_API_REQUEST',\n  API_RESPONSE: 'BODHI_API_RESPONSE',\n  STREAM_REQUEST: 'BODHI_STREAM_REQUEST',\n  STREAM_CHUNK: 'BODHI_STREAM_CHUNK',\n  STREAM_ERROR: 'BODHI_STREAM_ERROR',\n  ERROR: 'BODHI_ERROR',\n  GET_EXTENSION_ID: 'BODHI_GET_EXTENSION_ID',\n  SET_EXTENSION_ID: 'BODHI_SET_EXTENSION_ID',\n  TEST_CONNECTION: 'BODHI_TEST_CONNECTION',\n  TEST_CONNECTION_RESPONSE: 'BODHI_TEST_CONNECTION_RESPONSE',\n};\n","/* global RequestInit */\n/// <reference lib=\"dom\" />\n/// Shared utility functions for Bodhi Browser Extension\nimport {\n  MESSAGE_TYPES,\n  CONTENT_TYPE_HEADER,\n  CONTENT_TYPE_JSON,\n  HTTP_METHOD_GET,\n  SSE_DONE_MARKER,\n  SSE_DATA_PREFIX,\n  DEFAULT_REQUEST_TIMEOUT,\n} from './constants.js';\nimport { ApiResponse, ApiResponseMessage, SSEChunk } from './types.js';\n\n// Status code ranges\nconst HTTP_STATUS_OK_MIN = 200;\nconst HTTP_STATUS_OK_MAX = 299;\n\n// Create a shared logger instance\nconst isProd = process.env.NODE_ENV === 'production';\n\nfunction parseLoggerArgs(args: any): any[] {\n  if (typeof args === 'function') {\n    const result = args();\n    if (Array.isArray(result)) {\n      return result;\n    } else if (typeof result === 'object') {\n      return [JSON.stringify(result)];\n    } else {\n      return [result];\n    }\n  } else if (Array.isArray(args)) {\n    return args;\n  } else if (args && typeof args === 'object') {\n    return [JSON.stringify(args)];\n  } else if (args !== undefined) {\n    return [args];\n  }\n  return [];\n}\n\nexport const createLogger = (tag: string) => ({\n  /**\n   * Enhanced info logger for dev/prod optimization.\n   * Usage:\n   *   logger.info('msg', [val1, val2])\n   *   logger.info('msg', () => [val1, val2])\n   *   logger.info('msg', () => ({foo: bar}))\n   *   logger.info('msg', {foo: bar})\n   */\n  info: (message: string, args?: any): void => {\n    if (isProd) return;\n    const values = parseLoggerArgs(args);\n    console.info(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n  /**\n   * Enhanced error logger for dev/prod optimization.\n   * Usage:\n   *   logger.error('msg', [val1, val2])\n   *   logger.error('msg', () => [val1, val2])\n   *   logger.error('msg', () => ({foo: bar}))\n   *   logger.error('msg', {foo: bar})\n   *   logger.error('msg', error)\n   */\n  error: (message: string, args?: any): void => {\n    const values = parseLoggerArgs(args);\n    console.error(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n});\n\nconst logger = createLogger('shared');\n\n/**\n * Centralized error handler to standardize error management across all components\n */\nexport const handleError = (\n  error: Error | string,\n  tag: string = 'unknown',\n  context: Record<string, any> = {}\n): Error => {\n  const errorMessage = typeof error === 'string' ? error : error.message;\n  const errorObj = typeof error === 'string' ? new Error(error) : error;\n\n  // Add context to the error object for debugging\n  Object.assign(errorObj, { context, location: tag });\n\n  // Log the error with contextual information\n  logger.error('Error', { tag, errorMessage, context, stack: errorObj.stack, error: errorObj });\n  return errorObj;\n};\n\n/**\n * Creates an error object with additional properties\n */\nexport const createErrorWithDetails = (message: string, status: number, body: any): Error => {\n  const error: any = new Error(message);\n  error.status = status;\n  error.body = body;\n  return error;\n};\n\n/**\n * Extracts error message from response body if available\n */\nexport const getErrorMessageFromResponse = (\n  response: ApiResponse | undefined,\n  defaultMessage: string\n): string => {\n  if (response?.body?.error?.message) {\n    return response.body.error.message;\n  }\n  return defaultMessage;\n};\n\n/**\n * Checks if a response status indicates success\n */\nexport const isSuccessResponse = (status: number): boolean => {\n  return status >= HTTP_STATUS_OK_MIN && status < HTTP_STATUS_OK_MAX;\n};\n\nexport const createRequestOptions = (\n  method: string,\n  headers: Record<string, string> = {},\n  body: any = null\n): RequestInit => {\n  const options: RequestInit = {\n    method,\n    headers: {\n      [CONTENT_TYPE_HEADER]: CONTENT_TYPE_JSON,\n      ...headers,\n    },\n  };\n  if (method !== HTTP_METHOD_GET && body) {\n    options.body = JSON.stringify(body);\n  }\n  return options;\n};\n\nexport const createErrorResponse = (\n  message: string,\n  requestId: string,\n  isStream: boolean = false\n): ApiResponseMessage => {\n  return {\n    type: isStream ? MESSAGE_TYPES.STREAM_ERROR : MESSAGE_TYPES.API_RESPONSE,\n    requestId,\n    response: {\n      body: {\n        error: {\n          message,\n        },\n      },\n      status: 0,\n      headers: {},\n    },\n  };\n};\n\nexport const parseResponse = async (response: Response): Promise<ApiResponse> => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER) || '';\n  const isJson = contentType.includes(CONTENT_TYPE_JSON);\n  const body = isJson ? await response.json() : await response.text();\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return {\n    body,\n    status: response.status,\n    headers,\n  };\n};\n\nexport const handleFetchError = (\n  error: Error,\n  responseHandler: (response: ApiResponseMessage) => void,\n  requestId: string,\n  isStream: boolean = false\n): void => {\n  logger.error('Error fetching from API', { error });\n  responseHandler(createErrorResponse(error.message, requestId, isStream));\n};\n\nexport const processSSEChunk = (chunk: string): SSEChunk | null => {\n  if (!chunk || chunk.trim() === '') return null;\n\n  // Check for the done marker\n  if (chunk.includes(SSE_DONE_MARKER)) {\n    return { done: true };\n  }\n\n  try {\n    // Check if the chunk starts with the expected data prefix\n    if (!chunk.startsWith(SSE_DATA_PREFIX)) {\n      // If it's a keep-alive comment or other non-data line, ignore it\n      if (chunk.startsWith(':')) {\n        logger.info('Received SSE keep-alive comment');\n        return null;\n      }\n      // Handle malformed chunks\n      logger.info(`Received malformed SSE chunk: ${chunk}`);\n      return null;\n    }\n\n    // Remove \"data: \" prefix from the chunk and parse JSON\n    const jsonStr = chunk.replace(new RegExp(`^${SSE_DATA_PREFIX}`), '');\n    const parsedData = JSON.parse(jsonStr);\n\n    // Validate the parsed data has the expected structure\n    if (parsedData && typeof parsedData === 'object') {\n      return parsedData as SSEChunk;\n    } else {\n      logger.error('Received unexpected SSE data structure', { jsonStr });\n      // Return a typed object instead of raw string\n      return { data: jsonStr };\n    }\n  } catch (error) {\n    const err = error as Error;\n    logger.error('Error processing SSE chunk', { chunk, error: err.message });\n    // Return a typed object instead of raw string\n    return { data: chunk, error: err.message };\n  }\n};\n\n/**\n * Makes an HTTP request with standardized error handling.\n * Can be used in both background and inject scripts.\n */\nexport const makeHttpRequest = async (\n  url: string,\n  options: RequestInit,\n  timeout: number = DEFAULT_REQUEST_TIMEOUT\n): Promise<Response> => {\n  try {\n    // Create an AbortController for timeout handling\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n\n    // Add the signal to the options\n    const requestOptions = {\n      ...options,\n      signal: controller.signal,\n    };\n\n    // Make the request\n    const response = await fetch(url, requestOptions);\n    clearTimeout(id);\n\n    return response;\n  } catch (error) {\n    if ((error as any)?.name === 'AbortError') {\n      throw new Error(`Request timeout after ${timeout}ms: ${url}`);\n    }\n    throw error;\n  }\n};\n","/* global RequestInit */\n/// <reference lib=\"dom\" />\n/**\n * Bodhi Browser Plugin background script\n * Responsible for initializing extension services and handling HTTP requests\n */\n\n// Use strict mode for better error catching and performance\n'use strict';\n\n//-----------------------------------------------------------------------------------\n// CONSTANTS AND CONFIGURATION\n//-----------------------------------------------------------------------------------\n\nimport {\n  DEFAULT_API_BASE_URL,\n  BODHI_STREAM_PORT,\n  STORAGE_KEY_BACKEND_URL,\n  SSE_CHUNK_DELIMITER,\n  MESSAGE_TYPES,\n} from './shared/constants.js';\nimport {\n  ApiRequest,\n  ApiResponseMessage,\n  ApiRequestMessage,\n  TestConnectionMessage,\n  TestConnectionResponseMessage,\n} from './shared/types.js';\nimport {\n  createLogger,\n  createRequestOptions,\n  createErrorResponse,\n  parseResponse,\n  handleFetchError,\n  processSSEChunk,\n  makeHttpRequest,\n  handleError,\n} from './shared/utils.js';\n\nlet API_BASE_URL = DEFAULT_API_BASE_URL;\n\nconst logger = createLogger('background.js');\n\n//-----------------------------------------------------------------------------------\n// SHARED API UTILITY FUNCTIONS (now imported from shared/utils)\n//-----------------------------------------------------------------------------------\n\n/**\n * Handle all streaming responses with consistent format\n * Manages reading the stream and sending chunks as they arrive\n */\nconst handleStreamingResponse = (\n  response: Response,\n  responseHandler: (response: ApiResponseMessage) => void,\n  requestId: string\n): void => {\n  const reader = response.body!.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  const read = async (): Promise<void> => {\n    try {\n      const { done, value } = await reader.read();\n      if (done) {\n        // If buffer has unprocessed data, emit it as a chunk before sending done: true\n        if (buffer && buffer.trim() !== '') {\n          const data = processSSEChunk(buffer);\n          if (data) {\n            responseHandler({\n              type: MESSAGE_TYPES.STREAM_CHUNK,\n              requestId,\n              response: {\n                body: data,\n                status: response.status,\n                headers: {},\n              },\n            });\n          }\n          buffer = '';\n        }\n        // Send the [DONE] message if the stream is complete\n        responseHandler({\n          type: MESSAGE_TYPES.STREAM_CHUNK,\n          requestId,\n          response: {\n            body: { done: true },\n            status: response.status,\n            headers: {},\n          },\n        });\n        return;\n      }\n\n      // Decode the value and add to buffer\n      buffer += decoder.decode(value, { stream: true });\n\n      // Process any complete SSE events\n      const chunks = buffer.split(SSE_CHUNK_DELIMITER);\n      buffer = chunks.pop() || ''; // Keep the last incomplete chunk (if any)\n\n      // Process all complete chunks\n      for (const chunk of chunks) {\n        if (!chunk || chunk.trim() === '') continue;\n\n        const data = processSSEChunk(chunk);\n        if (data) {\n          // Send chunk to client\n          responseHandler({\n            type: MESSAGE_TYPES.STREAM_CHUNK,\n            requestId,\n            response: {\n              body: data,\n              status: response.status,\n              headers: {},\n            },\n          });\n          // If we see the done signal, emit and stop\n          if (data.done) {\n            return;\n          }\n        }\n      }\n\n      // Continue reading\n      read();\n    } catch (error) {\n      const err = error as Error;\n      logger.error('Error processing stream chunk', { error: err });\n      responseHandler(createErrorResponse(err.message, requestId, true));\n\n      // Ensure reader is released in case of error\n      try {\n        reader.cancel();\n      } catch (error) {\n        logger.error('Error cancelling reader', { error });\n      }\n    }\n  };\n\n  read();\n};\n\n/**\n * Make API request with proper error handling\n * Centralized method for all fetch calls\n */\nconst makeApiRequest = (\n  url: string,\n  options: RequestInit,\n  responseHandler: (response: ApiResponseMessage) => void,\n  requestId: string,\n  isStream: boolean = false\n): void => {\n  makeHttpRequest(url, options)\n    .then(async response => {\n      if (!response.ok) {\n        const parsedResponse = await parseResponse(response);\n        responseHandler({\n          type: isStream ? MESSAGE_TYPES.STREAM_CHUNK : MESSAGE_TYPES.API_RESPONSE,\n          requestId,\n          response: parsedResponse,\n        });\n        return;\n      }\n\n      if (isStream) {\n        // Handle streaming response\n        handleStreamingResponse(response, responseHandler, requestId);\n      } else {\n        // Handle regular response\n        const parsedResponse = await parseResponse(response);\n        responseHandler({\n          type: MESSAGE_TYPES.API_RESPONSE,\n          requestId,\n          response: parsedResponse,\n        });\n      }\n    })\n    .catch(error => handleFetchError(error as Error, responseHandler, requestId, isStream));\n};\n\n//-----------------------------------------------------------------------------------\n// INITIALIZATION AND LIFECYCLE HANDLERS\n//-----------------------------------------------------------------------------------\n\n/**\n * Initialize the extension's background service\n * Sets up backend URL configuration and listeners\n */\nconst initExtension = (): void => {\n  try {\n    logger.info('Background service worker initialized');\n\n    // Load the configured backend URL\n    chrome.storage.local.get([STORAGE_KEY_BACKEND_URL], result => {\n      if (result[STORAGE_KEY_BACKEND_URL]) {\n        API_BASE_URL = result[STORAGE_KEY_BACKEND_URL];\n        logger.info('Using configured backend URL', { API_BASE_URL });\n      } else {\n        logger.info('Using default backend URL', { API_BASE_URL });\n      }\n    });\n\n    // Listen for changes to the backend URL\n    chrome.storage.onChanged.addListener((changes, area) => {\n      if (area === 'local' && changes[STORAGE_KEY_BACKEND_URL]) {\n        API_BASE_URL = changes[STORAGE_KEY_BACKEND_URL].newValue || DEFAULT_API_BASE_URL;\n        logger.info('Backend URL updated', { API_BASE_URL });\n      }\n    });\n  } catch (error) {\n    handleError(error as Error, 'background.js:initExtension');\n  }\n};\n\n/**\n * Handle extension installation or update events\n * Triggered when the extension is first installed or updated to a new version\n */\nchrome.runtime.onInstalled.addListener(details => {\n  try {\n    logger.info('Extension event', { reason: details.reason });\n\n    // Handle first installation vs update differently if needed\n    if (details.reason === 'install') {\n      // Open the extension page when first installed\n      chrome.tabs.create({\n        url: chrome.runtime.getURL('index.html'),\n      });\n      logger.info('Opened extension page on first install');\n    } else if (details.reason === 'update') {\n      // Update logic - optionally open page for major updates\n      logger.info('Extension updated', { previousVersion: details.previousVersion });\n    }\n  } catch (error) {\n    handleError(error as Error, 'background.js:onInstalled', { details });\n  }\n});\n\n//-----------------------------------------------------------------------------------\n// CONTENT SCRIPT STREAMING COMMUNICATION (LONG-LIVED CONNECTIONS)\n//-----------------------------------------------------------------------------------\n\n/**\n * Handle long-lived connections from content scripts\n * Used for streaming responses where multiple messages are sent over time\n * Invoked when a content script calls chrome.runtime.connect()\n */\nchrome.runtime.onConnect.addListener(port => {\n  if (port.name !== BODHI_STREAM_PORT) {\n    logger.error('Invalid port name', { portName: port.name });\n    return;\n  }\n\n  port.onMessage.addListener(async (message: ApiRequestMessage) => {\n    logger.info('Received onConnect request', { type: message.type });\n    try {\n      const requestId = message?.requestId || '';\n      if (message.type !== MESSAGE_TYPES.STREAM_REQUEST) {\n        logger.error('Invalid message type for onConnect request', { type: message.type });\n        port.postMessage(createErrorResponse('Invalid message type', requestId, true));\n        return;\n      }\n\n      const requestConfig = parseApiRequestMessage(message);\n\n      if ((requestConfig as ApiResponseMessage).type === MESSAGE_TYPES.ERROR) {\n        logger.error('Malformed streaming request', { requestId });\n        port.postMessage(requestConfig);\n        return;\n      }\n\n      logger.info('Processing onConnect request', { requestId });\n      const { method, endpoint, body, headers = {} } = requestConfig as ApiRequest;\n      const requestOptions = createRequestOptions(method, headers, body);\n      const url = `${API_BASE_URL}${endpoint}`;\n\n      makeApiRequest(url, requestOptions, response => port.postMessage(response), requestId, true);\n    } catch (error) {\n      const requestId = (message as any).data?.requestId || '';\n      handleError(error as Error, 'background.js:onConnect', {\n        requestId,\n        messageType: message.type,\n      });\n      port.postMessage(createErrorResponse((error as Error).message, requestId, true));\n    }\n  });\n});\n\n//-----------------------------------------------------------------------------------\n// CONTENT SCRIPT ONE-TIME MESSAGING\n//-----------------------------------------------------------------------------------\n\n/**\n * Handle test connection requests with custom URL\n * Does not modify stored configuration, only tests the provided URL\n */\nconst handleTestConnection = (\n  message: TestConnectionMessage,\n  sendResponse: (response: TestConnectionResponseMessage) => void\n): void => {\n  const { testUrl, requestId } = message;\n\n  try {\n    // Validate URL format\n    new URL(testUrl);\n  } catch {\n    sendResponse({\n      type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n      requestId,\n      response: {\n        body: {\n          status: 'error' as const,\n          url: testUrl,\n          error: {\n            message: `'${testUrl}' is not a valid URL. Please enter a valid URL like http://localhost:1135`,\n            type: 'validation_error',\n          },\n        },\n        status: 0,\n        headers: {},\n      },\n    });\n    return;\n  }\n\n  // Test the connection to the specific URL\n  const url = `${testUrl}/bodhi/v1/info`;\n  const requestOptions = createRequestOptions('GET', {}, null);\n\n  makeHttpRequest(url, requestOptions)\n    .then(async response => {\n      const parsedResponse = await parseResponse(response);\n\n      // Handle network errors (status 0 means network failure)\n      if (parsedResponse.status === 0) {\n        sendResponse({\n          type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n          requestId,\n          response: {\n            body: {\n              status: 'unreachable' as const,\n              url: testUrl,\n              error: {\n                message: `Cannot reach server at ${testUrl}. Please check if the Bodhi app is running and the URL is correct.`,\n                type: 'network_error',\n              },\n            },\n            status: 0,\n            headers: {},\n          },\n        });\n        return;\n      }\n\n      // Handle successful response (status 200)\n      if (parsedResponse.status === 200 && parsedResponse.body) {\n        sendResponse({\n          type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n          requestId,\n          response: {\n            body: {\n              status: parsedResponse.body.status,\n              version: parsedResponse.body.version,\n              url: testUrl,\n            },\n            status: 200,\n            headers: parsedResponse.headers,\n          },\n        });\n        return;\n      }\n\n      // Handle server error response (status 500 or other error codes)\n      if (parsedResponse.status >= 400) {\n        const errorMsg =\n          parsedResponse.body?.error?.message ||\n          `Server returned error status ${parsedResponse.status}`;\n        sendResponse({\n          type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n          requestId,\n          response: {\n            body: {\n              status: 'error' as const,\n              url: testUrl,\n              error: {\n                message: `Server error: ${errorMsg}`,\n                type: 'server_error',\n              },\n            },\n            status: parsedResponse.status,\n            headers: parsedResponse.headers,\n          },\n        });\n        return;\n      }\n\n      // Handle unexpected response format\n      sendResponse({\n        type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n        requestId,\n        response: {\n          body: {\n            status: 'error' as const,\n            url: testUrl,\n            error: {\n              message: 'Unexpected response format from server',\n              type: 'response_error',\n            },\n          },\n          status: parsedResponse.status,\n          headers: parsedResponse.headers,\n        },\n      });\n    })\n    .catch(error => {\n      const err = error as Error;\n      logger.error('Error testing connection', { error: err.message, testUrl, requestId });\n\n      // Provide user-friendly error messages based on error type\n      let userMessage = `Cannot connect to ${testUrl}. `;\n      if (err.message.includes('fetch')) {\n        userMessage += 'Please check if the Bodhi app is running and the URL is correct.';\n      } else if (err.message.includes('timeout')) {\n        userMessage += 'Connection timed out. The server may be overloaded or unreachable.';\n      } else {\n        userMessage += `Error: ${err.message}`;\n      }\n\n      sendResponse({\n        type: MESSAGE_TYPES.TEST_CONNECTION_RESPONSE,\n        requestId,\n        response: {\n          body: {\n            status: 'unreachable' as const,\n            url: testUrl,\n            error: {\n              message: userMessage,\n              type: 'network_error',\n            },\n          },\n          status: 0,\n          headers: {},\n        },\n      });\n    });\n};\n\n/**\n * Handle one-time messages from content scripts\n * Used for regular API requests that expect a single response\n * Invoked when a content script calls chrome.runtime.sendMessage()\n */\nchrome.runtime.onMessage.addListener(\n  (message: ApiRequestMessage | TestConnectionMessage, sender, sendResponse) => {\n    logger.info('Received onMessage request', { senderId: sender.id });\n\n    try {\n      const requestId = message?.requestId || '';\n\n      // Handle test connection requests\n      if (message.type === MESSAGE_TYPES.TEST_CONNECTION) {\n        logger.info('Processing test connection request', { requestId });\n        handleTestConnection(message as TestConnectionMessage, sendResponse);\n        return true; // Indicate async response\n      }\n\n      if (message.type !== MESSAGE_TYPES.API_REQUEST) {\n        logger.error('Invalid message type for onMessage request', {\n          type: message.type,\n          requestId,\n        });\n        sendResponse(createErrorResponse('Invalid message type', requestId));\n        return;\n      }\n\n      const requestConfig = parseApiRequestMessage(message as ApiRequestMessage);\n\n      if ((requestConfig as ApiResponseMessage).type === MESSAGE_TYPES.ERROR) {\n        logger.error('Malformed request in onMessage', { requestId });\n        sendResponse(requestConfig);\n        return;\n      }\n\n      const { method, endpoint, body, headers = {} } = requestConfig as ApiRequest;\n      logger.info('Processing onMessage request', { method, endpoint, requestId });\n\n      const requestOptions = createRequestOptions(method, headers, body);\n      const url = `${API_BASE_URL}${endpoint}`;\n\n      makeHttpRequest(url, requestOptions)\n        .then(async response => {\n          const parsedResponse = await parseResponse(response);\n          sendResponse({\n            type: MESSAGE_TYPES.API_RESPONSE,\n            requestId,\n            response: parsedResponse,\n          });\n        })\n        .catch(error => {\n          const err = error as Error;\n          logger.error('Error fetching from API', { error: err.message, requestId });\n          sendResponse(createErrorResponse(err.message, requestId));\n        });\n\n      return true; // Indicate async response\n    } catch (error) {\n      const requestId = message?.requestId || '';\n      const err = error as Error;\n      logger.error('Error handling onMessage request', { error: err.message, requestId });\n      sendResponse(createErrorResponse(err.message, requestId));\n    }\n  }\n);\n\n//-----------------------------------------------------------------------------------\n// EXTERNAL EXTENSION ONE-TIME MESSAGING\n//-----------------------------------------------------------------------------------\n\n/**\n * Process external extension API requests\n * Maps actions like 'ping' and 'chat.completions.create' to appropriate endpoints\n */\n/**\n * Process external extension API requests\n * Supports both legacy (action/payload) and unified (type/request/requestId) formats\n */\nconst parseApiRequestMessage = (message: ApiRequestMessage): ApiRequest | ApiResponseMessage => {\n  // Unified format: { type, requestId, request: { method, endpoint, body, headers } }\n  const { type, requestId, request } = message as any;\n  const method = request?.method;\n  const endpoint = request?.endpoint;\n\n  let missingField = '';\n  if (!type) {\n    missingField = 'type';\n  } else if (!requestId) {\n    missingField = 'requestId';\n  } else if (!request) {\n    missingField = 'request';\n  } else if (!method) {\n    missingField = 'method';\n  } else if (!endpoint) {\n    missingField = 'endpoint';\n  }\n\n  if (missingField) {\n    return {\n      type: MESSAGE_TYPES.ERROR,\n      requestId: requestId || '',\n      response: {\n        status: 0,\n        headers: {},\n        body: {\n          error: {\n            message: `Malformed request: missing ${missingField}`,\n          },\n        },\n      },\n    };\n  }\n\n  const fixedEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\n  return { endpoint: fixedEndpoint, method, body: request.body, headers: request.headers || {} };\n};\n\n/**\n * Handle one-time messages from other extensions\n * Used when external extensions need to make API requests through this extension\n * Invoked when another extension calls chrome.runtime.sendMessage(extensionId, ...)\n */\nchrome.runtime.onMessageExternal.addListener((message: ApiRequestMessage, sender, sendResponse) => {\n  logger.info('Received onMessageExternal request', { senderId: sender.id });\n\n  try {\n    // message is always ApiRequestMessage, so we don't need type checks\n    const requestConfig = parseApiRequestMessage(message);\n    const requestId = message.requestId;\n\n    // If there was an error in the request, return it\n    if ((requestConfig as ApiResponseMessage).type === MESSAGE_TYPES.ERROR) {\n      logger.info('Error response onMessageExternal', { requestId });\n      sendResponse(requestConfig);\n      return;\n    }\n\n    const { method, endpoint, body, headers = {} } = requestConfig as ApiRequest;\n    const requestOptions = createRequestOptions(method, headers, body);\n    const url = `${API_BASE_URL}${endpoint}`;\n\n    makeHttpRequest(url, requestOptions)\n      .then(async response => {\n        const parsedResponse = await parseResponse(response);\n        sendResponse({\n          type: MESSAGE_TYPES.API_RESPONSE,\n          requestId,\n          response: parsedResponse,\n        });\n      })\n      .catch(error => {\n        const err = error as Error;\n        handleError(err, 'background.js:onMessageExternal', {\n          requestId,\n          senderId: sender.id,\n        });\n        sendResponse(createErrorResponse(err.message, requestId || ''));\n      });\n\n    return true; // Indicate async response\n  } catch (error) {\n    const err = error as Error;\n    handleError(err, 'background.js:onMessageExternal', {\n      messageType: message?.type,\n      requestId: message?.requestId,\n      senderId: sender.id,\n    });\n    sendResponse(createErrorResponse(err.message, message?.requestId || ''));\n  }\n});\n\n//-----------------------------------------------------------------------------------\n// EXTERNAL EXTENSION STREAMING COMMUNICATION\n//-----------------------------------------------------------------------------------\n\n/**\n * Handle long-lived connections from other extensions\n * Used for streaming responses to external extensions\n * Invoked when another extension calls chrome.runtime.connect(extensionId, ...)\n */\nchrome.runtime.onConnectExternal.addListener(port => {\n  logger.info('Received onConnectExternal connection request', {\n    senderId: port.sender?.id || 'unknown',\n  });\n\n  try {\n    // Handle messages on this port\n    port.onMessage.addListener(async (request: ApiRequestMessage) => {\n      // message is always ApiRequestMessage, so we don't need type checks\n      const requestConfig = parseApiRequestMessage(request);\n      const requestId = request.requestId;\n\n      try {\n        // If there was an error in the request, return it\n        if ((requestConfig as ApiResponseMessage).type === MESSAGE_TYPES.ERROR) {\n          port.postMessage(requestConfig);\n          return;\n        }\n\n        const { endpoint, method, body, headers = {} } = requestConfig as ApiRequest;\n        const requestOptions = createRequestOptions(method, headers, body);\n        const url = `${API_BASE_URL}${endpoint}`;\n\n        makeApiRequest(\n          url,\n          requestOptions,\n          response => port.postMessage(response),\n          requestId || '',\n          true\n        );\n      } catch (error) {\n        const err = error as Error;\n        handleError(err, 'background.js:onConnectExternal.onMessage', {\n          requestId,\n          senderId: port.sender?.id,\n        });\n        port.postMessage(createErrorResponse(err.message, requestId || '', true));\n      }\n    });\n\n    // Handle disconnection\n    port.onDisconnect.addListener(() => {\n      logger.info('Extension disconnected', { senderId: port.sender?.id || 'unknown' });\n      // Any cleanup needed when an extension disconnects\n    });\n  } catch (error) {\n    handleError(error as Error, 'background.js:onConnectExternal', {\n      senderId: port.sender?.id,\n    });\n  }\n});\n\n//-----------------------------------------------------------------------------------\n// INITIALIZE EXTENSION\n//-----------------------------------------------------------------------------------\n\n// Immediately Invoked Function Expression (IIFE) to start the extension\n(function () {\n  initExtension();\n})();\n"],"names":["CONTENT_TYPE_JSON","CONTENT_TYPE_HEADER","DEFAULT_API_BASE_URL","STORAGE_KEY_BACKEND_URL","SSE_DATA_PREFIX","MESSAGE_TYPES","createLogger","tag","info","message","args","error","values","result","Array","isArray","JSON","stringify","undefined","parseLoggerArgs","console","logger","handleError","context","errorMessage","errorObj","Error","Object","assign","location","stack","createRequestOptions","method","headers","body","options","createErrorResponse","requestId","isStream","type","response","status","parseResponse","async","get","includes","json","text","forEach","value","key","processSSEChunk","chunk","trim","done","startsWith","jsonStr","replace","RegExp","parsedData","parse","data","err","makeHttpRequest","url","timeout","controller","AbortController","id","setTimeout","abort","requestOptions","signal","fetch","clearTimeout","name","API_BASE_URL","makeApiRequest","responseHandler","then","ok","parsedResponse","reader","getReader","decoder","TextDecoder","buffer","read","decode","stream","chunks","split","pop","cancel","handleStreamingResponse","catch","handleFetchError","chrome","runtime","onInstalled","addListener","details","reason","tabs","create","getURL","previousVersion","onConnect","port","onMessage","postMessage","requestConfig","parseApiRequestMessage","endpoint","messageType","portName","sender","sendResponse","senderId","testUrl","URL","version","errorMsg","userMessage","handleTestConnection","request","missingField","onMessageExternal","onConnectExternal","onDisconnect","storage","local","onChanged","changes","area","newValue","initExtension"],"sourceRoot":""}
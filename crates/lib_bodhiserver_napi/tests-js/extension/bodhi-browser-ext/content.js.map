{"version":3,"file":"content.js","mappings":"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","sources":["webpack://bodhi-browser/./src-ext/shared/constants.ts","webpack://bodhi-browser/./src-ext/shared/utils.ts","webpack://bodhi-browser/./src-ext/content.ts"],"sourcesContent":["// Shared constants for Bodhi Browser Extension\n\nexport const CONTENT_TYPE_JSON = 'application/json';\nexport const CONTENT_TYPE_HEADER = 'Content-Type';\nexport const DEFAULT_API_BASE_URL = 'http://localhost:1135';\nexport const DEFAULT_REQUEST_TIMEOUT = 150000; // 2.5 minutes\nexport const BODHI_STREAM_PORT = 'BODHI_STREAM_PORT';\nexport const STORAGE_KEY_BACKEND_URL = 'backendUrl';\nexport const HTTP_METHOD_GET = 'GET';\nexport const HTTP_METHOD_POST = 'POST';\nexport const ENDPOINT_PING = '/ping';\nexport const ENDPOINT_CHAT_COMPLETIONS = '/v1/chat/completions';\nexport const SSE_DONE_MARKER = '[DONE]';\nexport const SSE_DATA_PREFIX = 'data: ';\nexport const SSE_CHUNK_DELIMITER = '\\n\\n';\n\n// Document states\nexport const DOCUMENT_STATE_COMPLETE = 'complete';\n\n// Event names\nexport const EVENT_INITIALIZED = 'bodhiext:initialized';\n\n// Origin fallback\nexport const ORIGIN_WILDCARD = '*';\n\n// Error messages\nexport const ERROR_MISSING_REQUEST_ID = 'Invalid message format: missing requestId or request';\nexport const ERROR_CONNECTION_CLOSED = 'Connection closed unexpectedly';\n\nexport const MESSAGE_TYPES = {\n  API_REQUEST: 'BODHI_API_REQUEST',\n  API_RESPONSE: 'BODHI_API_RESPONSE',\n  STREAM_REQUEST: 'BODHI_STREAM_REQUEST',\n  STREAM_CHUNK: 'BODHI_STREAM_CHUNK',\n  STREAM_ERROR: 'BODHI_STREAM_ERROR',\n  ERROR: 'BODHI_ERROR',\n  GET_EXTENSION_ID: 'BODHI_GET_EXTENSION_ID',\n  SET_EXTENSION_ID: 'BODHI_SET_EXTENSION_ID',\n  TEST_CONNECTION: 'BODHI_TEST_CONNECTION',\n  TEST_CONNECTION_RESPONSE: 'BODHI_TEST_CONNECTION_RESPONSE',\n};\n","/* global RequestInit */\n/// <reference lib=\"dom\" />\n/// Shared utility functions for Bodhi Browser Extension\nimport {\n  MESSAGE_TYPES,\n  CONTENT_TYPE_HEADER,\n  CONTENT_TYPE_JSON,\n  HTTP_METHOD_GET,\n  SSE_DONE_MARKER,\n  SSE_DATA_PREFIX,\n  DEFAULT_REQUEST_TIMEOUT,\n} from './constants.js';\nimport { ApiResponse, ApiResponseMessage, SSEChunk } from './types.js';\n\n// Status code ranges\nconst HTTP_STATUS_OK_MIN = 200;\nconst HTTP_STATUS_OK_MAX = 299;\n\n// Create a shared logger instance\nconst isProd = process.env.NODE_ENV === 'production';\n\nfunction parseLoggerArgs(args: any): any[] {\n  if (typeof args === 'function') {\n    const result = args();\n    if (Array.isArray(result)) {\n      return result;\n    } else if (typeof result === 'object') {\n      return [JSON.stringify(result)];\n    } else {\n      return [result];\n    }\n  } else if (Array.isArray(args)) {\n    return args;\n  } else if (args && typeof args === 'object') {\n    return [JSON.stringify(args)];\n  } else if (args !== undefined) {\n    return [args];\n  }\n  return [];\n}\n\nexport const createLogger = (tag: string) => ({\n  /**\n   * Enhanced info logger for dev/prod optimization.\n   * Usage:\n   *   logger.info('msg', [val1, val2])\n   *   logger.info('msg', () => [val1, val2])\n   *   logger.info('msg', () => ({foo: bar}))\n   *   logger.info('msg', {foo: bar})\n   */\n  info: (message: string, args?: any): void => {\n    if (isProd) return;\n    const values = parseLoggerArgs(args);\n    console.info(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n  /**\n   * Enhanced error logger for dev/prod optimization.\n   * Usage:\n   *   logger.error('msg', [val1, val2])\n   *   logger.error('msg', () => [val1, val2])\n   *   logger.error('msg', () => ({foo: bar}))\n   *   logger.error('msg', {foo: bar})\n   *   logger.error('msg', error)\n   */\n  error: (message: string, args?: any): void => {\n    const values = parseLoggerArgs(args);\n    console.error(`[Bodhi/${tag}] ${message}`, ...values);\n  },\n});\n\nconst logger = createLogger('shared');\n\n/**\n * Centralized error handler to standardize error management across all components\n */\nexport const handleError = (\n  error: Error | string,\n  tag: string = 'unknown',\n  context: Record<string, any> = {}\n): Error => {\n  const errorMessage = typeof error === 'string' ? error : error.message;\n  const errorObj = typeof error === 'string' ? new Error(error) : error;\n\n  // Add context to the error object for debugging\n  Object.assign(errorObj, { context, location: tag });\n\n  // Log the error with contextual information\n  logger.error('Error', { tag, errorMessage, context, stack: errorObj.stack, error: errorObj });\n  return errorObj;\n};\n\n/**\n * Creates an error object with additional properties\n */\nexport const createErrorWithDetails = (message: string, status: number, body: any): Error => {\n  const error: any = new Error(message);\n  error.status = status;\n  error.body = body;\n  return error;\n};\n\n/**\n * Extracts error message from response body if available\n */\nexport const getErrorMessageFromResponse = (\n  response: ApiResponse | undefined,\n  defaultMessage: string\n): string => {\n  if (response?.body?.error?.message) {\n    return response.body.error.message;\n  }\n  return defaultMessage;\n};\n\n/**\n * Checks if a response status indicates success\n */\nexport const isSuccessResponse = (status: number): boolean => {\n  return status >= HTTP_STATUS_OK_MIN && status < HTTP_STATUS_OK_MAX;\n};\n\nexport const createRequestOptions = (\n  method: string,\n  headers: Record<string, string> = {},\n  body: any = null\n): RequestInit => {\n  const options: RequestInit = {\n    method,\n    headers: {\n      [CONTENT_TYPE_HEADER]: CONTENT_TYPE_JSON,\n      ...headers,\n    },\n  };\n  if (method !== HTTP_METHOD_GET && body) {\n    options.body = JSON.stringify(body);\n  }\n  return options;\n};\n\nexport const createErrorResponse = (\n  message: string,\n  requestId: string,\n  isStream: boolean = false\n): ApiResponseMessage => {\n  return {\n    type: isStream ? MESSAGE_TYPES.STREAM_ERROR : MESSAGE_TYPES.API_RESPONSE,\n    requestId,\n    response: {\n      body: {\n        error: {\n          message,\n        },\n      },\n      status: 0,\n      headers: {},\n    },\n  };\n};\n\nexport const parseResponse = async (response: Response): Promise<ApiResponse> => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER) || '';\n  const isJson = contentType.includes(CONTENT_TYPE_JSON);\n  const body = isJson ? await response.json() : await response.text();\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return {\n    body,\n    status: response.status,\n    headers,\n  };\n};\n\nexport const handleFetchError = (\n  error: Error,\n  responseHandler: (response: ApiResponseMessage) => void,\n  requestId: string,\n  isStream: boolean = false\n): void => {\n  logger.error('Error fetching from API', { error });\n  responseHandler(createErrorResponse(error.message, requestId, isStream));\n};\n\nexport const processSSEChunk = (chunk: string): SSEChunk | null => {\n  if (!chunk || chunk.trim() === '') return null;\n\n  // Check for the done marker\n  if (chunk.includes(SSE_DONE_MARKER)) {\n    return { done: true };\n  }\n\n  try {\n    // Check if the chunk starts with the expected data prefix\n    if (!chunk.startsWith(SSE_DATA_PREFIX)) {\n      // If it's a keep-alive comment or other non-data line, ignore it\n      if (chunk.startsWith(':')) {\n        logger.info('Received SSE keep-alive comment');\n        return null;\n      }\n      // Handle malformed chunks\n      logger.info(`Received malformed SSE chunk: ${chunk}`);\n      return null;\n    }\n\n    // Remove \"data: \" prefix from the chunk and parse JSON\n    const jsonStr = chunk.replace(new RegExp(`^${SSE_DATA_PREFIX}`), '');\n    const parsedData = JSON.parse(jsonStr);\n\n    // Validate the parsed data has the expected structure\n    if (parsedData && typeof parsedData === 'object') {\n      return parsedData as SSEChunk;\n    } else {\n      logger.error('Received unexpected SSE data structure', { jsonStr });\n      // Return a typed object instead of raw string\n      return { data: jsonStr };\n    }\n  } catch (error) {\n    const err = error as Error;\n    logger.error('Error processing SSE chunk', { chunk, error: err.message });\n    // Return a typed object instead of raw string\n    return { data: chunk, error: err.message };\n  }\n};\n\n/**\n * Makes an HTTP request with standardized error handling.\n * Can be used in both background and inject scripts.\n */\nexport const makeHttpRequest = async (\n  url: string,\n  options: RequestInit,\n  timeout: number = DEFAULT_REQUEST_TIMEOUT\n): Promise<Response> => {\n  try {\n    // Create an AbortController for timeout handling\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n\n    // Add the signal to the options\n    const requestOptions = {\n      ...options,\n      signal: controller.signal,\n    };\n\n    // Make the request\n    const response = await fetch(url, requestOptions);\n    clearTimeout(id);\n\n    return response;\n  } catch (error) {\n    if ((error as any)?.name === 'AbortError') {\n      throw new Error(`Request timeout after ${timeout}ms: ${url}`);\n    }\n    throw error;\n  }\n};\n","/**\n * Bodhi Browser Plugin content script\n * Injected into web pages to facilitate communication between page and extension\n */\n\n'use strict';\n\n//-----------------------------------------------------------------------------------\n// CONSTANTS AND CONFIGURATION\n//-----------------------------------------------------------------------------------\n\nimport {\n  BODHI_STREAM_PORT,\n  MESSAGE_TYPES,\n  DOCUMENT_STATE_COMPLETE,\n  ORIGIN_WILDCARD,\n  ERROR_MISSING_REQUEST_ID,\n  ERROR_CONNECTION_CLOSED,\n} from './shared/constants.js';\n\nimport {\n  ApiRequestMessage,\n  ApiResponseMessage,\n  StreamChunkMessage,\n  ErrorMessage,\n  GetExtensionIdMessage,\n  SetExtensionIdMessage,\n} from './shared/types.js';\n\nimport { createLogger, createErrorResponse, handleError } from './shared/utils.js';\n\n// Use console namespace to better identify logs\nconst logger = createLogger('content.js');\n\n// Store active stream connections\nconst activeStreams = new Map<string, chrome.runtime.Port>();\n\n//-----------------------------------------------------------------------------------\n// SCRIPT INJECTION\n//-----------------------------------------------------------------------------------\n\n/**\n * Inject our interface script into the page\n */\nconst injectScript = (): void => {\n  try {\n    // Only inject if document is fully loaded\n    if (document.readyState !== DOCUMENT_STATE_COMPLETE) {\n      document.addEventListener('readystatechange', () => {\n        if (document.readyState === DOCUMENT_STATE_COMPLETE) {\n          injectScript();\n        }\n      });\n      return;\n    }\n\n    // Create and inject the script element\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('inject.js');\n\n    // Use a safe approach to handle onload without 'this' typing issues\n    script.onload = () => {\n      script.remove(); // Clean up after loading\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n    logger.info('Interface script injected');\n  } catch (error) {\n    handleError(error as Error, 'content.js:injectScript');\n  }\n};\n\n//-----------------------------------------------------------------------------------\n// MESSAGE HANDLERS\n//-----------------------------------------------------------------------------------\n\n/**\n * Send the extension ID to the page\n */\nconst sendExtensionId = (): void => {\n  try {\n    const extensionId = chrome.runtime.id;\n    logger.info('Sending extension ID to page', { extensionId });\n\n    window.postMessage(\n      {\n        type: MESSAGE_TYPES.SET_EXTENSION_ID,\n        extension_id: extensionId,\n      } as SetExtensionIdMessage,\n      window.origin || ORIGIN_WILDCARD\n    );\n  } catch (error) {\n    handleError(error as Error, 'content.js:sendExtensionId');\n  }\n};\n\n/**\n * Handle generic API message from the page\n */\nconst handleApiMessage = (event: MessageEvent<ApiRequestMessage>): void => {\n  if (!event.data || !event.data.type || event.data.type !== MESSAGE_TYPES.API_REQUEST) {\n    return;\n  }\n  logger.info('Received api request from page', { type: event.data.type });\n\n  try {\n    // Validate request\n    if (!event.data.requestId || !event.data.request) {\n      throw new Error(ERROR_MISSING_REQUEST_ID);\n    }\n\n    // Forward the request to the background script as-is\n    chrome.runtime.sendMessage(event.data, (response: ApiResponseMessage) => {\n      // Forward the response back to the page as-is\n      window.postMessage(response, event.origin || ORIGIN_WILDCARD);\n    });\n  } catch (error) {\n    const err = handleError(error as Error, 'content.js:handleApiMessage');\n\n    // Send error response back to the page\n    if (event.data && event.data.requestId) {\n      window.postMessage(\n        createErrorResponse(err.message, event.data.requestId),\n        event.origin || ORIGIN_WILDCARD\n      );\n    }\n  }\n};\n\n/**\n * Handle get extension ID message\n */\nconst handleGetExtensionId = (event: MessageEvent<GetExtensionIdMessage>): void => {\n  if (!event.data || !event.data.type || event.data.type !== MESSAGE_TYPES.GET_EXTENSION_ID) {\n    return;\n  }\n  logger.info('Received get extension ID request from page', { type: event.data.type });\n  sendExtensionId();\n};\n\n/**\n * Handle streaming API message from the page\n */\nconst handleStreamingMessage = (event: MessageEvent<ApiRequestMessage>): void => {\n  if (!event.data || !event.data.type || event.data.type !== MESSAGE_TYPES.STREAM_REQUEST) {\n    return;\n  }\n  logger.info('Received streaming request from page', { type: event.data.type });\n\n  try {\n    const port = chrome.runtime.connect({ name: BODHI_STREAM_PORT });\n    const requestId = event.data.requestId;\n\n    if (!requestId) {\n      throw new Error(ERROR_MISSING_REQUEST_ID);\n    }\n\n    activeStreams.set(requestId, port);\n\n    // Handle incoming messages from background\n    port.onMessage.addListener((message: StreamChunkMessage | ErrorMessage) => {\n      window.postMessage(message, event.origin || ORIGIN_WILDCARD);\n\n      // Close connection when stream is done or has error\n      if (\n        (message.type === MESSAGE_TYPES.STREAM_CHUNK && message.response.body.done) ||\n        message.type === MESSAGE_TYPES.STREAM_ERROR\n      ) {\n        activeStreams.delete(requestId);\n        port.disconnect();\n      }\n    });\n\n    // Handle disconnection\n    port.onDisconnect.addListener(() => {\n      if (activeStreams.has(requestId)) {\n        // Send an error if the port was closed unexpectedly\n        window.postMessage(\n          createErrorResponse(ERROR_CONNECTION_CLOSED, requestId, true),\n          event.origin || ORIGIN_WILDCARD\n        );\n\n        activeStreams.delete(requestId);\n      }\n    });\n\n    // Send the streaming request to the background script\n    port.postMessage(event.data);\n  } catch (error) {\n    const err = handleError(error as Error, 'content.js:handleStreamingMessage');\n\n    // Send error response back to the page\n    if (event.data && event.data.requestId) {\n      window.postMessage(\n        createErrorResponse(err.message, event.data.requestId, true),\n        event.origin || ORIGIN_WILDCARD\n      );\n    }\n  }\n};\n\n//-----------------------------------------------------------------------------------\n// EVENT LISTENERS\n//-----------------------------------------------------------------------------------\n\n/**\n * Type guard to check if a message is an API request\n */\nfunction isApiRequestMessage(message: any): message is ApiRequestMessage {\n  return message?.type === MESSAGE_TYPES.API_REQUEST;\n}\n\n/**\n * Type guard to check if a message is a stream request\n */\nfunction isStreamRequestMessage(message: any): message is ApiRequestMessage {\n  return message?.type === MESSAGE_TYPES.STREAM_REQUEST;\n}\n\n/**\n * Type guard to check if a message is a get extension ID request\n */\nfunction isGetExtensionIdMessage(message: any): message is GetExtensionIdMessage {\n  return message?.type === MESSAGE_TYPES.GET_EXTENSION_ID;\n}\n\n/**\n * Register message listeners to handle communication with the page\n */\nfunction registerMessageListeners(): void {\n  if (document.readyState !== DOCUMENT_STATE_COMPLETE) {\n    document.addEventListener('readystatechange', () => {\n      if (document.readyState === DOCUMENT_STATE_COMPLETE) {\n        registerMessageListeners();\n      }\n    });\n    return;\n  }\n\n  // Listen for messages from the page\n  window.addEventListener('message', (event: MessageEvent) => {\n    // Make sure the message is from the page we're injected into\n    if (event.source !== window) return;\n\n    // Route message to appropriate handler based on type\n    if (isApiRequestMessage(event.data)) {\n      handleApiMessage(event as MessageEvent<ApiRequestMessage>);\n    } else if (isStreamRequestMessage(event.data)) {\n      handleStreamingMessage(event as MessageEvent<ApiRequestMessage>);\n    } else if (isGetExtensionIdMessage(event.data)) {\n      handleGetExtensionId(event as MessageEvent<GetExtensionIdMessage>);\n    }\n  });\n\n  logger.info('Message listeners registered');\n}\n\n//-----------------------------------------------------------------------------------\n// INITIALIZATION\n//-----------------------------------------------------------------------------------\n\n/**\n * Initialize the content script\n * Sets up script injection and message listeners\n */\nconst initContentScript = (): void => {\n  try {\n    logger.info('Content script initializing');\n    injectScript();\n    registerMessageListeners();\n    logger.info('Content script initialized');\n  } catch (error) {\n    handleError(error as Error, 'content.js:initContentScript');\n  }\n};\n\n// Start the content script\ninitContentScript();\n"],"names":["DOCUMENT_STATE_COMPLETE","ORIGIN_WILDCARD","ERROR_MISSING_REQUEST_ID","MESSAGE_TYPES","createLogger","tag","info","message","args","error","values","result","Array","isArray","JSON","stringify","undefined","parseLoggerArgs","console","logger","handleError","context","errorMessage","errorObj","Error","Object","assign","location","stack","createErrorResponse","requestId","isStream","type","response","body","status","headers","activeStreams","Map","injectScript","document","readyState","addEventListener","script","createElement","src","chrome","runtime","getURL","onload","remove","head","documentElement","appendChild","registerMessageListeners","window","event","source","data","request","sendMessage","postMessage","origin","err","handleApiMessage","isStreamRequestMessage","port","connect","name","set","onMessage","addListener","done","delete","disconnect","onDisconnect","has","handleStreamingMessage","isGetExtensionIdMessage","extensionId","id","extension_id","sendExtensionId","handleGetExtensionId","initContentScript"],"sourceRoot":""}
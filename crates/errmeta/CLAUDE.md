# CLAUDE.md - errmeta Crate

See [crates/errmeta/PACKAGE.md](crates/errmeta/PACKAGE.md) for implementation details.

## Purpose

The `errmeta` crate is BodhiApp's **minimal error infrastructure foundation** -- a zero-framework dependency crate that defines the core error contract (`AppError` trait), the HTTP error category enumeration (`ErrorType`), and a small set of universal error types used across the entire crate graph. It exists so that crates with minimal dependency requirements (like `llama_server_proc` and `mcp_client`) can participate in BodhiApp's structured error system without pulling in framework dependencies like `axum`, `serde`, or `sea-orm`.

## Architecture Position

**Upstream dependencies** (crates this depends on):
- [`errmeta_derive`](../errmeta_derive/CLAUDE.md) -- `#[derive(ErrorMeta)]` proc macro for generating `AppError` trait implementations

**Downstream consumers** (every Rust crate in the workspace depends on this, directly or transitively):
- [`llama_server_proc`](../llama_server_proc/CLAUDE.md) -- LLM process management (lightweight, no framework deps)
- [`mcp_client`](../mcp_client/) -- MCP protocol client (lightweight, no framework deps)
- [`services`](../services/CLAUDE.md) -- business logic layer (re-exports all errmeta types)
- All other crates consume errmeta transitively through `services`

## Architectural Design Rationale

### Why errmeta Exists as a Separate Crate

Before this refactoring, BodhiApp had a monolithic `objs` crate that served as the universal foundation layer, containing everything from error infrastructure to domain types to serde-dependent API error envelopes. This created a problem: crates like `llama_server_proc` that only needed the `AppError` trait and `ErrorType` enum were forced to depend on `objs` and transitively pull in `axum`, `serde`, `sea-orm`, and dozens of other framework dependencies.

The `errmeta` crate was extracted to solve this dependency fan-out problem:

1. **Minimal Dependency Surface**: Only depends on `errmeta_derive` (proc macro), `strum` (enum string conversion), and `thiserror` (error derive). No framework, serialization, or database dependencies.
2. **Universal Error Contract**: The `AppError` trait defines the interface that all BodhiApp errors must satisfy -- `error_type()`, `code()`, `args()`, and the derived `status()`. This contract is the foundation of the entire error-to-HTTP-response pipeline.
3. **Lightweight Adoption**: Crates that manage processes (`llama_server_proc`) or protocol clients (`mcp_client`) can implement structured errors without framework bloat.
4. **Re-export Strategy**: The `services` crate re-exports all errmeta types (`pub use errmeta::{impl_error_from, AppError, EntityError, ErrorType, IoError, RwLockReadError}`), so downstream crates that already depend on `services` never need to add `errmeta` as a direct dependency.

### What Lives Here vs. What Lives in services

The boundary is clear: **errmeta contains error types that need zero framework dependencies**. Types that depend on `axum` (like `ApiError`, `JsonRejectionError`), `serde` (like `OpenAIApiError`, `SerdeJsonError`), or `validator` (like `ObjValidationError`) live in `services::shared_objs` instead.

| errmeta (no framework deps) | services::shared_objs (framework deps) |
|---|---|
| `AppError` trait | `ApiError` (axum `IntoResponse`) |
| `ErrorType` enum | `OpenAIApiError` (serde, utoipa) |
| `IoError` enum | `SerdeJsonError` (serde_json) |
| `EntityError` enum | `SerdeYamlError` (serde_yaml) |
| `RwLockReadError` struct | `ReqwestError` (reqwest) |
| `impl_error_from!` macro | `JsonRejectionError` (axum) |
| | `ObjValidationError` (validator) |

## Core Error Contract

### AppError Trait

The `AppError` trait is the central error abstraction. Every domain error enum in BodhiApp implements this trait (usually via `#[derive(ErrorMeta)]`):

- `error_type() -> String`: Returns the HTTP error category (e.g., `"invalid_request_error"`, `"internal_server_error"`). Maps to `ErrorType` enum serialized names.
- `status() -> u16`: Derives HTTP status code from `error_type()` by parsing back to `ErrorType`. Defaults to 500 if parsing fails.
- `code() -> String`: Returns the machine-readable error code (e.g., `"entity_error-not_found"`). Auto-generated by `errmeta_derive` as `{enum_name_snake_case}-{variant_name_snake_case}`.
- `args() -> HashMap<String, String>`: Returns error context as key-value pairs for templated error messages.

The trait also provides blanket `From<T: AppError>` for `Box<dyn AppError>`, enabling trait object usage for heterogeneous error collections.

### ErrorType Enum

Maps semantic error categories to HTTP status codes:

| Variant | Serialized Name | HTTP Status |
|---|---|---|
| `BadRequest` | `invalid_request_error` | 400 |
| `Authentication` | `authentication_error` | 401 |
| `Forbidden` | `forbidden_error` | 403 |
| `NotFound` | `not_found_error` | 404 |
| `Conflict` | `conflict_error` | 409 |
| `UnprocessableEntity` | `unprocessable_entity_error` | 422 |
| `InternalServer` | `internal_server_error` | 500 |
| `InvalidAppState` | `invalid_app_state` | 500 |
| `Unknown` (default) | `unknown_error` | 500 |
| `ServiceUnavailable` | `service_unavailable` | 503 |

The `Default` impl returns `Unknown` (500), ensuring unknown error types fail safely.

**Serialization inconsistency note**: Most variants follow the `{name}_error` suffix convention (e.g., `BadRequest` -> `invalid_request_error`, `Authentication` -> `authentication_error`). However, `ServiceUnavailable` serializes as `service_unavailable` (no `_error` suffix) and `InvalidAppState` serializes as `invalid_app_state` (no `_error` suffix). This inconsistency is intentional and maintained for backward compatibility with existing error codes in production.

### impl_error_from! Macro

Bridges Rust's orphan rule for external error type conversions. When you need `From<ExternalError> for YourServiceError` but `ExternalError` is from a third-party crate, the macro generates a two-step conversion through an intermediate wrapper type:

```
ExternalError -> IntermediateWrapper (via From) -> ServiceError::Variant (via #[from])
```

Usage: `impl_error_from!(source_type, target_enum::variant, intermediate_type)`

This pattern is pervasive -- used ~20 times across the codebase for bridging `std::io::Error`, `reqwest::Error`, `serde_json::Error`, `serde_yaml::Error`, etc.

## Universal Error Types

### IoError

A consolidated enum for all filesystem operation errors, replacing what was previously 6 separate IO error structs. Each variant captures both the `std::io::Error` source and the filesystem path for diagnostics:

- `Io` -- bare IO error (no path context, has `#[from]` for auto-conversion)
- `WithPath` -- generic IO error with path
- `DirCreate` -- directory creation failure
- `FileRead` -- file read failure
- `FileWrite` -- file write failure
- `FileDelete` -- file delete failure

Convenience constructors (`IoError::file_read(err, path)`, etc.) provide ergonomic error creation. All variants map to `ErrorType::InternalServer` (500).

### EntityError

A simple not-found error for entity lookups: `EntityError::NotFound(String)`. Maps to `ErrorType::NotFound` (404). Used across service and middleware layers for generic entity-not-found scenarios.

### RwLockReadError

A concurrency error for poisoned `RwLock` reads. Has a manual `AppError` implementation (not derived via `ErrorMeta`) because its single-field struct layout doesn't fit the enum-based `ErrorMeta` pattern. Maps to `ErrorType::InternalServer` (500).

## Error Flow Through the System

```
errmeta defines:   AppError trait, ErrorType, IoError, EntityError
                        |
errmeta_derive:    #[derive(ErrorMeta)] generates AppError impl
                        |
services defines:  Domain error enums (DataServiceError, HubServiceError, etc.)
                   each implementing AppError via ErrorMeta
                        |
services defines:  ApiError (From<T: AppError>) - captures error metadata
                        |
services defines:  OpenAIApiError (From<ApiError>) - OpenAI-compatible envelope
                        |
axum:              IntoResponse for ApiError -> JSON HTTP response
```

## Testing Patterns

Tests use `#[rstest]` with `pretty_assertions::assert_eq`. Test files follow the sibling file pattern: `test_error_type.rs`, `test_entity_error.rs`, `test_io_error.rs`, `test_rwlock_error.rs`.

Key testing focus areas:
- ErrorType serialization round-trips (string -> enum -> status code)
- IoError convenience constructors preserve source error and path
- AppError trait implementation correctness (error_type, code, args)
- Error code format validation (snake_case naming convention)
